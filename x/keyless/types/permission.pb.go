// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: selfchain/keyless/permission.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// WalletPermission represents the type of permission
type WalletPermission int32

const (
	// WALLET_PERMISSION_UNSPECIFIED represents an unspecified permission
	WalletPermission_WALLET_PERMISSION_UNSPECIFIED WalletPermission = 0
	// WALLET_PERMISSION_SIGN represents permission to sign transactions
	WalletPermission_WALLET_PERMISSION_SIGN WalletPermission = 1
	// WALLET_PERMISSION_RECOVER represents permission to initiate recovery
	WalletPermission_WALLET_PERMISSION_RECOVER WalletPermission = 2
	// WALLET_PERMISSION_ROTATE represents permission to rotate keys
	WalletPermission_WALLET_PERMISSION_ROTATE WalletPermission = 3
	// WALLET_PERMISSION_ADMIN represents admin permissions
	WalletPermission_WALLET_PERMISSION_ADMIN WalletPermission = 4
)

var WalletPermission_name = map[int32]string{
	0: "WALLET_PERMISSION_UNSPECIFIED",
	1: "WALLET_PERMISSION_SIGN",
	2: "WALLET_PERMISSION_RECOVER",
	3: "WALLET_PERMISSION_ROTATE",
	4: "WALLET_PERMISSION_ADMIN",
}

var WalletPermission_value = map[string]int32{
	"WALLET_PERMISSION_UNSPECIFIED": 0,
	"WALLET_PERMISSION_SIGN":        1,
	"WALLET_PERMISSION_RECOVER":     2,
	"WALLET_PERMISSION_ROTATE":      3,
	"WALLET_PERMISSION_ADMIN":       4,
}

func (x WalletPermission) String() string {
	return proto.EnumName(WalletPermission_name, int32(x))
}

func (WalletPermission) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8860031affef9c95, []int{0}
}

// Permission represents a wallet permission
type Permission struct {
	WalletAddress string     `protobuf:"bytes,1,opt,name=wallet_address,json=walletAddress,proto3" json:"wallet_address,omitempty"`
	Grantee       string     `protobuf:"bytes,2,opt,name=grantee,proto3" json:"grantee,omitempty"`
	Permissions   []string   `protobuf:"bytes,3,rep,name=permissions,proto3" json:"permissions,omitempty"`
	GrantedAt     *time.Time `protobuf:"bytes,4,opt,name=granted_at,json=grantedAt,proto3,stdtime" json:"granted_at,omitempty"`
	ExpiresAt     *time.Time `protobuf:"bytes,5,opt,name=expires_at,json=expiresAt,proto3,stdtime" json:"expires_at,omitempty"`
	Revoked       bool       `protobuf:"varint,6,opt,name=revoked,proto3" json:"revoked,omitempty"`
	RevokedAt     *time.Time `protobuf:"bytes,7,opt,name=revoked_at,json=revokedAt,proto3,stdtime" json:"revoked_at,omitempty"`
}

func (m *Permission) Reset()         { *m = Permission{} }
func (m *Permission) String() string { return proto.CompactTextString(m) }
func (*Permission) ProtoMessage()    {}
func (*Permission) Descriptor() ([]byte, []int) {
	return fileDescriptor_8860031affef9c95, []int{0}
}
func (m *Permission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Permission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Permission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Permission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Permission.Merge(m, src)
}
func (m *Permission) XXX_Size() int {
	return m.Size()
}
func (m *Permission) XXX_DiscardUnknown() {
	xxx_messageInfo_Permission.DiscardUnknown(m)
}

var xxx_messageInfo_Permission proto.InternalMessageInfo

func (m *Permission) GetWalletAddress() string {
	if m != nil {
		return m.WalletAddress
	}
	return ""
}

func (m *Permission) GetGrantee() string {
	if m != nil {
		return m.Grantee
	}
	return ""
}

func (m *Permission) GetPermissions() []string {
	if m != nil {
		return m.Permissions
	}
	return nil
}

func (m *Permission) GetGrantedAt() *time.Time {
	if m != nil {
		return m.GrantedAt
	}
	return nil
}

func (m *Permission) GetExpiresAt() *time.Time {
	if m != nil {
		return m.ExpiresAt
	}
	return nil
}

func (m *Permission) GetRevoked() bool {
	if m != nil {
		return m.Revoked
	}
	return false
}

func (m *Permission) GetRevokedAt() *time.Time {
	if m != nil {
		return m.RevokedAt
	}
	return nil
}

// PermissionGrant represents a permission grant request
type PermissionGrant struct {
	WalletAddress string             `protobuf:"bytes,1,opt,name=wallet_address,json=walletAddress,proto3" json:"wallet_address,omitempty"`
	Grantee       string             `protobuf:"bytes,2,opt,name=grantee,proto3" json:"grantee,omitempty"`
	Permissions   []WalletPermission `protobuf:"varint,3,rep,packed,name=permissions,proto3,enum=selfchain.keyless.WalletPermission" json:"permissions,omitempty"`
	ExpiresAt     *time.Time         `protobuf:"bytes,4,opt,name=expires_at,json=expiresAt,proto3,stdtime" json:"expires_at,omitempty"`
}

func (m *PermissionGrant) Reset()         { *m = PermissionGrant{} }
func (m *PermissionGrant) String() string { return proto.CompactTextString(m) }
func (*PermissionGrant) ProtoMessage()    {}
func (*PermissionGrant) Descriptor() ([]byte, []int) {
	return fileDescriptor_8860031affef9c95, []int{1}
}
func (m *PermissionGrant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PermissionGrant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PermissionGrant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PermissionGrant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PermissionGrant.Merge(m, src)
}
func (m *PermissionGrant) XXX_Size() int {
	return m.Size()
}
func (m *PermissionGrant) XXX_DiscardUnknown() {
	xxx_messageInfo_PermissionGrant.DiscardUnknown(m)
}

var xxx_messageInfo_PermissionGrant proto.InternalMessageInfo

func (m *PermissionGrant) GetWalletAddress() string {
	if m != nil {
		return m.WalletAddress
	}
	return ""
}

func (m *PermissionGrant) GetGrantee() string {
	if m != nil {
		return m.Grantee
	}
	return ""
}

func (m *PermissionGrant) GetPermissions() []WalletPermission {
	if m != nil {
		return m.Permissions
	}
	return nil
}

func (m *PermissionGrant) GetExpiresAt() *time.Time {
	if m != nil {
		return m.ExpiresAt
	}
	return nil
}

// PermissionRevoke represents a permission revocation request
type PermissionRevoke struct {
	WalletAddress string             `protobuf:"bytes,1,opt,name=wallet_address,json=walletAddress,proto3" json:"wallet_address,omitempty"`
	Grantee       string             `protobuf:"bytes,2,opt,name=grantee,proto3" json:"grantee,omitempty"`
	Permissions   []WalletPermission `protobuf:"varint,3,rep,packed,name=permissions,proto3,enum=selfchain.keyless.WalletPermission" json:"permissions,omitempty"`
}

func (m *PermissionRevoke) Reset()         { *m = PermissionRevoke{} }
func (m *PermissionRevoke) String() string { return proto.CompactTextString(m) }
func (*PermissionRevoke) ProtoMessage()    {}
func (*PermissionRevoke) Descriptor() ([]byte, []int) {
	return fileDescriptor_8860031affef9c95, []int{2}
}
func (m *PermissionRevoke) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PermissionRevoke) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PermissionRevoke.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PermissionRevoke) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PermissionRevoke.Merge(m, src)
}
func (m *PermissionRevoke) XXX_Size() int {
	return m.Size()
}
func (m *PermissionRevoke) XXX_DiscardUnknown() {
	xxx_messageInfo_PermissionRevoke.DiscardUnknown(m)
}

var xxx_messageInfo_PermissionRevoke proto.InternalMessageInfo

func (m *PermissionRevoke) GetWalletAddress() string {
	if m != nil {
		return m.WalletAddress
	}
	return ""
}

func (m *PermissionRevoke) GetGrantee() string {
	if m != nil {
		return m.Grantee
	}
	return ""
}

func (m *PermissionRevoke) GetPermissions() []WalletPermission {
	if m != nil {
		return m.Permissions
	}
	return nil
}

func init() {
	proto.RegisterEnum("selfchain.keyless.WalletPermission", WalletPermission_name, WalletPermission_value)
	proto.RegisterType((*Permission)(nil), "selfchain.keyless.Permission")
	proto.RegisterType((*PermissionGrant)(nil), "selfchain.keyless.PermissionGrant")
	proto.RegisterType((*PermissionRevoke)(nil), "selfchain.keyless.PermissionRevoke")
}

func init() {
	proto.RegisterFile("selfchain/keyless/permission.proto", fileDescriptor_8860031affef9c95)
}

var fileDescriptor_8860031affef9c95 = []byte{
	// 462 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x54, 0xcb, 0x6e, 0xd3, 0x40,
	0x14, 0xcd, 0x24, 0xa1, 0x6d, 0x6e, 0x45, 0x31, 0x23, 0x04, 0x6e, 0xa0, 0x8e, 0x09, 0x42, 0x8a,
	0x58, 0xd8, 0x52, 0xfb, 0x05, 0x6e, 0x3a, 0x54, 0x96, 0xda, 0x24, 0xb2, 0x0d, 0x95, 0xd8, 0x58,
	0x2e, 0x9e, 0x1a, 0xab, 0x4e, 0xc6, 0xf2, 0x0c, 0xd0, 0xfe, 0x45, 0xd7, 0xfc, 0x02, 0x3f, 0xd2,
	0x65, 0x97, 0x5d, 0x15, 0x94, 0xfc, 0x08, 0xf2, 0x2b, 0x8e, 0x30, 0x9b, 0xc2, 0x86, 0x9d, 0xef,
	0x3d, 0xe7, 0x9e, 0x39, 0xf7, 0x8c, 0x35, 0xd0, 0xe7, 0x34, 0x3a, 0xfb, 0xf8, 0xc9, 0x0b, 0x67,
	0xfa, 0x39, 0xbd, 0x8c, 0x28, 0xe7, 0x7a, 0x4c, 0x93, 0x69, 0xc8, 0x79, 0xc8, 0x66, 0x5a, 0x9c,
	0x30, 0xc1, 0xf0, 0xe3, 0x25, 0x47, 0x2b, 0x38, 0xdd, 0x27, 0x01, 0x0b, 0x58, 0x86, 0xea, 0xe9,
	0x57, 0x4e, 0xec, 0xf6, 0x02, 0xc6, 0x82, 0x88, 0xea, 0x59, 0x75, 0xfa, 0xf9, 0x4c, 0x17, 0xe1,
	0x94, 0x72, 0xe1, 0x4d, 0xe3, 0x9c, 0xd0, 0xbf, 0x6d, 0x02, 0x4c, 0x96, 0xf2, 0xf8, 0x35, 0x6c,
	0x7d, 0xf5, 0xa2, 0x88, 0x0a, 0xd7, 0xf3, 0xfd, 0x84, 0x72, 0x2e, 0x23, 0x15, 0x0d, 0x3a, 0xd6,
	0xc3, 0xbc, 0x6b, 0xe4, 0x4d, 0x2c, 0xc3, 0x7a, 0x90, 0x78, 0x33, 0x41, 0xa9, 0xdc, 0xcc, 0xf0,
	0xb2, 0xc4, 0x2a, 0x6c, 0x56, 0x6e, 0xb9, 0xdc, 0x52, 0x5b, 0x83, 0x8e, 0xb5, 0xda, 0xc2, 0x43,
	0x80, 0x9c, 0xec, 0xbb, 0x9e, 0x90, 0xdb, 0x2a, 0x1a, 0x6c, 0xee, 0x76, 0xb5, 0xdc, 0xa7, 0x56,
	0xfa, 0xd4, 0x9c, 0xd2, 0xe7, 0xfe, 0xc6, 0xf5, 0x5d, 0x0f, 0x5d, 0xfd, 0xe8, 0x21, 0xab, 0x53,
	0xcc, 0x19, 0x22, 0x15, 0xa1, 0x17, 0x71, 0x98, 0x50, 0x9e, 0x8a, 0x3c, 0xb8, 0x8f, 0x48, 0x31,
	0x67, 0x88, 0x74, 0x8b, 0x84, 0x7e, 0x61, 0xe7, 0xd4, 0x97, 0xd7, 0x54, 0x34, 0xd8, 0xb0, 0xca,
	0x32, 0x95, 0x2f, 0x3e, 0x53, 0xf9, 0xf5, 0xfb, 0xc8, 0x17, 0x73, 0x86, 0xe8, 0xdf, 0x21, 0x78,
	0x54, 0x45, 0x7b, 0x98, 0x7a, 0xff, 0xf7, 0x7c, 0x49, 0x3d, 0xdf, 0xad, 0xdd, 0x57, 0x5a, 0xed,
	0x7f, 0xd0, 0x4e, 0x32, 0xc1, 0xea, 0xfc, 0xda, 0x25, 0xac, 0xe4, 0xd7, 0xfe, 0xab, 0xfc, 0xfa,
	0xdf, 0x10, 0x48, 0x2b, 0x07, 0x64, 0x8b, 0xff, 0x2f, 0x1b, 0xbe, 0xf9, 0x8e, 0x40, 0xfa, 0x9d,
	0x81, 0x5f, 0xc2, 0xce, 0x89, 0x71, 0x74, 0x44, 0x1c, 0x77, 0x42, 0xac, 0x63, 0xd3, 0xb6, 0xcd,
	0xf1, 0xc8, 0x7d, 0x37, 0xb2, 0x27, 0x64, 0x68, 0xbe, 0x35, 0xc9, 0x81, 0xd4, 0xc0, 0x5d, 0x78,
	0x5a, 0xa7, 0xd8, 0xe6, 0xe1, 0x48, 0x42, 0x78, 0x07, 0xb6, 0xeb, 0x98, 0x45, 0x86, 0xe3, 0xf7,
	0xc4, 0x92, 0x9a, 0xf8, 0x05, 0xc8, 0x7f, 0x80, 0xc7, 0x8e, 0xe1, 0x10, 0xa9, 0x85, 0x9f, 0xc3,
	0xb3, 0x3a, 0x6a, 0x1c, 0x1c, 0x9b, 0x23, 0xa9, 0xbd, 0xbf, 0x77, 0x3d, 0x57, 0xd0, 0xcd, 0x5c,
	0x41, 0x3f, 0xe7, 0x0a, 0xba, 0x5a, 0x28, 0x8d, 0x9b, 0x85, 0xd2, 0xb8, 0x5d, 0x28, 0x8d, 0x0f,
	0xdb, 0xd5, 0x73, 0x70, 0xb1, 0x7c, 0x10, 0xc4, 0x65, 0x4c, 0xf9, 0xe9, 0x5a, 0x76, 0x51, 0x7b,
	0xbf, 0x02, 0x00, 0x00, 0xff, 0xff, 0x69, 0xcd, 0x4e, 0xc1, 0x32, 0x04, 0x00, 0x00,
}

func (m *Permission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Permission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Permission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RevokedAt != nil {
		n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.RevokedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.RevokedAt):])
		if err1 != nil {
			return 0, err1
		}
		i -= n1
		i = encodeVarintPermission(dAtA, i, uint64(n1))
		i--
		dAtA[i] = 0x3a
	}
	if m.Revoked {
		i--
		if m.Revoked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.ExpiresAt != nil {
		n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.ExpiresAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ExpiresAt):])
		if err2 != nil {
			return 0, err2
		}
		i -= n2
		i = encodeVarintPermission(dAtA, i, uint64(n2))
		i--
		dAtA[i] = 0x2a
	}
	if m.GrantedAt != nil {
		n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.GrantedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.GrantedAt):])
		if err3 != nil {
			return 0, err3
		}
		i -= n3
		i = encodeVarintPermission(dAtA, i, uint64(n3))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Permissions) > 0 {
		for iNdEx := len(m.Permissions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Permissions[iNdEx])
			copy(dAtA[i:], m.Permissions[iNdEx])
			i = encodeVarintPermission(dAtA, i, uint64(len(m.Permissions[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Grantee) > 0 {
		i -= len(m.Grantee)
		copy(dAtA[i:], m.Grantee)
		i = encodeVarintPermission(dAtA, i, uint64(len(m.Grantee)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.WalletAddress) > 0 {
		i -= len(m.WalletAddress)
		copy(dAtA[i:], m.WalletAddress)
		i = encodeVarintPermission(dAtA, i, uint64(len(m.WalletAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PermissionGrant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PermissionGrant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PermissionGrant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiresAt != nil {
		n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.ExpiresAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ExpiresAt):])
		if err4 != nil {
			return 0, err4
		}
		i -= n4
		i = encodeVarintPermission(dAtA, i, uint64(n4))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Permissions) > 0 {
		dAtA6 := make([]byte, len(m.Permissions)*10)
		var j5 int
		for _, num := range m.Permissions {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintPermission(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Grantee) > 0 {
		i -= len(m.Grantee)
		copy(dAtA[i:], m.Grantee)
		i = encodeVarintPermission(dAtA, i, uint64(len(m.Grantee)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.WalletAddress) > 0 {
		i -= len(m.WalletAddress)
		copy(dAtA[i:], m.WalletAddress)
		i = encodeVarintPermission(dAtA, i, uint64(len(m.WalletAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PermissionRevoke) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PermissionRevoke) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PermissionRevoke) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Permissions) > 0 {
		dAtA8 := make([]byte, len(m.Permissions)*10)
		var j7 int
		for _, num := range m.Permissions {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintPermission(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Grantee) > 0 {
		i -= len(m.Grantee)
		copy(dAtA[i:], m.Grantee)
		i = encodeVarintPermission(dAtA, i, uint64(len(m.Grantee)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.WalletAddress) > 0 {
		i -= len(m.WalletAddress)
		copy(dAtA[i:], m.WalletAddress)
		i = encodeVarintPermission(dAtA, i, uint64(len(m.WalletAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPermission(dAtA []byte, offset int, v uint64) int {
	offset -= sovPermission(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Permission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WalletAddress)
	if l > 0 {
		n += 1 + l + sovPermission(uint64(l))
	}
	l = len(m.Grantee)
	if l > 0 {
		n += 1 + l + sovPermission(uint64(l))
	}
	if len(m.Permissions) > 0 {
		for _, s := range m.Permissions {
			l = len(s)
			n += 1 + l + sovPermission(uint64(l))
		}
	}
	if m.GrantedAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.GrantedAt)
		n += 1 + l + sovPermission(uint64(l))
	}
	if m.ExpiresAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ExpiresAt)
		n += 1 + l + sovPermission(uint64(l))
	}
	if m.Revoked {
		n += 2
	}
	if m.RevokedAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.RevokedAt)
		n += 1 + l + sovPermission(uint64(l))
	}
	return n
}

func (m *PermissionGrant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WalletAddress)
	if l > 0 {
		n += 1 + l + sovPermission(uint64(l))
	}
	l = len(m.Grantee)
	if l > 0 {
		n += 1 + l + sovPermission(uint64(l))
	}
	if len(m.Permissions) > 0 {
		l = 0
		for _, e := range m.Permissions {
			l += sovPermission(uint64(e))
		}
		n += 1 + sovPermission(uint64(l)) + l
	}
	if m.ExpiresAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ExpiresAt)
		n += 1 + l + sovPermission(uint64(l))
	}
	return n
}

func (m *PermissionRevoke) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WalletAddress)
	if l > 0 {
		n += 1 + l + sovPermission(uint64(l))
	}
	l = len(m.Grantee)
	if l > 0 {
		n += 1 + l + sovPermission(uint64(l))
	}
	if len(m.Permissions) > 0 {
		l = 0
		for _, e := range m.Permissions {
			l += sovPermission(uint64(e))
		}
		n += 1 + sovPermission(uint64(l)) + l
	}
	return n
}

func sovPermission(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPermission(x uint64) (n int) {
	return sovPermission(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Permission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermission
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Permission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Permission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermission
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermission
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermission
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WalletAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grantee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermission
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermission
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermission
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grantee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermission
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermission
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermission
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permissions = append(m.Permissions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrantedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermission
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermission
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermission
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GrantedAt == nil {
				m.GrantedAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.GrantedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermission
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermission
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermission
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpiresAt == nil {
				m.ExpiresAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.ExpiresAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revoked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermission
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Revoked = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevokedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermission
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermission
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermission
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RevokedAt == nil {
				m.RevokedAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.RevokedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermission(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermission
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PermissionGrant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermission
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PermissionGrant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PermissionGrant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermission
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermission
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermission
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WalletAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grantee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermission
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermission
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermission
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grantee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v WalletPermission
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPermission
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= WalletPermission(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Permissions = append(m.Permissions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPermission
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPermission
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPermission
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Permissions) == 0 {
					m.Permissions = make([]WalletPermission, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v WalletPermission
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPermission
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= WalletPermission(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Permissions = append(m.Permissions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermission
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermission
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermission
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpiresAt == nil {
				m.ExpiresAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.ExpiresAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermission(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermission
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PermissionRevoke) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermission
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PermissionRevoke: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PermissionRevoke: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermission
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermission
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermission
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WalletAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grantee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermission
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermission
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermission
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grantee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v WalletPermission
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPermission
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= WalletPermission(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Permissions = append(m.Permissions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPermission
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPermission
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPermission
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Permissions) == 0 {
					m.Permissions = make([]WalletPermission, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v WalletPermission
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPermission
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= WalletPermission(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Permissions = append(m.Permissions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPermission(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermission
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPermission(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPermission
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPermission
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPermission
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPermission
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPermission
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPermission
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPermission        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPermission          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPermission = fmt.Errorf("proto: unexpected end of group")
)
