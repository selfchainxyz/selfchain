// Code generated by mockery v2.51.1. DO NOT EDIT.

package mocks

import (
	identitytypes "selfchain/x/identity/types"

	mock "github.com/stretchr/testify/mock"

	types "github.com/cosmos/cosmos-sdk/types"
)

// IdentityKeeper is an autogenerated mock type for the IdentityKeeper type
type IdentityKeeper struct {
	mock.Mock
}

// CheckRateLimit provides a mock function with given fields: ctx, did, operation
func (_m *IdentityKeeper) CheckRateLimit(ctx types.Context, did string, operation string) error {
	ret := _m.Called(ctx, did, operation)

	if len(ret) == 0 {
		panic("no return value specified for CheckRateLimit")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Context, string, string) error); ok {
		r0 = rf(ctx, did, operation)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GenerateRecoveryToken provides a mock function with given fields: ctx, walletID
func (_m *IdentityKeeper) GenerateRecoveryToken(ctx types.Context, walletID string) (string, error) {
	ret := _m.Called(ctx, walletID)

	if len(ret) == 0 {
		panic("no return value specified for GenerateRecoveryToken")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Context, string) (string, error)); ok {
		return rf(ctx, walletID)
	}
	if rf, ok := ret.Get(0).(func(types.Context, string) string); ok {
		r0 = rf(ctx, walletID)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(types.Context, string) error); ok {
		r1 = rf(ctx, walletID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDIDDocument provides a mock function with given fields: ctx, did
func (_m *IdentityKeeper) GetDIDDocument(ctx types.Context, did string) (identitytypes.DIDDocument, bool) {
	ret := _m.Called(ctx, did)

	if len(ret) == 0 {
		panic("no return value specified for GetDIDDocument")
	}

	var r0 identitytypes.DIDDocument
	var r1 bool
	if rf, ok := ret.Get(0).(func(types.Context, string) (identitytypes.DIDDocument, bool)); ok {
		return rf(ctx, did)
	}
	if rf, ok := ret.Get(0).(func(types.Context, string) identitytypes.DIDDocument); ok {
		r0 = rf(ctx, did)
	} else {
		r0 = ret.Get(0).(identitytypes.DIDDocument)
	}

	if rf, ok := ret.Get(1).(func(types.Context, string) bool); ok {
		r1 = rf(ctx, did)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GetKeyShare provides a mock function with given fields: ctx, did
func (_m *IdentityKeeper) GetKeyShare(ctx types.Context, did string) ([]byte, bool) {
	ret := _m.Called(ctx, did)

	if len(ret) == 0 {
		panic("no return value specified for GetKeyShare")
	}

	var r0 []byte
	var r1 bool
	if rf, ok := ret.Get(0).(func(types.Context, string) ([]byte, bool)); ok {
		return rf(ctx, did)
	}
	if rf, ok := ret.Get(0).(func(types.Context, string) []byte); ok {
		r0 = rf(ctx, did)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Context, string) bool); ok {
		r1 = rf(ctx, did)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// LogAuditEvent provides a mock function with given fields: ctx, event
func (_m *IdentityKeeper) LogAuditEvent(ctx types.Context, event *identitytypes.AuditEvent) error {
	ret := _m.Called(ctx, event)

	if len(ret) == 0 {
		panic("no return value specified for LogAuditEvent")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Context, *identitytypes.AuditEvent) error); ok {
		r0 = rf(ctx, event)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ReconstructWallet provides a mock function with given fields: ctx, didDoc
func (_m *IdentityKeeper) ReconstructWallet(ctx types.Context, didDoc identitytypes.DIDDocument) (interface{}, error) {
	ret := _m.Called(ctx, didDoc)

	if len(ret) == 0 {
		panic("no return value specified for ReconstructWallet")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Context, identitytypes.DIDDocument) (interface{}, error)); ok {
		return rf(ctx, didDoc)
	}
	if rf, ok := ret.Get(0).(func(types.Context, identitytypes.DIDDocument) interface{}); ok {
		r0 = rf(ctx, didDoc)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(types.Context, identitytypes.DIDDocument) error); ok {
		r1 = rf(ctx, didDoc)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ValidateRecoveryToken provides a mock function with given fields: ctx, walletID, token
func (_m *IdentityKeeper) ValidateRecoveryToken(ctx types.Context, walletID string, token string) error {
	ret := _m.Called(ctx, walletID, token)

	if len(ret) == 0 {
		panic("no return value specified for ValidateRecoveryToken")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Context, string, string) error); ok {
		r0 = rf(ctx, walletID, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// VerifyDIDOwnership provides a mock function with given fields: ctx, did, owner
func (_m *IdentityKeeper) VerifyDIDOwnership(ctx types.Context, did string, owner types.AccAddress) error {
	ret := _m.Called(ctx, did, owner)

	if len(ret) == 0 {
		panic("no return value specified for VerifyDIDOwnership")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Context, string, types.AccAddress) error); ok {
		r0 = rf(ctx, did, owner)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// VerifyMFA provides a mock function with given fields: ctx, did
func (_m *IdentityKeeper) VerifyMFA(ctx types.Context, did string) error {
	ret := _m.Called(ctx, did)

	if len(ret) == 0 {
		panic("no return value specified for VerifyMFA")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Context, string) error); ok {
		r0 = rf(ctx, did)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// VerifyOAuth2Token provides a mock function with given fields: ctx, did, token
func (_m *IdentityKeeper) VerifyOAuth2Token(ctx types.Context, did string, token string) error {
	ret := _m.Called(ctx, did, token)

	if len(ret) == 0 {
		panic("no return value specified for VerifyOAuth2Token")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Context, string, string) error); ok {
		r0 = rf(ctx, did, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// VerifyRecoveryToken provides a mock function with given fields: ctx, did, token
func (_m *IdentityKeeper) VerifyRecoveryToken(ctx types.Context, did string, token string) error {
	ret := _m.Called(ctx, did, token)

	if len(ret) == 0 {
		panic("no return value specified for VerifyRecoveryToken")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Context, string, string) error); ok {
		r0 = rf(ctx, did, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewIdentityKeeper creates a new instance of IdentityKeeper. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIdentityKeeper(t interface {
	mock.TestingT
	Cleanup(func())
}) *IdentityKeeper {
	mock := &IdentityKeeper{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
