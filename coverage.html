
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cli: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">selfchain/x/keyless/client/cli/query.go (0.0%)</option>
				
				<option value="file1">selfchain/x/keyless/client/cli/query_params.go (0.0%)</option>
				
				<option value="file2">selfchain/x/keyless/client/cli/tx.go (0.0%)</option>
				
				<option value="file3">selfchain/x/keyless/crypto/eddsa/conversion.go (100.0%)</option>
				
				<option value="file4">selfchain/x/keyless/crypto/eddsa/converter.go (0.0%)</option>
				
				<option value="file5">selfchain/x/keyless/crypto/encryption.go (83.8%)</option>
				
				<option value="file6">selfchain/x/keyless/crypto/signing/ecdsa.go (0.0%)</option>
				
				<option value="file7">selfchain/x/keyless/crypto/signing/ecdsa/signer.go (81.8%)</option>
				
				<option value="file8">selfchain/x/keyless/crypto/signing/eddsa.go (82.4%)</option>
				
				<option value="file9">selfchain/x/keyless/crypto/signing/factory.go (93.6%)</option>
				
				<option value="file10">selfchain/x/keyless/crypto/signing/format/format.go (94.2%)</option>
				
				<option value="file11">selfchain/x/keyless/crypto/signing/utils.go (100.0%)</option>
				
				<option value="file12">selfchain/x/keyless/genesis.go (100.0%)</option>
				
				<option value="file13">selfchain/x/keyless/keeper/identity.go (75.0%)</option>
				
				<option value="file14">selfchain/x/keyless/keeper/keeper.go (12.5%)</option>
				
				<option value="file15">selfchain/x/keyless/keeper/msg_server.go (0.0%)</option>
				
				<option value="file16">selfchain/x/keyless/keeper/pagination.go (0.0%)</option>
				
				<option value="file17">selfchain/x/keyless/keeper/params.go (64.3%)</option>
				
				<option value="file18">selfchain/x/keyless/keeper/query.go (3.1%)</option>
				
				<option value="file19">selfchain/x/keyless/keeper/recovery.go (86.4%)</option>
				
				<option value="file20">selfchain/x/keyless/keeper/rotation.go (0.0%)</option>
				
				<option value="file21">selfchain/x/keyless/keeper/storage.go (0.0%)</option>
				
				<option value="file22">selfchain/x/keyless/keeper/wallet.go (0.0%)</option>
				
				<option value="file23">selfchain/x/keyless/keygen/encryption.go (0.0%)</option>
				
				<option value="file24">selfchain/x/keyless/keygen/manager.go (0.0%)</option>
				
				<option value="file25">selfchain/x/keyless/keygen/rotation.go (0.0%)</option>
				
				<option value="file26">selfchain/x/keyless/module.go (0.0%)</option>
				
				<option value="file27">selfchain/x/keyless/module_simulation.go (0.0%)</option>
				
				<option value="file28">selfchain/x/keyless/networks/config.go (0.0%)</option>
				
				<option value="file29">selfchain/x/keyless/networks/registry.go (0.0%)</option>
				
				<option value="file30">selfchain/x/keyless/networks/supported_networks.go (0.0%)</option>
				
				<option value="file31">selfchain/x/keyless/simulation/helpers.go (0.0%)</option>
				
				<option value="file32">selfchain/x/keyless/storage/storage.go (58.3%)</option>
				
				<option value="file33">selfchain/x/keyless/testutil/keeper_helper.go (0.0%)</option>
				
				<option value="file34">selfchain/x/keyless/testutil/mocks/identity_keeper.go (60.6%)</option>
				
				<option value="file35">selfchain/x/keyless/tss/common.go (32.4%)</option>
				
				<option value="file36">selfchain/x/keyless/tss/keygen.go (62.7%)</option>
				
				<option value="file37">selfchain/x/keyless/tss/signing.go (90.9%)</option>
				
				<option value="file38">selfchain/x/keyless/tss/test_helpers.go (0.0%)</option>
				
				<option value="file39">selfchain/x/keyless/types/audit.pb.go (0.5%)</option>
				
				<option value="file40">selfchain/x/keyless/types/codec.go (0.0%)</option>
				
				<option value="file41">selfchain/x/keyless/types/genesis.go (100.0%)</option>
				
				<option value="file42">selfchain/x/keyless/types/genesis.pb.go (1.2%)</option>
				
				<option value="file43">selfchain/x/keyless/types/keygen.go (0.0%)</option>
				
				<option value="file44">selfchain/x/keyless/types/keygen.pb.go (0.7%)</option>
				
				<option value="file45">selfchain/x/keyless/types/keys.go (0.0%)</option>
				
				<option value="file46">selfchain/x/keyless/types/message_constructors.go (0.0%)</option>
				
				<option value="file47">selfchain/x/keyless/types/messages.go (0.0%)</option>
				
				<option value="file48">selfchain/x/keyless/types/network.pb.go (0.4%)</option>
				
				<option value="file49">selfchain/x/keyless/types/params.go (42.9%)</option>
				
				<option value="file50">selfchain/x/keyless/types/params.pb.go (0.5%)</option>
				
				<option value="file51">selfchain/x/keyless/types/query.pb.go (0.8%)</option>
				
				<option value="file52">selfchain/x/keyless/types/query.pb.gw.go (0.0%)</option>
				
				<option value="file53">selfchain/x/keyless/types/recovery.pb.go (1.1%)</option>
				
				<option value="file54">selfchain/x/keyless/types/rotation.pb.go (0.5%)</option>
				
				<option value="file55">selfchain/x/keyless/types/security_level.go (0.0%)</option>
				
				<option value="file56">selfchain/x/keyless/types/tx.pb.go (0.6%)</option>
				
				<option value="file57">selfchain/x/keyless/types/wallet.go (0.0%)</option>
				
				<option value="file58">selfchain/x/keyless/types/wallet.pb.go (0.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cli

import (
        "fmt"
        "github.com/spf13/cobra"
        "github.com/cosmos/cosmos-sdk/client"
        "github.com/cosmos/cosmos-sdk/client/flags"
        "selfchain/x/keyless/types"
)

// GetQueryCmd returns the cli query commands for this module
func GetQueryCmd(queryRoute string) *cobra.Command <span class="cov0" title="0">{
        // Group keyless queries under a subcommand
        cmd := &amp;cobra.Command{
                Use:                        types.ModuleName,
                Short:                      fmt.Sprintf("Querying commands for the %s module", types.ModuleName),
                DisableFlagParsing:         true,
                SuggestionsMinimumDistance: 2,
                RunE:                       client.ValidateCmd,
        }

        cmd.AddCommand(
                CmdQueryParams(),
                CmdQueryWallet(),
                CmdListWallets(),
                CmdQueryPartyData(),
        )

        flags.AddQueryFlagsToCmd(cmd)

        return cmd
}</span>

func CmdQueryWallet() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "wallet [address]",
                Short: "Query a wallet by address",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        clientCtx, err := client.GetClientQueryContext(cmd)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">queryClient := types.NewQueryClient(clientCtx)
                        res, err := queryClient.Wallet(cmd.Context(), &amp;types.QueryWalletRequest{
                                Address: args[0],
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">return clientCtx.PrintProto(res)</span>
                },
        }

        <span class="cov0" title="0">flags.AddQueryFlagsToCmd(cmd)
        return cmd</span>
}

func CmdListWallets() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "list-wallets",
                Short: "List all wallets",
                Args:  cobra.NoArgs,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        clientCtx, err := client.GetClientQueryContext(cmd)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">pageReq, err := client.ReadPageRequest(cmd.Flags())
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">queryClient := types.NewQueryClient(clientCtx)
                        res, err := queryClient.Wallets(cmd.Context(), &amp;types.QueryWalletsRequest{
                                Pagination: pageReq,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">return clientCtx.PrintProto(res)</span>
                },
        }

        <span class="cov0" title="0">flags.AddPaginationFlagsToCmd(cmd, "wallets")
        flags.AddQueryFlagsToCmd(cmd)
        return cmd</span>
}

func CmdQueryPartyData() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "party-data [wallet-address]",
                Short: "Query party data for a wallet",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        clientCtx, err := client.GetClientQueryContext(cmd)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">queryClient := types.NewQueryClient(clientCtx)
                        res, err := queryClient.PartyData(cmd.Context(), &amp;types.QueryPartyDataRequest{
                                WalletAddress: args[0],
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">return clientCtx.PrintProto(res)</span>
                },
        }

        <span class="cov0" title="0">flags.AddQueryFlagsToCmd(cmd)
        return cmd</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cli

import (
        "github.com/cosmos/cosmos-sdk/client"
        "github.com/cosmos/cosmos-sdk/client/flags"
        "github.com/spf13/cobra"

        "selfchain/x/keyless/types"
)

func CmdQueryParams() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "params",
                Short: "shows the parameters of the module",
                Args:  cobra.NoArgs,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        clientCtx, err := client.GetClientQueryContext(cmd)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">queryClient := types.NewQueryClient(clientCtx)

                        res, err := queryClient.Params(cmd.Context(), &amp;types.QueryParamsRequest{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">return clientCtx.PrintProto(res)</span>
                },
        }

        <span class="cov0" title="0">flags.AddQueryFlagsToCmd(cmd)

        return cmd</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cli

import (
        "fmt"
        "time"
        "encoding/hex"

        "github.com/spf13/cobra"
        "github.com/cosmos/cosmos-sdk/client"
        "github.com/cosmos/cosmos-sdk/client/flags"
        "github.com/cosmos/cosmos-sdk/client/tx"
        "selfchain/x/keyless/types"
)

var (
        DefaultRelativePacketTimeoutTimestamp = uint64((time.Duration(10) * time.Minute).Nanoseconds())
)

const (
        flagPacketTimeoutTimestamp = "packet-timeout-timestamp"
        listSeparator             = ","
)

// GetTxCmd returns the transaction commands for this module
func GetTxCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:                        types.ModuleName,
                Short:                      fmt.Sprintf("%s transactions subcommands", types.ModuleName),
                DisableFlagParsing:         true,
                SuggestionsMinimumDistance: 2,
                RunE:                       client.ValidateCmd,
        }

        cmd.AddCommand(
                CmdCreateWallet(),
                CmdRecoverWallet(),
                CmdSignTransaction(),
        )

        return cmd
}</span>

func CmdCreateWallet() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "create-wallet [pub-key] [chain-id]",
                Short: "Create a new keyless wallet",
                Args:  cobra.ExactArgs(2),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        clientCtx, err := client.GetClientTxContext(cmd)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">msg := types.NewMsgCreateWallet(
                                clientCtx.GetFromAddress().String(),
                                args[0], // pubKey
                                "",      // wallet address will be generated by the server
                                args[1], // chainId
                        )

                        return tx.GenerateOrBroadcastTxCLI(clientCtx, cmd.Flags(), msg)</span>
                },
        }

        <span class="cov0" title="0">flags.AddTxFlagsToCmd(cmd)
        return cmd</span>
}

func CmdRecoverWallet() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "recover-wallet [wallet-address] [recovery-proof] [new-pub-key] [signature]",
                Short: "Recover a wallet using recovery proof",
                Args:  cobra.ExactArgs(4),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        clientCtx, err := client.GetClientTxContext(cmd)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">msg := types.NewMsgRecoverWallet(
                                clientCtx.GetFromAddress().String(),
                                args[0], // wallet address
                                args[1], // recovery proof
                                args[2], // new public key
                                args[3], // signature
                        )

                        return tx.GenerateOrBroadcastTxCLI(clientCtx, cmd.Flags(), msg)</span>
                },
        }

        <span class="cov0" title="0">flags.AddTxFlagsToCmd(cmd)
        return cmd</span>
}

func CmdSignTransaction() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "sign-tx [wallet-address] [unsigned-tx] [chain-id]",
                Short: "Sign a transaction using the keyless wallet",
                Args:  cobra.ExactArgs(3),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        clientCtx, err := client.GetClientTxContext(cmd)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Decode hex-encoded unsigned transaction
                        <span class="cov0" title="0">unsignedTx := args[1]
                        if _, err := hex.DecodeString(unsignedTx); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid unsigned transaction hex: %w", err)
                        }</span>

                        <span class="cov0" title="0">msg := types.NewMsgSignTransaction(
                                clientCtx.GetFromAddress().String(),
                                args[0], // wallet address
                                unsignedTx,
                                args[2], // chain id
                        )

                        return tx.GenerateOrBroadcastTxCLI(clientCtx, cmd.Flags(), msg)</span>
                },
        }

        <span class="cov0" title="0">flags.AddTxFlagsToCmd(cmd)
        return cmd</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package eddsa

import (
        "crypto/ed25519"
        "crypto/sha512"
        "fmt"
        "math/big"

        "github.com/btcsuite/btcd/btcec/v2"
)

// ConversionParameters stores parameters for ECDSA to EdDSA conversion
type ConversionParameters struct {
        ECDSAPublicKey  *btcec.PublicKey
        EdDSAPublicKey  ed25519.PublicKey
        ConversionProof []byte
}

// ConvertECDSAToEdDSA converts an ECDSA public key to EdDSA format
func ConvertECDSAToEdDSA(ecdsaPub *btcec.PublicKey) (*ConversionParameters, error) <span class="cov8" title="1">{
        if ecdsaPub == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("ECDSA public key is nil")
        }</span>

        // Generate Ed25519 key from ECDSA public key components
        <span class="cov8" title="1">h := sha512.New()
        h.Write(ecdsaPub.SerializeCompressed())
        seed := h.Sum(nil)[:32]

        // Generate Ed25519 keypair from seed
        edPub := ed25519.NewKeyFromSeed(seed).Public().(ed25519.PublicKey)

        // Create conversion proof
        proof := generateConversionProof(ecdsaPub, edPub)

        return &amp;ConversionParameters{
                ECDSAPublicKey:  ecdsaPub,
                EdDSAPublicKey:  edPub,
                ConversionProof: proof,
        }, nil</span>
}

// ConvertSignatureToEdDSA converts an ECDSA signature to EdDSA format
func ConvertSignatureToEdDSA(r, s *big.Int) ([]byte, error) <span class="cov8" title="1">{
        if r == nil || s == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("signature components cannot be nil")
        }</span>

        // EdDSA signature is 64 bytes: R (32 bytes) || S (32 bytes)
        <span class="cov8" title="1">signature := make([]byte, ed25519.SignatureSize)

        // Convert R to fixed 32 bytes
        rBytes := r.Bytes()
        if len(rBytes) &gt; 32 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("R component too large")
        }</span>
        <span class="cov8" title="1">copy(signature[32-len(rBytes):32], rBytes)

        // Convert S to fixed 32 bytes
        sBytes := s.Bytes()
        if len(sBytes) &gt; 32 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("S component too large")
        }</span>
        <span class="cov8" title="1">copy(signature[64-len(sBytes):], sBytes)

        return signature, nil</span>
}

// VerifyEdDSASignature verifies an EdDSA signature
func VerifyEdDSASignature(pubKey ed25519.PublicKey, message, signature []byte) bool <span class="cov8" title="1">{
        return ed25519.Verify(pubKey, message, signature)
}</span>

// generateConversionProof creates a proof of correct conversion
// This is a placeholder - in production, implement a zero-knowledge proof
func generateConversionProof(ecdsaPub *btcec.PublicKey, eddsaPub ed25519.PublicKey) []byte <span class="cov8" title="1">{
        h := sha512.New()
        h.Write(ecdsaPub.SerializeCompressed())
        h.Write(eddsaPub)
        return h.Sum(nil)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package eddsa

import (
        "math/big"
        "selfchain/x/keyless/crypto/types"
)

// EdDSAConverter implements the CryptoService interface for EdDSA operations
type EdDSAConverter struct{}

var _ types.CryptoService = (*EdDSAConverter)(nil)

// ConvertSignatureToEdDSA converts an ECDSA signature (r,s) to EdDSA format
func (e *EdDSAConverter) ConvertSignatureToEdDSA(r, s *big.Int) ([]byte, error) <span class="cov0" title="0">{
        return ConvertSignatureToEdDSA(r, s)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package crypto

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "encoding/base64"
        "fmt"
        "io"
)

// EncryptionKey is a type alias for byte slice
type EncryptionKey []byte

// NewEncryptionKey generates a new random encryption key
func NewEncryptionKey() (EncryptionKey, error) <span class="cov8" title="1">{
        key := make([]byte, 32)
        if _, err := io.ReadFull(rand.Reader, key); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return key, nil</span>
}

// Encrypt encrypts data using AES-GCM
func Encrypt(key EncryptionKey, plaintext []byte) (string, error) <span class="cov8" title="1">{
        if len(key) != 32 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid key size: must be 32 bytes")
        }</span>

        <span class="cov8" title="1">block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create cipher: %w", err)
        }</span>

        <span class="cov8" title="1">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create GCM: %w", err)
        }</span>

        <span class="cov8" title="1">nonce := make([]byte, gcm.NonceSize())
        if _, err = io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate nonce: %w", err)
        }</span>

        // Seal will append the ciphertext to the nonce
        <span class="cov8" title="1">ciphertext := gcm.Seal(nonce, nonce, plaintext, nil)
        return base64.StdEncoding.EncodeToString(ciphertext), nil</span>
}

// Decrypt decrypts data using AES-GCM
func Decrypt(key EncryptionKey, ciphertext string) ([]byte, error) <span class="cov8" title="1">{
        if len(key) != 32 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid key size: must be 32 bytes")
        }</span>

        <span class="cov8" title="1">data, err := base64.StdEncoding.DecodeString(ciphertext)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to decode base64: %w", err)
        }</span>

        <span class="cov8" title="1">block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cipher: %w", err)
        }</span>

        <span class="cov8" title="1">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GCM: %w", err)
        }</span>

        <span class="cov8" title="1">nonceSize := gcm.NonceSize()
        if len(data) &lt; nonceSize </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("malformed ciphertext: too short")
        }</span>

        <span class="cov8" title="1">nonce := data[:nonceSize]
        ciphertextBytes := data[nonceSize:]

        plaintext, err := gcm.Open(nil, nonce, ciphertextBytes, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to decrypt: %w", err)
        }</span>

        <span class="cov8" title="1">return plaintext, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package signing

import (
        "context"
        "crypto/sha256"
        "errors"
        "fmt"
        "math/big"

        "selfchain/x/keyless/crypto/signing/types"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/btcec/v2/ecdsa"
)

// ECDSASigner implements the SigningService interface for ECDSA signatures
type ECDSASigner struct {
        privKey *btcec.PrivateKey
        pubKey  *btcec.PublicKey
}

// NewECDSASigner creates a new ECDSA signer
func NewECDSASigner(privKey *btcec.PrivateKey, pubKey *btcec.PublicKey) *ECDSASigner <span class="cov0" title="0">{
        return &amp;ECDSASigner{
                privKey: privKey,
                pubKey:  pubKey,
        }
}</span>

// Sign creates an ECDSA signature for the given message
func (s *ECDSASigner) Sign(ctx context.Context, message []byte, algorithm types.SigningAlgorithm) (*types.SignatureResult, error) <span class="cov0" title="0">{
        if algorithm != types.ECDSA </span><span class="cov0" title="0">{
                return nil, errors.New("unsupported algorithm")
        }</span>

        <span class="cov0" title="0">if s.privKey == nil </span><span class="cov0" title="0">{
                return nil, errors.New("private key not initialized")
        }</span>

        // Hash the message
        <span class="cov0" title="0">hash := sha256.Sum256(message)

        // Sign the hash
        signature := ecdsa.Sign(s.privKey, hash[:])

        // Get the serialized signature
        der := signature.Serialize()

        // Get the signature components
        rBytes := signature.Serialize()[:32]  // First 32 bytes are R
        sBytes := signature.Serialize()[32:64] // Next 32 bytes are S
        
        rBig := new(big.Int).SetBytes(rBytes)
        sBig := new(big.Int).SetBytes(sBytes)

        return &amp;types.SignatureResult{
                R:     rBig,
                S:     sBig,
                Bytes: der,
        }, nil</span>
}

// Verify verifies an ECDSA signature
func (e *ECDSASigner) Verify(ctx context.Context, message []byte, signature *types.SignatureResult, pubKeyBytes []byte) (bool, error) <span class="cov0" title="0">{
        // Parse public key
        pubKey, err := btcec.ParsePubKey(pubKeyBytes)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to parse public key: %v", err)
        }</span>

        // Hash the message
        <span class="cov0" title="0">hash := sha256.Sum256(message)

        // Create signature from R and S
        rScalar := new(btcec.ModNScalar)
        sScalar := new(btcec.ModNScalar)
        rScalar.SetByteSlice(signature.R.Bytes())
        sScalar.SetByteSlice(signature.S.Bytes())
        sig := ecdsa.NewSignature(rScalar, sScalar)

        // Verify the signature
        return sig.Verify(hash[:], pubKey), nil</span>
}

// GetPublicKey returns the ECDSA public key
func (s *ECDSASigner) GetPublicKey(ctx context.Context, algorithm types.SigningAlgorithm) ([]byte, error) <span class="cov0" title="0">{
        if algorithm != types.ECDSA </span><span class="cov0" title="0">{
                return nil, errors.New("unsupported algorithm")
        }</span>

        <span class="cov0" title="0">if s.pubKey == nil </span><span class="cov0" title="0">{
                return nil, errors.New("public key not initialized")
        }</span>

        <span class="cov0" title="0">pubKey := s.privKey.PubKey()
        return pubKey.SerializeCompressed(), nil</span>
}

// FormatDERSignature formats a signature in DER format
func FormatDERSignature(sig *types.SignatureResult) ([]byte, error) <span class="cov0" title="0">{
        if sig == nil </span><span class="cov0" title="0">{
                return nil, errors.New("signature is nil")
        }</span>

        // Create signature from R and S
        <span class="cov0" title="0">rScalar := new(btcec.ModNScalar)
        sScalar := new(btcec.ModNScalar)
        rScalar.SetByteSlice(sig.R.Bytes())
        sScalar.SetByteSlice(sig.S.Bytes())
        signature := ecdsa.NewSignature(rScalar, sScalar)

        // Format signature in DER format
        return signature.Serialize(), nil</span>
}

// UnmarshalDERSignature parses a DER signature into R and S components
func UnmarshalDERSignature(sigBytes []byte) (*big.Int, *big.Int, error) <span class="cov0" title="0">{
        sig, err := ecdsa.ParseDERSignature(sigBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // Get the signature components
        <span class="cov0" title="0">sigData := sig.Serialize()
        rBytes := sigData[:32]  // First 32 bytes are R
        sBytes := sigData[32:64] // Next 32 bytes are S
        
        rBig := new(big.Int).SetBytes(rBytes)
        sBig := new(big.Int).SetBytes(sBytes)

        return rBig, sBig, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package ecdsa

import (
        "context"
        "crypto/sha256"
        "errors"
        "fmt"
        "math/big"

        "selfchain/x/keyless/crypto/signing/types"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/btcec/v2/ecdsa"
)

// ECDSASigner implements the types.SigningService interface for ECDSA signatures
type ECDSASigner struct {
        privKey *btcec.PrivateKey
        pubKey  *btcec.PublicKey
}

// NewECDSASigner creates a new ECDSA signer
func NewECDSASigner(privKey *btcec.PrivateKey, pubKey *btcec.PublicKey) *ECDSASigner <span class="cov8" title="1">{
        return &amp;ECDSASigner{
                privKey: privKey,
                pubKey:  pubKey,
        }
}</span>

// Sign creates an ECDSA signature for the given message
func (s *ECDSASigner) Sign(ctx context.Context, message []byte, algorithm types.SigningAlgorithm) (*types.SignatureResult, error) <span class="cov8" title="1">{
        if algorithm != types.ECDSA </span><span class="cov0" title="0">{
                return nil, errors.New("unsupported algorithm")
        }</span>

        <span class="cov8" title="1">if s.privKey == nil </span><span class="cov0" title="0">{
                return nil, errors.New("private key not initialized")
        }</span>

        <span class="cov8" title="1">if len(message) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("empty message")
        }</span>

        // Hash the message
        <span class="cov8" title="1">hash := sha256.Sum256(message)

        // Create a deterministic nonce
        nonce := sha256.Sum256(append(hash[:], s.privKey.Serialize()...))
        k := new(btcec.ModNScalar)
        k.SetBytes(&amp;nonce)

        // Get the curve parameters
        curve := btcec.S256()
        n := curve.N

        // Calculate R = k*G
        kBytes := k.Bytes()
        x, _ := curve.ScalarBaseMult(kBytes[:])
        r := new(big.Int).Set(x)
        r.Mod(r, n)

        // Calculate s = k^-1(hash + r*privKey) mod n
        rInt := new(big.Int).Set(r)
        privInt := new(big.Int).SetBytes(s.privKey.Serialize())
        hashInt := new(big.Int).SetBytes(hash[:])

        // k^-1
        kBytes = k.Bytes()
        kInt := new(big.Int).SetBytes(kBytes[:])
        kInv := new(big.Int).ModInverse(kInt, n)
        if kInv == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to calculate k inverse")
        }</span>

        // r*privKey
        <span class="cov8" title="1">rPriv := new(big.Int).Mul(rInt, privInt)
        rPriv.Mod(rPriv, n)

        // hash + r*privKey
        sInt := new(big.Int).Add(hashInt, rPriv)
        sInt.Mod(sInt, n)

        // k^-1 * (hash + r*privKey)
        sInt.Mul(sInt, kInv)
        sInt.Mod(sInt, n)

        // Convert to ModNScalar for signature creation
        rScalar := new(btcec.ModNScalar)
        sScalar := new(btcec.ModNScalar)
        rScalar.SetByteSlice(r.Bytes())
        sScalar.SetByteSlice(sInt.Bytes())

        // Create ECDSA signature
        signature := ecdsa.NewSignature(rScalar, sScalar)

        // Get the serialized signature
        der := signature.Serialize()

        // Return signature result
        return &amp;types.SignatureResult{
                R:     r,
                S:     sInt,
                Bytes: der,
        }, nil</span>
}

// Verify verifies an ECDSA signature
func (s *ECDSASigner) Verify(ctx context.Context, message []byte, signature *types.SignatureResult, pubKeyBytes []byte) (bool, error) <span class="cov8" title="1">{
        if signature == nil </span><span class="cov0" title="0">{
                return false, errors.New("signature is nil")
        }</span>

        // Parse public key
        <span class="cov8" title="1">pubKey, err := btcec.ParsePubKey(pubKeyBytes)
        if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("failed to parse public key: %w", err)
        }</span>

        // Hash the message
        <span class="cov8" title="1">hash := sha256.Sum256(message)

        // Convert big.Int to ModNScalar
        rScalar := new(btcec.ModNScalar)
        sScalar := new(btcec.ModNScalar)
        rScalar.SetByteSlice(signature.R.Bytes())
        sScalar.SetByteSlice(signature.S.Bytes())

        // Create ECDSA signature
        sig := ecdsa.NewSignature(rScalar, sScalar)

        // Verify the signature
        return sig.Verify(hash[:], pubKey), nil</span>
}

// GetPublicKey returns the ECDSA public key
func (s *ECDSASigner) GetPublicKey(ctx context.Context, algorithm types.SigningAlgorithm) ([]byte, error) <span class="cov0" title="0">{
        if algorithm != types.ECDSA </span><span class="cov0" title="0">{
                return nil, errors.New("unsupported algorithm")
        }</span>

        <span class="cov0" title="0">if s.pubKey == nil </span><span class="cov0" title="0">{
                return nil, errors.New("public key not initialized")
        }</span>

        <span class="cov0" title="0">return s.pubKey.SerializeCompressed(), nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package signing

import (
        "context"
        "crypto/ed25519"
        "crypto/rand"
        "errors"
        "fmt"
)

// EdDSASigner implements the SigningService interface for EdDSA signatures
type EdDSASigner struct {
        party1Data interface{}
        party2Data interface{}
        privKey    ed25519.PrivateKey // For testing only
        pubKey     ed25519.PublicKey  // For testing only
}

// NewEdDSASigner creates a new EdDSA signer with party data
func NewEdDSASigner(party1Data, party2Data interface{}) *EdDSASigner <span class="cov8" title="1">{
        // For testing, generate a dummy key pair
        pub, priv, _ := ed25519.GenerateKey(rand.Reader)
        return &amp;EdDSASigner{
                party1Data: party1Data,
                party2Data: party2Data,
                privKey:    priv,
                pubKey:     pub,
        }
}</span>

// Sign creates an EdDSA signature for the given message
func (s *EdDSASigner) Sign(ctx context.Context, message []byte, algorithm SigningAlgorithm) (*SignatureResult, error) <span class="cov8" title="1">{
        if algorithm != EdDSA </span><span class="cov0" title="0">{
                return nil, errors.New("unsupported algorithm")
        }</span>

        // Sign the message (for testing only)
        <span class="cov8" title="1">sig := ed25519.Sign(s.privKey, message)

        // For EdDSA, we store the raw signature bytes
        return &amp;SignatureResult{
                Bytes: sig,
        }, nil</span>
}

// Verify verifies an EdDSA signature
func (s *EdDSASigner) Verify(ctx context.Context, message []byte, signature *SignatureResult, pubKeyBytes []byte) (bool, error) <span class="cov8" title="1">{
        if signature == nil </span><span class="cov8" title="1">{
                return false, errors.New("signature is nil")
        }</span>

        <span class="cov8" title="1">if len(pubKeyBytes) != ed25519.PublicKeySize </span><span class="cov8" title="1">{
                return false, fmt.Errorf("invalid public key size: expected %d, got %d", ed25519.PublicKeySize, len(pubKeyBytes))
        }</span>

        // Convert bytes to ed25519.PublicKey
        <span class="cov8" title="1">pubKey := ed25519.PublicKey(pubKeyBytes)

        // Verify the signature
        return ed25519.Verify(pubKey, message, signature.Bytes), nil</span>
}

// GetPublicKey returns the EdDSA public key
func (s *EdDSASigner) GetPublicKey(ctx context.Context, algorithm SigningAlgorithm) ([]byte, error) <span class="cov8" title="1">{
        if algorithm != EdDSA </span><span class="cov0" title="0">{
                return nil, errors.New("unsupported algorithm")
        }</span>

        <span class="cov8" title="1">if s.pubKey == nil </span><span class="cov0" title="0">{
                return nil, errors.New("public key not initialized")
        }</span>

        // Return the raw public key bytes
        <span class="cov8" title="1">return []byte(s.pubKey), nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package signing

import (
        "context"
        "errors"
        "fmt"
        "math/big"

        ecdsa_signer "selfchain/x/keyless/crypto/signing/ecdsa"
        "selfchain/x/keyless/crypto/signing/types"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/btcec/v2/ecdsa"
)

// SignerFactory is responsible for creating signing service instances
type SignerFactory struct{}

// NewSignerFactory creates a new signer factory
func NewSignerFactory() *SignerFactory <span class="cov8" title="1">{
        return &amp;SignerFactory{}
}</span>

// validatePrivateKey validates a private key
func (f *SignerFactory) validatePrivateKey(privKeyBytes []byte) (*btcec.PrivateKey, error) <span class="cov8" title="1">{
        if len(privKeyBytes) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        // Check key length
        <span class="cov8" title="1">if len(privKeyBytes) != 32 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid private key length: expected 32 bytes, got %d", len(privKeyBytes))
        }</span>

        <span class="cov8" title="1">privKey, _ := btcec.PrivKeyFromBytes(privKeyBytes)
        if privKey == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse private key")
        }</span>

        <span class="cov8" title="1">return privKey, nil</span>
}

// validatePublicKey validates a public key
func (f *SignerFactory) validatePublicKey(pubKeyBytes []byte) (*btcec.PublicKey, error) <span class="cov8" title="1">{
        if len(pubKeyBytes) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        // Check key length (33 for compressed, 65 for uncompressed)
        <span class="cov8" title="1">if len(pubKeyBytes) != 33 &amp;&amp; len(pubKeyBytes) != 65 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid public key length: expected 33 or 65 bytes, got %d", len(pubKeyBytes))
        }</span>

        <span class="cov8" title="1">pubKey, err := btcec.ParsePubKey(pubKeyBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse public key: %w", err)
        }</span>

        <span class="cov8" title="1">return pubKey, nil</span>
}

// createECDSASigner creates a new ECDSA signing service
func (f *SignerFactory) createECDSASigner(privKeyBytes []byte, pubKeyBytes []byte) (types.SigningService, error) <span class="cov8" title="1">{
        // Parse private key if provided
        privKey, err := f.validatePrivateKey(privKeyBytes)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Parse public key if provided
        <span class="cov8" title="1">pubKey, err := f.validatePublicKey(pubKeyBytes)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // If no public key is provided but we have a private key, derive public key
        <span class="cov8" title="1">if pubKey == nil &amp;&amp; privKey != nil </span><span class="cov0" title="0">{
                pubKey = privKey.PubKey()
        }</span>

        // Ensure we have at least one key
        <span class="cov8" title="1">if privKey == nil &amp;&amp; pubKey == nil </span><span class="cov8" title="1">{
                return nil, errors.New("either private key or public key must be provided")
        }</span>

        <span class="cov8" title="1">return ecdsa_signer.NewECDSASigner(privKey, pubKey), nil</span>
}

// CreateSigner creates a new signing service based on the algorithm and key pair
func (f *SignerFactory) CreateSigner(ctx context.Context, algorithm types.SigningAlgorithm, privKeyBytes []byte, pubKeyBytes []byte) (types.SigningService, error) <span class="cov8" title="1">{
        switch algorithm </span>{
        case types.ECDSA:<span class="cov8" title="1">
                return f.createECDSASigner(privKeyBytes, pubKeyBytes)</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported algorithm: %v", algorithm)</span>
        }
}

// Sign signs a message using the specified algorithm
func (f *SignerFactory) Sign(ctx context.Context, message []byte, algorithm types.SigningAlgorithm, signer types.SigningService) (*types.SignatureResult, error) <span class="cov8" title="1">{
        if signer == nil </span><span class="cov8" title="1">{
                return nil, errors.New("signer is nil")
        }</span>

        // Sign the message
        <span class="cov8" title="1">return signer.Sign(ctx, message, algorithm)</span>
}

// Verify verifies a signature using the specified algorithm
func (f *SignerFactory) Verify(ctx context.Context, message []byte, signature *types.SignatureResult, pubKey []byte, algorithm types.SigningAlgorithm, signer types.SigningService) (bool, error) <span class="cov8" title="1">{
        if signer == nil </span><span class="cov8" title="1">{
                return false, errors.New("signer is nil")
        }</span>

        // Verify the signature
        <span class="cov8" title="1">return signer.Verify(ctx, message, signature, pubKey)</span>
}

// FormatSignature formats a signature according to the specified algorithm
func (f *SignerFactory) FormatSignature(ctx context.Context, sig *types.SignatureResult, algorithm types.SigningAlgorithm) ([]byte, error) <span class="cov8" title="1">{
        if sig == nil </span><span class="cov8" title="1">{
                return nil, errors.New("signature is nil")
        }</span>

        // Return the DER encoded signature
        <span class="cov8" title="1">return sig.Bytes, nil</span>
}

// UnformatSignature unformats a signature according to the specified algorithm
func (f *SignerFactory) UnformatSignature(ctx context.Context, sigBytes []byte, algorithm types.SigningAlgorithm) (*types.SignatureResult, error) <span class="cov8" title="1">{
        if len(sigBytes) == 0 </span><span class="cov8" title="1">{
                return nil, errors.New("signature bytes are empty")
        }</span>

        // Parse the DER signature
        <span class="cov8" title="1">parsedSig, err := ecdsa.ParseDERSignature(sigBytes)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse signature: %w", err)
        }</span>

        // Get the serialized signature
        <span class="cov8" title="1">serialized := parsedSig.Serialize()

        // Convert to SignatureResult
        return &amp;types.SignatureResult{
                R:     new(big.Int).SetBytes(serialized[:32]),
                S:     new(big.Int).SetBytes(serialized[32:]),
                Bytes: sigBytes,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package format

import (
        "errors"
        "math/big"
)

// SignatureResult represents a signature result with R, S components
type SignatureResult struct {
        R        *big.Int
        S        *big.Int
        V        uint8
        Recovery byte
        Bytes    []byte
}

// FormatEthereumSignature formats a signature in Ethereum's format (R || S || V)
func FormatEthereumSignature(sig *SignatureResult) ([]byte, error) <span class="cov8" title="1">{
        if sig == nil </span><span class="cov8" title="1">{
                return nil, errors.New("signature is nil")
        }</span>

        <span class="cov8" title="1">result := make([]byte, 65)

        // Ensure R and S are padded to 32 bytes
        rBytes := make([]byte, 32)
        sBytes := make([]byte, 32)
        sig.R.FillBytes(rBytes)  // Use FillBytes to properly pad
        sig.S.FillBytes(sBytes)  // Use FillBytes to properly pad

        // Copy R and S into result
        copy(result[0:32], rBytes)
        copy(result[32:64], sBytes)

        // Add recovery ID (V)
        result[64] = sig.Recovery
        if result[64] == 0 </span><span class="cov0" title="0">{
                result[64] = 27 // Default V value for Ethereum
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// FormatCosmosSignature formats a signature in Cosmos' format (R || S)
func FormatCosmosSignature(sig *SignatureResult) ([]byte, error) <span class="cov8" title="1">{
        if sig == nil </span><span class="cov8" title="1">{
                return nil, errors.New("signature is nil")
        }</span>

        <span class="cov8" title="1">result := make([]byte, 64)

        // Ensure R and S are padded to 32 bytes
        rBytes := make([]byte, 32)
        sBytes := make([]byte, 32)
        sig.R.FillBytes(rBytes)  // Use FillBytes to properly pad
        sig.S.FillBytes(sBytes)  // Use FillBytes to properly pad

        // Copy R and S into result
        copy(result[0:32], rBytes)
        copy(result[32:64], sBytes)

        return result, nil</span>
}

// ParseEthereumSignature parses an Ethereum signature into R, S, V components
func ParseEthereumSignature(sig []byte) (*SignatureResult, error) <span class="cov8" title="1">{
        if len(sig) != 65 </span><span class="cov8" title="1">{
                return nil, errors.New("invalid ethereum signature length")
        }</span>

        <span class="cov8" title="1">r := new(big.Int).SetBytes(sig[:32])
        s := new(big.Int).SetBytes(sig[32:64])
        v := uint8(sig[64])

        return &amp;SignatureResult{
                R:        r,
                S:        s,
                V:        v,
                Recovery: v,
                Bytes:    sig,
        }, nil</span>
}

// ParseCosmosSignature parses a Cosmos signature into R, S components
func ParseCosmosSignature(sig []byte) (*SignatureResult, error) <span class="cov8" title="1">{
        if len(sig) != 64 </span><span class="cov8" title="1">{
                return nil, errors.New("invalid cosmos signature length")
        }</span>

        <span class="cov8" title="1">r := new(big.Int).SetBytes(sig[:32])
        s := new(big.Int).SetBytes(sig[32:64])

        return &amp;SignatureResult{
                R:     r,
                S:     s,
                Bytes: sig,
        }, nil</span>
}

// ParseBitcoinSignature parses a Bitcoin signature in DER format
func ParseBitcoinSignature(sig []byte) (*SignatureResult, error) <span class="cov8" title="1">{
        if len(sig) &lt; 8 </span><span class="cov8" title="1">{ // Minimum DER signature length
                return nil, errors.New("malformed bitcoin signature")
        }</span>

        // Remove SIGHASH_ALL byte if present
        <span class="cov8" title="1">sigBytes := sig
        if len(sig) &gt; 0 &amp;&amp; sig[len(sig)-1] == 0x01 </span><span class="cov8" title="1">{
                sigBytes = sig[:len(sig)-1]
        }</span>

        <span class="cov8" title="1">r, s, err := UnmarshalDERSignature(sigBytes)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;SignatureResult{
                R:     r,
                S:     s,
                Bytes: sigBytes,
        }, nil</span>
}

// UnmarshalDERSignature parses a DER signature into R and S components
func UnmarshalDERSignature(sig []byte) (*big.Int, *big.Int, error) <span class="cov8" title="1">{
        // ASN.1 DER format:
        // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
        if len(sig) &lt; 8 </span><span class="cov8" title="1">{
                return nil, nil, errors.New("signature too short")
        }</span>

        // Check sequence marker
        <span class="cov8" title="1">if sig[0] != 0x30 </span><span class="cov8" title="1">{
                return nil, nil, errors.New("signature not a sequence")
        }</span>

        // Get R component
        <span class="cov8" title="1">rStart := 4 // Skip sequence header (0x30) + length byte + integer marker (0x02) + length byte
        rLen := int(sig[3])
        if rLen+rStart &gt; len(sig) </span><span class="cov8" title="1">{
                return nil, nil, errors.New("R component length invalid")
        }</span>
        <span class="cov8" title="1">r := new(big.Int).SetBytes(sig[rStart : rStart+rLen])

        // Get S component
        sStart := rStart + rLen + 2 // Skip R + integer marker (0x02) + length byte
        if sStart+1 &gt; len(sig) </span><span class="cov0" title="0">{
                return nil, nil, errors.New("S component missing")
        }</span>
        <span class="cov8" title="1">sLen := int(sig[sStart-1])
        if sLen+sStart &gt; len(sig) </span><span class="cov8" title="1">{
                return nil, nil, errors.New("S component length invalid")
        }</span>
        <span class="cov8" title="1">s := new(big.Int).SetBytes(sig[sStart : sStart+sLen])

        return r, s, nil</span>
}

// FormatDERSignature formats a signature in DER format
func FormatDERSignature(sig *SignatureResult) ([]byte, error) <span class="cov8" title="1">{
        if sig == nil </span><span class="cov8" title="1">{
                return nil, errors.New("signature is nil")
        }</span>
        <span class="cov8" title="1">if sig.R == nil </span><span class="cov0" title="0">{
                return nil, errors.New("R value is nil")
        }</span>
        <span class="cov8" title="1">if sig.S == nil </span><span class="cov0" title="0">{
                return nil, errors.New("S value is nil")
        }</span>

        // Validate R and S values
        <span class="cov8" title="1">if sig.R.Sign() &lt;= 0 || sig.S.Sign() &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("invalid signature: R and S must be positive")
        }</span>

        // Check if values are too large (&gt; 32 bytes when padded)
        <span class="cov8" title="1">maxValue := new(big.Int).Lsh(big.NewInt(1), 256)
        if sig.R.Cmp(maxValue) &gt;= 0 || sig.S.Cmp(maxValue) &gt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("invalid signature: R or S too large")
        }</span>

        // Calculate lengths
        <span class="cov8" title="1">rBytes := sig.R.Bytes()
        sBytes := sig.S.Bytes()
        rLen := len(rBytes)
        sLen := len(sBytes)

        // Add extra byte to maintain positive numbers
        if rBytes[0]&amp;0x80 == 0x80 </span><span class="cov8" title="1">{
                rLen++
        }</span>
        <span class="cov8" title="1">if sBytes[0]&amp;0x80 == 0x80 </span><span class="cov8" title="1">{
                sLen++
        }</span>

        // Total length is:
        // 0x30 + length byte + 0x02 + rLength + rValue + 0x02 + sLength + sValue
        <span class="cov8" title="1">totalLen := 2 + 2 + rLen + 2 + sLen

        // Create DER signature
        der := make([]byte, totalLen)
        i := 0

        // Sequence marker
        der[i] = 0x30
        i++
        der[i] = byte(2 + rLen + 2 + sLen)
        i++

        // R value
        der[i] = 0x02
        i++
        der[i] = byte(rLen)
        i++
        if rBytes[0]&amp;0x80 == 0x80 </span><span class="cov8" title="1">{
                der[i] = 0x00
                i++
        }</span>
        <span class="cov8" title="1">copy(der[i:], rBytes)
        i += len(rBytes)

        // S value
        der[i] = 0x02
        i++
        der[i] = byte(sLen)
        i++
        if sBytes[0]&amp;0x80 == 0x80 </span><span class="cov8" title="1">{
                der[i] = 0x00
                i++
        }</span>
        <span class="cov8" title="1">copy(der[i:], sBytes)

        return der, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package signing

// padTo32 pads a byte slice to 32 bytes. If the input is longer than 32 bytes,
// it returns the rightmost 32 bytes.
func padTo32(b []byte) []byte <span class="cov8" title="1">{
        if len(b) &gt;= 32 </span><span class="cov8" title="1">{
                return b[len(b)-32:]
        }</span>
        <span class="cov8" title="1">padded := make([]byte, 32)
        copy(padded[32-len(b):], b)
        return padded</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package keyless

import (
        sdk "github.com/cosmos/cosmos-sdk/types"
        "selfchain/x/keyless/keeper"
        "selfchain/x/keyless/types"
)

// InitGenesis initializes the module's state from a provided genesis state.
func InitGenesis(ctx sdk.Context, k keeper.Keeper, genState types.GenesisState) <span class="cov8" title="1">{
        // this line is used by starport scaffolding # genesis/module/init
        k.SetParams(ctx, genState.Params)
}</span>

// ExportGenesis returns the module's exported genesis
func ExportGenesis(ctx sdk.Context, k keeper.Keeper) *types.GenesisState <span class="cov8" title="1">{
        genesis := types.DefaultGenesis()
        genesis.Params = k.GetParams(ctx)

        // this line is used by starport scaffolding # genesis/module/export

        return genesis
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package keeper

import (
        "context"
        "fmt"

        sdk "github.com/cosmos/cosmos-sdk/types"

        "selfchain/x/identity/types"
)

// SecurityLevel represents the security level for wallet operations
type SecurityLevel uint32

const (
        SecurityLevelLow SecurityLevel = iota + 1
        SecurityLevelMedium
        SecurityLevelHigh
)

// VerifyIdentity verifies a user's identity using DID and OAuth2
func (k Keeper) VerifyIdentity(ctx context.Context, did string, oauthToken string) error <span class="cov8" title="1">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)

        // 1. Verify DID existence and ownership
        _, found := k.identityKeeper.GetDIDDocument(sdkCtx, did)
        if !found </span><span class="cov0" title="0">{
                return fmt.Errorf("DID document not found: %s", did)
        }</span>

        // 2. Verify OAuth2 token
        <span class="cov8" title="1">if err := k.identityKeeper.VerifyOAuth2Token(sdkCtx, did, oauthToken); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to verify OAuth2 token: %w", err)
        }</span>

        // 3. Check if MFA is required
        <span class="cov8" title="1">if k.IsMFARequired(sdkCtx, did) </span><span class="cov8" title="1">{
                if err := k.identityKeeper.VerifyMFA(sdkCtx, did); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("MFA verification failed: %w", err)
                }</span>
        }

        // 4. Check rate limits
        <span class="cov8" title="1">if err := k.identityKeeper.CheckRateLimit(sdkCtx, did, "identity_verification"); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("rate limit exceeded: %w", err)
        }</span>

        // 5. Log audit event
        <span class="cov8" title="1">if err := k.identityKeeper.LogAuditEvent(sdkCtx, &amp;types.AuditEvent{
                Did:       did,
                EventType: "identity_verification",
                Success:   true,
                Details:   fmt.Sprintf("OAuth2 verification successful, MFA required: %v", k.IsMFARequired(sdkCtx, did)),
        }); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to log audit event: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IsMFARequired checks if MFA is required for a given DID
func (k Keeper) IsMFARequired(ctx sdk.Context, did string) bool <span class="cov8" title="1">{
        // Get security level from params
        params := k.GetParams(ctx)
        return params.MaxSecurityLevel &gt;= uint32(SecurityLevelHigh)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package keeper

import (
        "fmt"

        "github.com/cosmos/cosmos-sdk/codec"
        "github.com/cosmos/cosmos-sdk/store/prefix"
        storetypes "github.com/cosmos/cosmos-sdk/store/types"
        sdk "github.com/cosmos/cosmos-sdk/types"
        paramtypes "github.com/cosmos/cosmos-sdk/x/params/types"
        "github.com/cometbft/cometbft/libs/log"
        "selfchain/x/keyless/types"
        identitytypes "selfchain/x/identity/types"
)

type (
        Keeper struct {
                cdc           codec.BinaryCodec
                storeKey      storetypes.StoreKey
                memKey        storetypes.StoreKey
                paramstore    paramtypes.Subspace
                identityKeeper types.IdentityKeeper
        }
)

const (
        // Store prefixes
        walletPrefix    = "wallet"
        partyDataPrefix = "party_data"
)

func NewKeeper(
        cdc codec.BinaryCodec,
        storeKey,
        memKey storetypes.StoreKey,
        ps paramtypes.Subspace,
        identityKeeper types.IdentityKeeper,
) *Keeper <span class="cov8" title="1">{
        // set KeyTable if it has not already been set
        if !ps.HasKeyTable() </span><span class="cov8" title="1">{
                ps = ps.WithKeyTable(types.ParamKeyTable())
        }</span>

        <span class="cov8" title="1">return &amp;Keeper{
                cdc:           cdc,
                storeKey:      storeKey,
                memKey:        memKey,
                paramstore:    ps,
                identityKeeper: identityKeeper,
        }</span>
}

// Logger returns a module-specific logger
func (k Keeper) Logger(ctx sdk.Context) log.Logger <span class="cov0" title="0">{
        return ctx.Logger().With("module", fmt.Sprintf("x/%s", types.ModuleName))
}</span>

// GetPartyDataStore returns the store for TSS party data
func (k Keeper) GetPartyDataStore(ctx sdk.Context) prefix.Store <span class="cov0" title="0">{
        return prefix.NewStore(ctx.KVStore(k.storeKey), []byte(partyDataPrefix))
}</span>

// GetKeyShare retrieves a key share for a DID
func (k Keeper) GetKeyShare(ctx sdk.Context, did string) ([]byte, bool) <span class="cov0" title="0">{
        store := prefix.NewStore(ctx.KVStore(k.storeKey), []byte(walletPrefix))
        keyShare := store.Get([]byte(did))
        if keyShare == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return keyShare, true</span>
}

// StoreKeyShare stores a key share for a DID
func (k Keeper) StoreKeyShare(ctx sdk.Context, did string, keyShare []byte) error <span class="cov0" title="0">{
        store := prefix.NewStore(ctx.KVStore(k.storeKey), []byte(walletPrefix))
        store.Set([]byte(did), keyShare)
        return nil
}</span>

// ReconstructWallet reconstructs a wallet from a DID document
func (k Keeper) ReconstructWallet(ctx sdk.Context, didDoc identitytypes.DIDDocument) ([]byte, error) <span class="cov0" title="0">{
        // For now, just return the key share associated with the DID
        keyShare, found := k.GetKeyShare(ctx, didDoc.Id)
        if !found </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no key share found for DID %s", didDoc.Id)
        }</span>
        <span class="cov0" title="0">return keyShare, nil</span>
}

// InitiateRecovery initiates the wallet recovery process
func (k Keeper) InitiateRecovery(ctx sdk.Context, did string, recoveryToken string, recoveryAddress string) error <span class="cov0" title="0">{
        // Store recovery information
        store := prefix.NewStore(ctx.KVStore(k.storeKey), []byte("recovery"))
        recoveryInfo := types.RecoveryInfo{
                Did:             did,
                RecoveryToken:   recoveryToken,
                RecoveryAddress: recoveryAddress,
                Status:          types.RecoveryStatus_PENDING,
                CreatedAt:       ctx.BlockTime().Unix(),
        }
        
        bz, err := k.cdc.Marshal(&amp;recoveryInfo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">store.Set([]byte(did), bz)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package keeper

import (
        "context"
        "fmt"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "selfchain/x/keyless/types"
)

type msgServer struct {
        Keeper
}

// NewMsgServerImpl returns an implementation of the MsgServer interface
// for the provided Keeper.
func NewMsgServerImpl(keeper Keeper) types.MsgServer <span class="cov0" title="0">{
        return &amp;msgServer{Keeper: keeper}
}</span>

var _ types.MsgServer = msgServer{}

// CreateWallet creates a new keyless wallet
func (k msgServer) CreateWallet(goCtx context.Context, msg *types.MsgCreateWallet) (*types.MsgCreateWalletResponse, error) <span class="cov0" title="0">{
        ctx := sdk.UnwrapSDKContext(goCtx)

        // Generate a unique wallet ID
        walletId := fmt.Sprintf("%s-%s", msg.Creator, msg.WalletAddress)

        // Check if wallet already exists
        _, found := k.GetWalletFromStore(ctx, walletId)
        if found </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wallet already exists: %s", walletId)
        }</span>

        // Create a new wallet
        <span class="cov0" title="0">wallet := types.NewWallet(
                walletId,
                msg.PubKey,
                1, // Initial security level
                2, // Initial threshold
                3, // Initial parties
        )

        k.SetWallet(ctx, wallet)

        return &amp;types.MsgCreateWalletResponse{
                WalletAddress: msg.WalletAddress,
        }, nil</span>
}

// RecoverWallet recovers a wallet using recovery proof
func (k msgServer) RecoverWallet(goCtx context.Context, msg *types.MsgRecoverWallet) (*types.MsgRecoverWalletResponse, error) <span class="cov0" title="0">{
        ctx := sdk.UnwrapSDKContext(goCtx)

        // Generate wallet ID
        walletId := fmt.Sprintf("%s-%s", msg.Creator, msg.WalletAddress)

        // Validate recovery proof
        if err := k.ValidateRecoveryProof(ctx, walletId, msg.RecoveryProof); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get the existing wallet
        <span class="cov0" title="0">wallet, found := k.GetWalletFromStore(ctx, walletId)
        if !found </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wallet not found: %s", walletId)
        }</span>

        // Update the wallet with new public key
        <span class="cov0" title="0">wallet.PublicKey = msg.NewPubKey
        wallet.KeyVersion++
        k.SetWallet(ctx, &amp;wallet)

        return &amp;types.MsgRecoverWalletResponse{
                WalletAddress: msg.WalletAddress,
        }, nil</span>
}

// SignTransaction signs a transaction using the keyless wallet
func (k msgServer) SignTransaction(goCtx context.Context, msg *types.MsgSignTransaction) (*types.MsgSignTransactionResponse, error) <span class="cov0" title="0">{
        ctx := sdk.UnwrapSDKContext(goCtx)

        // Generate wallet ID
        walletId := fmt.Sprintf("%s-%s", msg.Creator, msg.WalletAddress)

        // Get the wallet
        wallet, found := k.GetWalletFromStore(ctx, walletId)
        if !found </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wallet not found: %s", walletId)
        }</span>

        // Verify permissions
        <span class="cov0" title="0">if err := k.ValidateWalletAccess(ctx, walletId, "sign"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Sign the transaction using TSS
        <span class="cov0" title="0">signedTx, err := k.SignWithTSS(ctx, &amp;wallet, msg.UnsignedTx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to sign transaction: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;types.MsgSignTransactionResponse{
                SignedTx: string(signedTx),
        }, nil</span>
}

// BatchSign performs batch signing operation
func (k msgServer) BatchSign(goCtx context.Context, msg *types.MsgBatchSign) (*types.MsgBatchSignResponse, error) <span class="cov0" title="0">{
        ctx := sdk.UnwrapSDKContext(goCtx)

        // Generate wallet ID
        walletId := fmt.Sprintf("%s-%s", msg.Creator, msg.WalletAddress)

        // Get the wallet
        wallet, found := k.GetWalletFromStore(ctx, walletId)
        if !found </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wallet not found: %s", walletId)
        }</span>

        // Verify permissions
        <span class="cov0" title="0">if err := k.ValidateWalletAccess(ctx, walletId, "sign"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Sign each transaction
        <span class="cov0" title="0">signedTxs := make([]string, 0, len(msg.UnsignedTxs))
        for _, unsignedTx := range msg.UnsignedTxs </span><span class="cov0" title="0">{
                signedTx, err := k.SignWithTSS(ctx, &amp;wallet, unsignedTx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to sign transaction: %v", err)
                }</span>
                <span class="cov0" title="0">signedTxs = append(signedTxs, string(signedTx))</span>
        }

        <span class="cov0" title="0">return &amp;types.MsgBatchSignResponse{
                SignedTxs: signedTxs,
        }, nil</span>
}

// InitiateKeyRotation initiates key rotation for a wallet
func (k msgServer) InitiateKeyRotation(goCtx context.Context, msg *types.MsgInitiateKeyRotation) (*types.MsgInitiateKeyRotationResponse, error) <span class="cov0" title="0">{
        ctx := sdk.UnwrapSDKContext(goCtx)

        // Generate wallet ID
        walletId := fmt.Sprintf("%s-%s", msg.Creator, msg.WalletAddress)

        // Get the wallet
        _, found := k.GetWalletFromStore(ctx, walletId)
        if !found </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wallet not found: %s", walletId)
        }</span>

        // Verify permissions
        <span class="cov0" title="0">if err := k.ValidateWalletAccess(ctx, walletId, "rotate"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create key rotation state
        <span class="cov0" title="0">rotation, err := k.Keeper.InitKeyRotation(ctx, walletId, msg.NewPubKey, msg.Signature)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initiate key rotation: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;types.MsgInitiateKeyRotationResponse{
                WalletAddress: msg.WalletAddress,
                NewVersion:    uint32(rotation.Version),
        }, nil</span>
}

// CompleteKeyRotation completes key rotation for a wallet
func (k msgServer) CompleteKeyRotation(goCtx context.Context, msg *types.MsgCompleteKeyRotation) (*types.MsgCompleteKeyRotationResponse, error) <span class="cov0" title="0">{
        ctx := sdk.UnwrapSDKContext(goCtx)

        // Generate wallet ID
        walletId := fmt.Sprintf("%s-%s", msg.Creator, msg.WalletAddress)

        // Get the wallet
        _, found := k.GetWalletFromStore(ctx, walletId)
        if !found </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wallet not found: %s", walletId)
        }</span>

        // Verify permissions
        <span class="cov0" title="0">if err := k.ValidateWalletAccess(ctx, walletId, "rotate"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Complete key rotation
        <span class="cov0" title="0">rotation, err := k.Keeper.CompleteKeyRotation(ctx, walletId, uint64(msg.Version))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to complete key rotation: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;types.MsgCompleteKeyRotationResponse{
                WalletAddress: msg.WalletAddress,
                Version:       uint32(rotation.Version),
        }, nil</span>
}

// CancelKeyRotation cancels key rotation for a wallet
func (k msgServer) CancelKeyRotation(goCtx context.Context, msg *types.MsgCancelKeyRotation) (*types.MsgCancelKeyRotationResponse, error) <span class="cov0" title="0">{
        ctx := sdk.UnwrapSDKContext(goCtx)

        // Generate wallet ID
        walletId := fmt.Sprintf("%s-%s", msg.Creator, msg.WalletAddress)

        // Verify wallet exists
        _, found := k.GetWalletFromStore(ctx, walletId)
        if !found </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wallet not found: %s", walletId)
        }</span>

        // Verify permissions
        <span class="cov0" title="0">if err := k.ValidateWalletAccess(ctx, walletId, "rotate"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Cancel key rotation
        <span class="cov0" title="0">_, err := k.Keeper.CancelKeyRotation(ctx, walletId, uint64(msg.Version))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to cancel key rotation: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;types.MsgCancelKeyRotationResponse{
                WalletAddress: msg.WalletAddress,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package keeper

import (
        "github.com/cosmos/cosmos-sdk/store/prefix"
        "github.com/cosmos/cosmos-sdk/types/query"
)

// Paginate is a helper function for pagination
func (k Keeper) Paginate(
        store prefix.Store,
        pageRequest *query.PageRequest,
        onResult func(key []byte, value []byte) error,
) (*query.PageResponse, error) <span class="cov0" title="0">{
        // Create a paginated iterator
        pageRes, err := query.Paginate(store, pageRequest, onResult)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return pageRes, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package keeper

import (
        sdk "github.com/cosmos/cosmos-sdk/types"
        "selfchain/x/keyless/types"
)

// GetParams get all parameters as types.Params
func (k Keeper) GetParams(ctx sdk.Context) (params types.Params) <span class="cov8" title="1">{
        store := ctx.KVStore(k.storeKey)
        bz := store.Get([]byte(types.ParamsKey))
        if bz == nil </span><span class="cov8" title="1">{
                return params
        }</span>
        
        <span class="cov8" title="1">k.cdc.MustUnmarshal(bz, &amp;params)
        return params</span>
}

// SetParams set the params
func (k Keeper) SetParams(ctx sdk.Context, params types.Params) <span class="cov8" title="1">{
        store := ctx.KVStore(k.storeKey)
        bz := k.cdc.MustMarshal(&amp;params)
        store.Set([]byte(types.ParamsKey), bz)
}</span>

// GetMaxParties returns the maximum number of parties allowed
func (k Keeper) GetMaxParties(ctx sdk.Context) uint32 <span class="cov0" title="0">{
        return k.GetParams(ctx).MaxParties
}</span>

// GetMaxThreshold returns the maximum threshold allowed
func (k Keeper) GetMaxThreshold(ctx sdk.Context) uint32 <span class="cov0" title="0">{
        return k.GetParams(ctx).MaxThreshold
}</span>

// GetMaxSecurityLevel returns the maximum security level allowed
func (k Keeper) GetMaxSecurityLevel(ctx sdk.Context) uint32 <span class="cov0" title="0">{
        return k.GetParams(ctx).MaxSecurityLevel
}</span>

// GetMaxBatchSize returns the maximum batch size allowed
func (k Keeper) GetMaxBatchSize(ctx sdk.Context) uint32 <span class="cov0" title="0">{
        return k.GetParams(ctx).MaxBatchSize
}</span>

// GetMaxMetadataSize returns the maximum metadata size allowed
func (k Keeper) GetMaxMetadataSize(ctx sdk.Context) uint32 <span class="cov0" title="0">{
        return k.GetParams(ctx).MaxMetadataSize
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package keeper

import (
        "context"

        "github.com/cosmos/cosmos-sdk/store/prefix"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "selfchain/x/keyless/types"
)

// Ensure Keeper implements QueryServer
var _ types.QueryServer = Keeper{}

// Params returns the module parameters
func (k Keeper) Params(c context.Context, req *types.QueryParamsRequest) (*types.QueryParamsResponse, error) <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>
        <span class="cov8" title="1">ctx := sdk.UnwrapSDKContext(c)

        return &amp;types.QueryParamsResponse{Params: k.GetParams(ctx)}, nil</span>
}

// Wallet returns information about a specific wallet
func (k Keeper) Wallet(c context.Context, req *types.QueryWalletRequest) (*types.QueryWalletResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>
        <span class="cov0" title="0">if req.Address == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "wallet address cannot be empty")
        }</span>

        <span class="cov0" title="0">ctx := sdk.UnwrapSDKContext(c)
        store := prefix.NewStore(ctx.KVStore(k.storeKey), types.KeyPrefix(types.WalletKey))
        bz := store.Get([]byte(req.Address))
        if bz == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.NotFound, "wallet not found")
        }</span>

        <span class="cov0" title="0">var wallet types.Wallet
        k.cdc.MustUnmarshal(bz, &amp;wallet)
        return &amp;types.QueryWalletResponse{
                Wallet: &amp;wallet,
        }, nil</span>
}

// Wallets returns all wallets with pagination
func (k Keeper) Wallets(c context.Context, req *types.QueryWalletsRequest) (*types.QueryWalletsResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov0" title="0">ctx := sdk.UnwrapSDKContext(c)
        store := ctx.KVStore(k.storeKey)
        walletStore := prefix.NewStore(store, types.KeyPrefix(types.WalletKey))

        var wallets []*types.Wallet
        pageRes, err := k.Paginate(walletStore, req.Pagination, func(key []byte, value []byte) error </span><span class="cov0" title="0">{
                var wallet types.Wallet
                if err := k.cdc.Unmarshal(value, &amp;wallet); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">wallets = append(wallets, &amp;wallet)
                return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;types.QueryWalletsResponse{
                Wallets:    wallets,
                Pagination: pageRes,
        }, nil</span>
}

// PartyData returns TSS party data for a wallet
func (k Keeper) PartyData(c context.Context, req *types.QueryPartyDataRequest) (*types.QueryPartyDataResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>
        <span class="cov0" title="0">if req.WalletAddress == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "wallet address cannot be empty")
        }</span>

        <span class="cov0" title="0">ctx := sdk.UnwrapSDKContext(c)
        store := prefix.NewStore(ctx.KVStore(k.storeKey), types.KeyPrefix(types.PartyDataKey))
        bz := store.Get([]byte(req.WalletAddress))
        if bz == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.NotFound, "party data not found")
        }</span>

        <span class="cov0" title="0">var partyData types.PartyData
        k.cdc.MustUnmarshal(bz, &amp;partyData)
        return &amp;types.QueryPartyDataResponse{
                WalletAddress: req.WalletAddress,
                PartyData:     &amp;partyData,
        }, nil</span>
}

// KeyRotation returns information about a specific key rotation
func (k Keeper) KeyRotation(c context.Context, req *types.QueryKeyRotationRequest) (*types.QueryKeyRotationResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>
        <span class="cov0" title="0">if req.WalletId == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "wallet ID cannot be empty")
        }</span>

        <span class="cov0" title="0">ctx := sdk.UnwrapSDKContext(c)
        store := prefix.NewStore(ctx.KVStore(k.storeKey), types.KeyPrefix(types.KeyRotationKey))
        key := append([]byte(req.WalletId), sdk.Uint64ToBigEndian(req.Version)...)
        bz := store.Get(key)
        if bz == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.NotFound, "key rotation not found")
        }</span>

        <span class="cov0" title="0">var rotation types.KeyRotation
        k.cdc.MustUnmarshal(bz, &amp;rotation)
        return &amp;types.QueryKeyRotationResponse{
                Rotation: &amp;rotation,
        }, nil</span>
}

// KeyRotations returns all key rotations for a wallet with pagination
func (k Keeper) KeyRotations(c context.Context, req *types.QueryKeyRotationsRequest) (*types.QueryKeyRotationsResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>
        <span class="cov0" title="0">if req.WalletId == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "wallet ID cannot be empty")
        }</span>

        <span class="cov0" title="0">ctx := sdk.UnwrapSDKContext(c)
        store := ctx.KVStore(k.storeKey)
        rotationStore := prefix.NewStore(store, types.KeyPrefix(types.KeyRotationKey))

        var rotations []*types.KeyRotation
        pageRes, err := k.Paginate(rotationStore, req.Pagination, func(key []byte, value []byte) error </span><span class="cov0" title="0">{
                var rotation types.KeyRotation
                if err := k.cdc.Unmarshal(value, &amp;rotation); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">rotations = append(rotations, &amp;rotation)
                return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;types.QueryKeyRotationsResponse{
                Rotations:  rotations,
                Pagination: pageRes,
        }, nil</span>
}

// ListAuditEvents returns all audit events with pagination
func (k Keeper) ListAuditEvents(c context.Context, req *types.QueryListAuditEventsRequest) (*types.QueryListAuditEventsResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>
        <span class="cov0" title="0">if req.WalletId == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "wallet ID cannot be empty")
        }</span>

        <span class="cov0" title="0">ctx := sdk.UnwrapSDKContext(c)
        store := ctx.KVStore(k.storeKey)
        eventStore := prefix.NewStore(store, types.KeyPrefix(types.AuditEventKey))

        var events []*types.AuditEvent
        pageRes, err := k.Paginate(eventStore, req.Pagination, func(key []byte, value []byte) error </span><span class="cov0" title="0">{
                var event types.AuditEvent
                if err := k.cdc.Unmarshal(value, &amp;event); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Filter by wallet ID, event type, and success
                <span class="cov0" title="0">if event.WalletId != req.WalletId </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if req.EventType != "" &amp;&amp; event.EventType != req.EventType </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if event.Success != req.Success </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">events = append(events, &amp;event)
                return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;types.QueryListAuditEventsResponse{
                Events:     events,
                Pagination: pageRes,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package keeper

import (
        "context"
        "fmt"

        "selfchain/x/keyless/types"

        "github.com/cosmos/cosmos-sdk/store/prefix"
        sdk "github.com/cosmos/cosmos-sdk/types"
)

// RecoverWallet handles the wallet recovery process
func (k Keeper) RecoverWallet(ctx context.Context, msg *types.MsgRecoverWallet) error <span class="cov8" title="1">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)

        // 1. Verify DID ownership through identity module
        didDoc, found := k.identityKeeper.GetDIDDocument(sdkCtx, msg.Creator)
        if !found </span><span class="cov0" title="0">{
                return fmt.Errorf("DID document not found: %s", msg.Creator)
        }</span>

        // 2. Verify recovery proof through identity module
        <span class="cov8" title="1">if err := k.identityKeeper.VerifyRecoveryToken(sdkCtx, msg.Creator, msg.RecoveryProof); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to verify recovery proof: %w", err)
        }</span>

        // 3. Get recovery share from identity module and use it for reconstruction
        <span class="cov8" title="1">if _, found := k.identityKeeper.GetKeyShare(sdkCtx, msg.Creator); !found </span><span class="cov0" title="0">{
                return fmt.Errorf("key share not found for DID: %s", msg.Creator)
        }</span>

        // 4. Reconstruct wallet using recovery share
        <span class="cov8" title="1">wallet, err := k.identityKeeper.ReconstructWallet(sdkCtx, didDoc)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to reconstruct wallet: %w", err)
        }</span>

        // 5. Store reconstructed wallet data in keeper's state
        <span class="cov8" title="1">store := prefix.NewStore(sdkCtx.KVStore(k.storeKey), types.KeyPrefix(types.WalletKey))
        blockTime := sdkCtx.BlockTime()
        newWallet := &amp;types.Wallet{
                Id:            msg.WalletAddress,
                Address:       msg.WalletAddress,
                Status:        types.WalletStatusActive,
                SecurityLevel: uint32(SecurityLevelHigh), // Recovered wallets use high security
                Threshold:     2,                         // Default threshold for recovered wallets
                Parties:       3,                         // Default number of parties for recovered wallets
                CreatedAt:     &amp;blockTime,
                UpdatedAt:     &amp;blockTime,
                Metadata: map[string]string{
                        "recovery_method": "did_recovery",
                        "recovered_by":    msg.Creator,
                },
        }

        // Copy reconstructed wallet data
        if w, ok := wallet.(*types.Wallet); ok </span><span class="cov8" title="1">{
                newWallet.PublicKey = w.PublicKey
                newWallet.KeyVersion = w.KeyVersion
                newWallet.ChainId = w.ChainId
        }</span>

        <span class="cov8" title="1">walletBytes := k.cdc.MustMarshal(newWallet)
        store.Set([]byte(msg.WalletAddress), walletBytes)

        // 6. Emit recovery event
        sdkCtx.EventManager().EmitEvent(
                sdk.NewEvent(
                        types.EventTypeWalletRecovered,
                        sdk.NewAttribute(types.AttributeKeyCreator, msg.Creator),
                        sdk.NewAttribute(types.AttributeKeyWalletAddress, msg.WalletAddress),
                        sdk.NewAttribute(types.AttributeKeyStatus, types.WalletStatusActive),
                ),
        )

        return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package keeper

import (
        "fmt"
        "time"

        "selfchain/x/keyless/types"

        "github.com/cosmos/cosmos-sdk/store/prefix"
        sdk "github.com/cosmos/cosmos-sdk/types"
)

const (
        keyRotationPrefix = "key_rotation"
)

// GetKeyRotationStore returns the store for key rotation data
func (k Keeper) GetKeyRotationStore(ctx sdk.Context) prefix.Store <span class="cov0" title="0">{
        store := ctx.KVStore(k.storeKey)
        return prefix.NewStore(store, []byte(keyRotationPrefix))
}</span>

// InitKeyRotation initializes a key rotation operation for a wallet
func (k Keeper) InitKeyRotation(ctx sdk.Context, walletId string, newPubKey string, signature string) (*types.KeyRotation, error) <span class="cov0" title="0">{
        // Verify wallet exists
        wallet, found := k.GetWalletFromStore(ctx, walletId)
        if !found </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wallet not found: %s", walletId)
        }</span>

        // Get current version
        <span class="cov0" title="0">version := uint64(wallet.KeyVersion) + 1

        // Create new key rotation
        now := time.Now()
        rotation := &amp;types.KeyRotation{
                WalletId:  walletId,
                Version:   version,
                NewPubKey: newPubKey,
                Status:    "pending",
                CreatedAt: &amp;now,
                Signature: signature,
        }

        // Store key rotation
        k.setKeyRotation(ctx, rotation)

        return rotation, nil</span>
}

// CompleteKeyRotation completes a pending key rotation operation
func (k Keeper) CompleteKeyRotation(ctx sdk.Context, walletId string, version uint64) (*types.KeyRotation, error) <span class="cov0" title="0">{
        // Get key rotation
        rotation, found := k.GetKeyRotation(ctx, walletId, version)
        if !found </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("key rotation not found: wallet=%s, version=%d", walletId, version)
        }</span>

        // Verify status is pending
        <span class="cov0" title="0">if rotation.Status != "pending" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("key rotation is not pending: %s", rotation.Status)
        }</span>

        // Update wallet with new public key
        <span class="cov0" title="0">wallet, found := k.GetWalletFromStore(ctx, walletId)
        if !found </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wallet not found: %s", walletId)
        }</span>

        // Update wallet's public key and version
        <span class="cov0" title="0">wallet.PublicKey = rotation.NewPubKey
        wallet.KeyVersion = uint32(rotation.Version)
        k.SetWallet(ctx, &amp;wallet)

        // Update rotation status
        now := time.Now()
        rotation.Status = "completed"
        rotation.CompletedAt = &amp;now
        k.setKeyRotation(ctx, rotation)

        return rotation, nil</span>
}

// CancelKeyRotation cancels a pending key rotation operation
func (k Keeper) CancelKeyRotation(ctx sdk.Context, walletId string, version uint64) (*types.KeyRotation, error) <span class="cov0" title="0">{
        // Get key rotation
        rotation, found := k.GetKeyRotation(ctx, walletId, version)
        if !found </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("key rotation not found: wallet=%s, version=%d", walletId, version)
        }</span>

        // Verify status is pending
        <span class="cov0" title="0">if rotation.Status != "pending" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("key rotation is not pending: %s", rotation.Status)
        }</span>

        // Update rotation status
        <span class="cov0" title="0">now := time.Now()
        rotation.Status = "cancelled"
        rotation.CompletedAt = &amp;now
        k.setKeyRotation(ctx, rotation)

        return rotation, nil</span>
}

// GetKeyRotation gets a key rotation by wallet ID and version
func (k Keeper) GetKeyRotation(ctx sdk.Context, walletId string, version uint64) (*types.KeyRotation, bool) <span class="cov0" title="0">{
        store := k.GetKeyRotationStore(ctx)
        key := []byte(fmt.Sprintf("%s_%d", walletId, version))

        bz := store.Get(key)
        if bz == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">var rotation types.KeyRotation
        k.cdc.MustUnmarshal(bz, &amp;rotation)
        return &amp;rotation, true</span>
}

// GetKeyRotations gets all key rotations for a wallet
func (k Keeper) GetKeyRotations(ctx sdk.Context, walletId string) []types.KeyRotation <span class="cov0" title="0">{
        store := k.GetKeyRotationStore(ctx)
        prefix := []byte(walletId + "_")

        iterator := store.Iterator(prefix, nil)
        defer iterator.Close()

        var rotations []types.KeyRotation
        for ; iterator.Valid(); iterator.Next() </span><span class="cov0" title="0">{
                var rotation types.KeyRotation
                k.cdc.MustUnmarshal(iterator.Value(), &amp;rotation)
                rotations = append(rotations, rotation)
        }</span>

        <span class="cov0" title="0">return rotations</span>
}

// setKeyRotation stores a key rotation in the KVStore
func (k Keeper) setKeyRotation(ctx sdk.Context, rotation *types.KeyRotation) <span class="cov0" title="0">{
        store := k.GetKeyRotationStore(ctx)
        key := []byte(fmt.Sprintf("%s_%d", rotation.WalletId, rotation.Version))
        bz := k.cdc.MustMarshal(rotation)
        store.Set(key, bz)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package keeper

import (
        "fmt"

        "selfchain/x/keyless/types"

        "github.com/cosmos/cosmos-sdk/store/prefix"
        sdk "github.com/cosmos/cosmos-sdk/types"
)

// GetWalletStore returns the store for wallet data
func (k Keeper) GetWalletStore(ctx sdk.Context) prefix.Store <span class="cov0" title="0">{
        store := ctx.KVStore(k.storeKey)
        return prefix.NewStore(store, []byte(walletPrefix))
}</span>

// SaveWallet stores a wallet
func (k Keeper) SaveWallet(ctx sdk.Context, wallet *types.Wallet) error <span class="cov0" title="0">{
        store := k.GetWalletStore(ctx)
        bz, err := k.cdc.Marshal(wallet)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal wallet: %w", err)
        }</span>
        <span class="cov0" title="0">store.Set([]byte(wallet.Id), bz)
        return nil</span>
}

// GetWallet retrieves a wallet
func (k Keeper) GetWallet(ctx sdk.Context, id string) (*types.Wallet, error) <span class="cov0" title="0">{
        store := k.GetWalletStore(ctx)
        bz := store.Get([]byte(id))
        if bz == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wallet not found: %s", id)
        }</span>

        <span class="cov0" title="0">var wallet types.Wallet
        if err := k.cdc.Unmarshal(bz, &amp;wallet); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal wallet: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;wallet, nil</span>
}

// DeleteWallet removes a wallet
func (k Keeper) DeleteWallet(ctx sdk.Context, id string) <span class="cov0" title="0">{
        store := k.GetWalletStore(ctx)
        store.Delete([]byte(id))
}</span>

// SavePartyData stores TSS party data
func (k Keeper) SavePartyData(ctx sdk.Context, walletID string, data *types.PartyData) error <span class="cov0" title="0">{
        store := k.GetPartyDataStore(ctx)
        bz, err := k.cdc.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal party data: %w", err)
        }</span>
        <span class="cov0" title="0">store.Set([]byte(walletID), bz)
        return nil</span>
}

// GetPartyData retrieves TSS party data
func (k Keeper) GetPartyData(ctx sdk.Context, walletID string) (*types.PartyData, error) <span class="cov0" title="0">{
        store := k.GetPartyDataStore(ctx)
        bz := store.Get([]byte(walletID))
        if bz == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("party data not found: %s", walletID)
        }</span>

        <span class="cov0" title="0">var data types.PartyData
        if err := k.cdc.Unmarshal(bz, &amp;data); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal party data: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;data, nil</span>
}

// DeletePartyData removes TSS party data
func (k Keeper) DeletePartyData(ctx sdk.Context, walletID string) <span class="cov0" title="0">{
        store := k.GetPartyDataStore(ctx)
        store.Delete([]byte(walletID))
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package keeper

import (
        "fmt"

        "github.com/cosmos/cosmos-sdk/store/prefix"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "selfchain/x/keyless/types"
)

// SetWallet sets a wallet in the store
func (k Keeper) SetWallet(ctx sdk.Context, wallet *types.Wallet) <span class="cov0" title="0">{
        store := prefix.NewStore(ctx.KVStore(k.storeKey), types.KeyPrefix(types.WalletKey))
        b := k.cdc.MustMarshal(wallet)
        store.Set([]byte(wallet.Id), b)
}</span>

// GetWalletFromStore returns a wallet from the store
func (k Keeper) GetWalletFromStore(ctx sdk.Context, id string) (types.Wallet, bool) <span class="cov0" title="0">{
        store := prefix.NewStore(ctx.KVStore(k.storeKey), types.KeyPrefix(types.WalletKey))
        b := store.Get([]byte(id))
        if b == nil </span><span class="cov0" title="0">{
                return types.Wallet{}, false
        }</span>

        <span class="cov0" title="0">var wallet types.Wallet
        k.cdc.MustUnmarshal(b, &amp;wallet)
        return wallet, true</span>
}

// ValidateWalletAccess validates if the permission exists in the wallet's permissions list
func (k Keeper) ValidateWalletAccess(ctx sdk.Context, id string, permission string) error <span class="cov0" title="0">{
        wallet, found := k.GetWalletFromStore(ctx, id)
        if !found </span><span class="cov0" title="0">{
                return fmt.Errorf("wallet not found: %s", id)
        }</span>

        <span class="cov0" title="0">for _, p := range wallet.Permissions </span><span class="cov0" title="0">{
                if p == permission </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("permission denied: %s", permission)</span>
}

// ValidateRecoveryProof validates a recovery proof for a wallet
func (k Keeper) ValidateRecoveryProof(ctx sdk.Context, walletId, recoveryProof string) error <span class="cov0" title="0">{
        // TODO: Implement recovery proof validation
        // This should integrate with the identity module for verification
        return nil
}</span>

// SignWithTSS signs a transaction using TSS
func (k Keeper) SignWithTSS(ctx sdk.Context, wallet *types.Wallet, unsignedTx string) ([]byte, error) <span class="cov0" title="0">{
        // TODO: Implement TSS signing
        // This should:
        // 1. Validate security level and threshold requirements
        // 2. Coordinate with parties to perform distributed signing
        // 3. Verify the signature before returning
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package keygen

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/bnb-chain/tss-lib/v2/ecdsa/keygen"

        "selfchain/x/keyless/types"
        "selfchain/x/keyless/crypto"
)

// EncryptionManager handles key encryption
type EncryptionManager struct {
        masterKey []byte
}

// NewEncryptionManager creates a new encryption manager
func NewEncryptionManager() *EncryptionManager <span class="cov0" title="0">{
        // In production, this should be loaded from a secure source or HSM
        return &amp;EncryptionManager{
                masterKey: make([]byte, 32), // Placeholder for demo
        }
}</span>

// EncryptShare encrypts a party's save data
func (em *EncryptionManager) EncryptShare(data *keygen.LocalPartySaveData) (*types.EncryptedShare, error) <span class="cov0" title="0">{
        // 1. Generate unique encryption key
        key, err := crypto.NewEncryptionKey()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate encryption key: %w", err)
        }</span>

        // 2. Marshal the save data to JSON
        <span class="cov0" title="0">jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal share data: %w", err)
        }</span>

        // 3. Encrypt the JSON data
        <span class="cov0" title="0">encryptedData, err := crypto.Encrypt(key, jsonData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encrypt share data: %w", err)
        }</span>

        // 4. Create encrypted share with metadata
        <span class="cov0" title="0">return &amp;types.EncryptedShare{
                EncryptedData: encryptedData,
                KeyId:        uuid.New().String(),
                Version:      1,
                CreatedAt:    time.Now(),
        }, nil</span>
}

// DecryptShare decrypts an encrypted share
func (em *EncryptionManager) DecryptShare(share *types.EncryptedShare) (*keygen.LocalPartySaveData, error) <span class="cov0" title="0">{
        // 1. Get encryption key for the share
        key, err := em.getKeyForShare(share.KeyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get key: %w", err)
        }</span>

        // 2. Decrypt the data
        <span class="cov0" title="0">decryptedData, err := crypto.Decrypt(key, share.EncryptedData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decrypt share data: %w", err)
        }</span>

        // 3. Unmarshal the JSON data
        <span class="cov0" title="0">var saveData keygen.LocalPartySaveData
        if err := json.Unmarshal(decryptedData, &amp;saveData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal share data: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;saveData, nil</span>
}

// getKeyForShare retrieves the encryption key for a share
func (em *EncryptionManager) getKeyForShare(keyID string) (crypto.EncryptionKey, error) <span class="cov0" title="0">{
        // In production, this should retrieve the key from a secure key management service
        // For now, return a placeholder key
        return make([]byte, 32), nil
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package keygen

import (
        "context"
        "fmt"
        "time"

        "github.com/bnb-chain/tss-lib/v2/ecdsa/keygen"

        "selfchain/x/keyless/types"
        "selfchain/x/keyless/storage"
        "selfchain/x/keyless/tss"
)

// KeyGenManager handles the key generation lifecycle
type KeyGenManager struct {
        keeper       storage.Storage
        encryptionMgr *EncryptionManager
}

// NewKeyGenManager creates a new key generation manager
func NewKeyGenManager(keeper storage.Storage) *KeyGenManager <span class="cov0" title="0">{
        return &amp;KeyGenManager{
                keeper:       keeper,
                encryptionMgr: NewEncryptionManager(),
        }
}</span>

// GenerateKeyShares creates a new key pair with enhanced security
func (km *KeyGenManager) GenerateKeyShares(ctx context.Context, req *types.KeyGenRequest) (*types.KeyGenResponse, error) <span class="cov0" title="0">{
        // 1. Validate request
        if err := req.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid request: %w", err)
        }</span>

        // 2. Generate pre-parameters with timeout
        <span class="cov0" title="0">preParams, err := km.generateSecurePreParams(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pre-params generation failed: %w", err)
        }</span>

        // 3. Generate key shares using TSS
        <span class="cov0" title="0">keygenResult, err := tss.GenerateKey(ctx, preParams, req.ChainId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("key generation failed: %w", err)
        }</span>

        // Add metadata
        <span class="cov0" title="0">now := time.Now()
        metadata := &amp;types.KeyMetadata{
                CreatedAt:     now,
                LastRotated:   now,
                LastUsed:      now,
                UsageCount:    0,
                BackupStatus:  types.BackupStatus_BACKUP_STATUS_NONE,
                SecurityLevel: req.SecurityLevel,
        }

        // 4. Encrypt key shares
        encryptedShares, err := km.encryptKeyShares(ctx, keygenResult)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("share encryption failed: %w", err)
        }</span>

        // 5. Store encrypted shares
        <span class="cov0" title="0">if err := km.storeKeyShares(ctx, req.WalletId, encryptedShares); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("share storage failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;types.KeyGenResponse{
                WalletId:  req.WalletId,
                PublicKey: keygenResult.PublicKeyBytes,
                Metadata:  metadata,
        }, nil</span>
}

func (km *KeyGenManager) generateSecurePreParams(ctx context.Context) (*keygen.LocalPreParams, error) <span class="cov0" title="0">{
        // Add timeout for pre-params generation
        ctx, cancel := context.WithTimeout(ctx, 2*time.Minute)
        defer cancel()

        preParams, err := keygen.GeneratePreParams(1 * time.Minute)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return preParams, nil</span>
}

func (km *KeyGenManager) encryptKeyShares(ctx context.Context, result *tss.KeygenResult) ([]*types.EncryptedShare, error) <span class="cov0" title="0">{
        shares := make([]*types.EncryptedShare, 2)

        // Encrypt Party1 Data
        share1, err := km.encryptionMgr.EncryptShare(result.Party1Data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encrypt party 1 share: %w", err)
        }</span>
        <span class="cov0" title="0">shares[0] = share1

        // Encrypt Party2 Data
        share2, err := km.encryptionMgr.EncryptShare(result.Party2Data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encrypt party 2 share: %w", err)
        }</span>
        <span class="cov0" title="0">shares[1] = share2

        return shares, nil</span>
}

func (km *KeyGenManager) storeKeyShares(ctx context.Context, walletID string, shares []*types.EncryptedShare) error <span class="cov0" title="0">{
        for i, share := range shares </span><span class="cov0" title="0">{
                key := fmt.Sprintf("%s_share_%d", walletID, i+1)
                if err := km.keeper.SavePartyShare(ctx, key, share); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to store share %d: %w", i+1, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package keygen

import (
        "context"
        "fmt"
        "time"

        "selfchain/x/keyless/types"
        "selfchain/x/keyless/storage"
)

// KeyRotationManager handles periodic key rotation
type KeyRotationManager struct {
        keyGen  *KeyGenManager
        storage *storage.Storage
}

// NewKeyRotationManager creates a new key rotation manager
func NewKeyRotationManager(keyGen *KeyGenManager, storage *storage.Storage) *KeyRotationManager <span class="cov0" title="0">{
        return &amp;KeyRotationManager{
                keyGen:  keyGen,
                storage: storage,
        }
}</span>

// RotateKeyShares performs secure key rotation
func (kr *KeyRotationManager) RotateKeyShares(ctx context.Context, walletID string) error <span class="cov0" title="0">{
        // 1. Load existing shares
        share1, err := kr.storage.GetPartyShare(ctx, fmt.Sprintf("%s_share_1", walletID))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get share 1: %w", err)
        }</span>

        <span class="cov0" title="0">share2, err := kr.storage.GetPartyShare(ctx, fmt.Sprintf("%s_share_2", walletID))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get share 2: %w", err)
        }</span>

        // 2. Generate new key shares
        <span class="cov0" title="0">req := &amp;types.KeyGenRequest{
                WalletId:      walletID,
                ChainId:       "temp", // This should be retrieved from wallet metadata
                SecurityLevel: types.SecurityLevel_SECURITY_LEVEL_STANDARD,
        }

        resp, err := kr.keyGen.GenerateKeyShares(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate new shares: %w", err)
        }</span>

        // 3. Validate new shares
        <span class="cov0" title="0">if err := kr.validateNewShares(ctx, resp); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("new shares validation failed: %w", err)
        }</span>

        // 4. Backup old shares
        <span class="cov0" title="0">if err := kr.backupOldShares(ctx, walletID, share1, share2); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to backup old shares: %w", err)
        }</span>

        // 5. Update metadata
        <span class="cov0" title="0">resp.Metadata.LastRotated = time.Now()

        return nil</span>
}

func (kr *KeyRotationManager) validateNewShares(ctx context.Context, resp *types.KeyGenResponse) error <span class="cov0" title="0">{
        // Implement share validation logic
        // This should verify that the new shares can successfully sign transactions
        return nil
}</span>

func (kr *KeyRotationManager) backupOldShares(ctx context.Context, walletID string, share1, share2 *types.EncryptedShare) error <span class="cov0" title="0">{
        // Implement backup logic
        // This should store old shares in a secure backup location
        return nil
}</span>

// ShouldRotate checks if key rotation is needed
func (kr *KeyRotationManager) ShouldRotate(metadata *types.KeyMetadata) bool <span class="cov0" title="0">{
        if metadata == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check time since last rotation
        <span class="cov0" title="0">if time.Since(metadata.LastRotated) &gt; 30*24*time.Hour </span><span class="cov0" title="0">{ // 30 days
                return true
        }</span>

        // Check usage count
        <span class="cov0" title="0">if metadata.UsageCount &gt; 1000 </span><span class="cov0" title="0">{ // Example threshold
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package keyless

import (
        "context"
        "encoding/json"
        "fmt"
        // this line is used by starport scaffolding # 1

        "github.com/grpc-ecosystem/grpc-gateway/runtime"
        "github.com/spf13/cobra"

        abci "github.com/cometbft/cometbft/abci/types"

        "github.com/cosmos/cosmos-sdk/client"
        "github.com/cosmos/cosmos-sdk/codec"
        cdctypes "github.com/cosmos/cosmos-sdk/codec/types"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/module"
        "selfchain/x/keyless/client/cli"
        "selfchain/x/keyless/keeper"
        "selfchain/x/keyless/types"
)

var (
        _ module.AppModule      = AppModule{}
        _ module.AppModuleBasic = AppModuleBasic{}
)

// ----------------------------------------------------------------------------
// AppModuleBasic
// ----------------------------------------------------------------------------

// AppModuleBasic implements the AppModuleBasic interface that defines the independent methods a Cosmos SDK module needs to implement.
type AppModuleBasic struct {
        cdc codec.BinaryCodec
}

func NewAppModuleBasic(cdc codec.BinaryCodec) AppModuleBasic <span class="cov0" title="0">{
        return AppModuleBasic{cdc: cdc}
}</span>

// Name returns the name of the module as a string
func (AppModuleBasic) Name() string <span class="cov0" title="0">{
        return types.ModuleName
}</span>

// RegisterLegacyAminoCodec registers the amino codec for the module, which is used to marshal and unmarshal structs to/from []byte in order to persist them in the module's KVStore
func (AppModuleBasic) RegisterLegacyAminoCodec(cdc *codec.LegacyAmino) <span class="cov0" title="0">{
        types.RegisterCodec(cdc)
}</span>

// RegisterInterfaces registers a module's interface types and their concrete implementations as proto.Message
func (a AppModuleBasic) RegisterInterfaces(reg cdctypes.InterfaceRegistry) <span class="cov0" title="0">{
        types.RegisterInterfaces(reg)
}</span>

// DefaultGenesis returns a default GenesisState for the module, marshalled to json.RawMessage. The default GenesisState need to be defined by the module developer and is primarily used for testing
func (AppModuleBasic) DefaultGenesis(cdc codec.JSONCodec) json.RawMessage <span class="cov0" title="0">{
        return cdc.MustMarshalJSON(types.DefaultGenesis())
}</span>

// ValidateGenesis used to validate the GenesisState, given in its json.RawMessage form
func (AppModuleBasic) ValidateGenesis(cdc codec.JSONCodec, config client.TxEncodingConfig, bz json.RawMessage) error <span class="cov0" title="0">{
        var genState types.GenesisState
        if err := cdc.UnmarshalJSON(bz, &amp;genState); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal %s genesis state: %w", types.ModuleName, err)
        }</span>
        <span class="cov0" title="0">return genState.Validate()</span>
}

// RegisterGRPCGatewayRoutes registers the gRPC Gateway routes for the module
func (AppModuleBasic) RegisterGRPCGatewayRoutes(clientCtx client.Context, mux *runtime.ServeMux) <span class="cov0" title="0">{
        types.RegisterQueryHandlerClient(context.Background(), mux, types.NewQueryClient(clientCtx))
}</span>

// GetTxCmd returns the root Tx command for the module. The subcommands of this root command are used by end-users to generate new transactions containing messages defined in the module
func (a AppModuleBasic) GetTxCmd() *cobra.Command <span class="cov0" title="0">{
        return cli.GetTxCmd()
}</span>

// GetQueryCmd returns the root query command for the module. The subcommands of this root command are used by end-users to generate new queries to the subset of the state defined by the module
func (AppModuleBasic) GetQueryCmd() *cobra.Command <span class="cov0" title="0">{
        return cli.GetQueryCmd(types.StoreKey)
}</span>

// ----------------------------------------------------------------------------
// AppModule
// ----------------------------------------------------------------------------

// AppModule implements the AppModule interface that defines the inter-dependent methods that modules need to implement
type AppModule struct {
        AppModuleBasic
        keeper        keeper.Keeper
        accountKeeper types.AccountKeeper
        bankKeeper    types.BankKeeper
        identityKeeper types.IdentityKeeper
}

func NewAppModule(
        cdc codec.Codec,
        keeper keeper.Keeper,
        accountKeeper types.AccountKeeper,
        bankKeeper types.BankKeeper,
        identityKeeper types.IdentityKeeper,
) AppModule <span class="cov0" title="0">{
        return AppModule{
                AppModuleBasic: NewAppModuleBasic(cdc),
                keeper:         keeper,
                accountKeeper:  accountKeeper,
                bankKeeper:     bankKeeper,
                identityKeeper: identityKeeper,
        }
}</span>

// RegisterServices registers a gRPC query service to respond to the module-specific gRPC queries
func (am AppModule) RegisterServices(cfg module.Configurator) <span class="cov0" title="0">{
        types.RegisterMsgServer(cfg.MsgServer(), keeper.NewMsgServerImpl(am.keeper))
        types.RegisterQueryServer(cfg.QueryServer(), am.keeper)
}</span>

// RegisterInvariants registers the invariants of the module. If an invariant deviates from its predicted value, the InvariantRegistry triggers appropriate logic (most often the chain will be halted)
func (am AppModule) RegisterInvariants(_ sdk.InvariantRegistry) {<span class="cov0" title="0">}</span>

// InitGenesis performs the module's genesis initialization. It returns no validator updates.
func (am AppModule) InitGenesis(ctx sdk.Context, cdc codec.JSONCodec, gs json.RawMessage) []abci.ValidatorUpdate <span class="cov0" title="0">{
        var genState types.GenesisState
        // Initialize global index to index in genesis state
        cdc.MustUnmarshalJSON(gs, &amp;genState)

        InitGenesis(ctx, am.keeper, genState)

        return []abci.ValidatorUpdate{}
}</span>

// ExportGenesis returns the module's exported genesis state as raw JSON bytes.
func (am AppModule) ExportGenesis(ctx sdk.Context, cdc codec.JSONCodec) json.RawMessage <span class="cov0" title="0">{
        genState := ExportGenesis(ctx, am.keeper)
        return cdc.MustMarshalJSON(genState)
}</span>

// ConsensusVersion is a sequence number for state-breaking change of the module. It should be incremented on each consensus-breaking change introduced by the module. To avoid wrong/empty versions, the initial version should be set to 1
func (AppModule) ConsensusVersion() uint64 <span class="cov0" title="0">{ return 1 }</span>

// BeginBlock contains the logic that is automatically triggered at the beginning of each block
func (am AppModule) BeginBlock(_ sdk.Context, _ abci.RequestBeginBlock) {<span class="cov0" title="0">}</span>

// EndBlock contains the logic that is automatically triggered at the end of each block
func (am AppModule) EndBlock(_ sdk.Context, _ abci.RequestEndBlock) []abci.ValidatorUpdate <span class="cov0" title="0">{
        return []abci.ValidatorUpdate{}
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package keyless

import (
        "math/rand"

        "github.com/cosmos/cosmos-sdk/baseapp"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/module"
        simtypes "github.com/cosmos/cosmos-sdk/types/simulation"
        "github.com/cosmos/cosmos-sdk/x/simulation"
        "selfchain/testutil/sample"
        keylesssimulation "selfchain/x/keyless/simulation"
        "selfchain/x/keyless/types"
)

// avoid unused import issue
var (
        _ = sample.AccAddress
        _ = keylesssimulation.FindAccount
        _ = simulation.MsgEntryKind
        _ = baseapp.Paramspace
        _ = rand.Rand{}
)

const (
// this line is used by starport scaffolding # simapp/module/const
)

// GenerateGenesisState creates a randomized GenState of the module.
func (AppModule) GenerateGenesisState(simState *module.SimulationState) <span class="cov0" title="0">{
        accs := make([]string, len(simState.Accounts))
        for i, acc := range simState.Accounts </span><span class="cov0" title="0">{
                accs[i] = acc.Address.String()
        }</span>
        <span class="cov0" title="0">keylessGenesis := types.GenesisState{
                Params: types.DefaultParams(),
                // this line is used by starport scaffolding # simapp/module/genesisState
        }
        simState.GenState[types.ModuleName] = simState.Cdc.MustMarshalJSON(&amp;keylessGenesis)</span>
}

// RegisterStoreDecoder registers a decoder.
func (am AppModule) RegisterStoreDecoder(_ sdk.StoreDecoderRegistry) {<span class="cov0" title="0">}</span>

// ProposalContents doesn't return any content functions for governance proposals.
func (AppModule) ProposalContents(_ module.SimulationState) []simtypes.WeightedProposalContent <span class="cov0" title="0">{
        return nil
}</span>

// WeightedOperations returns the all the gov module operations with their respective weights.
func (am AppModule) WeightedOperations(simState module.SimulationState) []simtypes.WeightedOperation <span class="cov0" title="0">{
        operations := make([]simtypes.WeightedOperation, 0)

        // this line is used by starport scaffolding # simapp/module/operation

        return operations
}</span>

// ProposalMsgs returns msgs used for governance proposals for simulations.
func (am AppModule) ProposalMsgs(simState module.SimulationState) []simtypes.WeightedProposalMsg <span class="cov0" title="0">{
        return []simtypes.WeightedProposalMsg{
                // this line is used by starport scaffolding # simapp/module/OpMsg
        }
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package networks

import (
        "fmt"
)

// SigningAlgorithm represents a supported signing algorithm
type SigningAlgorithm string

const (
        // ECDSA signing algorithm
        ECDSA SigningAlgorithm = "ECDSA"
        // EdDSA signing algorithm
        EdDSA SigningAlgorithm = "EdDSA"
        // Schnorr signing algorithm
        Schnorr SigningAlgorithm = "Schnorr"
        // BLS signing algorithm
        BLS SigningAlgorithm = "BLS"
)

// NetworkConfig represents the configuration for a specific network
type NetworkConfig struct {
        ChainID          string
        SigningAlgorithm SigningAlgorithm
        AddressPrefix    string
        CoinType         uint32
}

// ValidateSigningAlgorithm checks if the signing algorithm is supported
func ValidateSigningAlgorithm(algo SigningAlgorithm) error <span class="cov0" title="0">{
        switch algo </span>{
        case ECDSA, EdDSA:<span class="cov0" title="0">
                return nil</span>
        case Schnorr, BLS:<span class="cov0" title="0">
                return fmt.Errorf("signing algorithm %s not yet implemented", algo)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported signing algorithm: %s", algo)</span>
        }
}

// GetNetworkConfig returns the configuration for a specific chain ID
func GetNetworkConfig(chainID string) (*NetworkConfig, error) <span class="cov0" title="0">{
        registry := NewNetworkRegistry()
        
        // Try to find the network in registry
        var networkType NetworkType
        switch </span>{
        case chainID == "1" || chainID == "5":<span class="cov0" title="0">
                networkType = Ethereum</span>
        case chainID == "bitcoin" || chainID == "bitcoin-testnet":<span class="cov0" title="0">
                networkType = Bitcoin</span>
        default:<span class="cov0" title="0">
                networkType = Cosmos</span> // Default to Cosmos for other chains
        }
        
        <span class="cov0" title="0">networkInfo, err := registry.GetNetwork(networkType, chainID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return &amp;NetworkConfig{
                ChainID:          networkInfo.ChainID,
                SigningAlgorithm: networkInfo.SigningAlgorithm,
                AddressPrefix:    networkInfo.AddressPrefix,
                CoinType:         networkInfo.CoinType,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package networks

import (
        "fmt"
        "strings"
        "sync"
)

// CurveType represents the elliptic curve type used by the network
type CurveType string

const (
        // Supported curve types
        Secp256k1  CurveType = "secp256k1"
        Ed25519    CurveType = "ed25519"
        Curve25519 CurveType = "curve25519"
        P256       CurveType = "p256"
        BLS12_381  CurveType = "bls12_381"
        Stark256   CurveType = "stark256"
)

// NetworkType represents the blockchain network type
type NetworkType string

const (
        // Major network types
        Bitcoin  NetworkType = "bitcoin"
        Ethereum NetworkType = "ethereum"
        Cosmos   NetworkType = "cosmos"
        Solana   NetworkType = "solana"
        Polkadot NetworkType = "polkadot"
        Cardano  NetworkType = "cardano"
        Algorand NetworkType = "algorand"
        Tron     NetworkType = "tron"
        Near     NetworkType = "near"
        Stellar  NetworkType = "stellar"
        Aptos    NetworkType = "aptos"
        Sui      NetworkType = "sui"
)

// SigningConfig contains network-specific signing parameters
type SigningConfig struct {
        // Bitcoin-specific
        P2PKHPrefix  uint8  // Pay to Public Key Hash prefix
        P2SHPrefix   uint8  // Pay to Script Hash prefix
        HRP          string // Human Readable Part for bech32 addresses
        Base58Hasher string // Base58 hashing algorithm

        // Ethereum-specific
        ChainID  string // EVM chain ID
        GasToken string // Native gas token symbol

        // Cosmos-specific
        AddressPrefix string // Bech32 address prefix
        PubKeyPrefix  string // Public key prefix

        // Additional parameters can be added for other chains
}

// NetworkInfo contains detailed information about a blockchain network
type NetworkInfo struct {
        NetworkType      NetworkType
        ChainID          string
        SigningAlgorithm SigningAlgorithm
        Curve            CurveType
        AddressPrefix    string
        CoinType         uint32
        Decimals         uint8
        SymbolName       string
        DisplayName      string
        SigningConfig    *SigningConfig // Network-specific signing parameters
}

// NetworkRegistry manages the registry of supported networks
type NetworkRegistry struct {
        networks map[string]*NetworkInfo
        mu       sync.RWMutex
}

// NewNetworkRegistry creates a new network registry
func NewNetworkRegistry() *NetworkRegistry <span class="cov0" title="0">{
        registry := &amp;NetworkRegistry{
                networks: make(map[string]*NetworkInfo),
        }
        registry.initializeDefaultNetworks()
        return registry
}</span>

// initializeDefaultNetworks sets up the default supported networks
func (r *NetworkRegistry) initializeDefaultNetworks() <span class="cov0" title="0">{
        defaultNetworks := []*NetworkInfo{
                {
                        NetworkType:      Bitcoin,
                        ChainID:          "mainnet",
                        SigningAlgorithm: ECDSA,
                        Curve:            Secp256k1,
                        CoinType:         0,
                        Decimals:         8,
                        SymbolName:       "BTC",
                        DisplayName:      "Bitcoin",
                        SigningConfig: &amp;SigningConfig{
                                P2PKHPrefix:  0x00,
                                P2SHPrefix:   0x05,
                                HRP:          "bc",
                                Base58Hasher: "sha256",
                        },
                },
                {
                        NetworkType:      Ethereum,
                        ChainID:          "1",
                        SigningAlgorithm: ECDSA,
                        Curve:            Secp256k1,
                        CoinType:         60,
                        Decimals:         18,
                        SymbolName:       "ETH",
                        DisplayName:      "Ethereum",
                        SigningConfig: &amp;SigningConfig{
                                ChainID:  "1",
                                GasToken: "ETH",
                        },
                },
                {
                        NetworkType:      Cosmos,
                        ChainID:          "cosmoshub-4",
                        SigningAlgorithm: ECDSA,
                        Curve:            Secp256k1,
                        AddressPrefix:    "cosmos",
                        CoinType:         118,
                        Decimals:         6,
                        SymbolName:       "ATOM",
                        DisplayName:      "Cosmos Hub",
                        SigningConfig: &amp;SigningConfig{
                                AddressPrefix: "cosmos",
                                PubKeyPrefix:  "cosmospub",
                        },
                },
                {
                        NetworkType:      Solana,
                        ChainID:          "mainnet-beta",
                        SigningAlgorithm: EdDSA,
                        Curve:            Ed25519,
                        CoinType:         501,
                        Decimals:         9,
                        SymbolName:       "SOL",
                        DisplayName:      "Solana",
                },
                // Add more networks as needed
        }

        for _, network := range defaultNetworks </span><span class="cov0" title="0">{
                r.RegisterNetwork(network)
        }</span>
}

// RegisterNetwork adds a new network to the registry
func (r *NetworkRegistry) RegisterNetwork(info *NetworkInfo) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        key := fmt.Sprintf("%s-%s", info.NetworkType, info.ChainID)
        r.networks[key] = info
        return nil
}</span>

// GetNetwork retrieves network information by type and chain ID
func (r *NetworkRegistry) GetNetwork(networkType NetworkType, chainID string) (*NetworkInfo, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        key := fmt.Sprintf("%s-%s", networkType, chainID)
        if info, exists := r.networks[key]; exists </span><span class="cov0" title="0">{
                return info, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("network not found: %s-%s", networkType, chainID)</span>
}

// ListNetworks returns all registered networks
func (r *NetworkRegistry) ListNetworks() []*NetworkInfo <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        networks := make([]*NetworkInfo, 0, len(r.networks))
        for _, info := range r.networks </span><span class="cov0" title="0">{
                networks = append(networks, info)
        }</span>
        <span class="cov0" title="0">return networks</span>
}

// IsSupportedNetwork checks if a network is supported
func (r *NetworkRegistry) IsSupportedNetwork(networkType NetworkType, chainID string) bool <span class="cov0" title="0">{
        _, err := r.GetNetwork(networkType, chainID)
        return err == nil
}</span>

// ParseNetworkID parses a network ID into network type and chain ID
func ParseNetworkID(networkID string) (NetworkType, string, error) <span class="cov0" title="0">{
        parts := strings.Split(networkID, ":")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("invalid network ID format, expected 'type:chainID', got %s", networkID)
        }</span>

        <span class="cov0" title="0">networkType := NetworkType(parts[0])
        chainID := parts[1]

        return networkType, chainID, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package networks

import (
        "strings"

        "selfchain/x/keyless/types"
)

// DefaultNetworks returns a list of default supported networks
func DefaultNetworks() []*types.NetworkParams <span class="cov0" title="0">{
        return []*types.NetworkParams{
                {
                        NetworkType:      string(Bitcoin),
                        ChainId:         "bitcoin-mainnet",
                        SigningAlgorithm: string(ECDSA),
                        CurveType:       string(Secp256k1),
                        AddressPrefix:   "",
                        CoinType:        0,
                        Decimals:        8,
                        SymbolName:      "BTC",
                        DisplayName:     "Bitcoin",
                        SigningConfig: &amp;types.SigningConfig{
                                P2PkhPrefix:    0x00,
                                P2ShPrefix:     0x05,
                                Base58Hasher:   "sha256d",
                                ChainId:        "bitcoin-mainnet",
                                GasToken:       "BTC",
                                AddressPrefix:  "",
                        },
                },
                {
                        NetworkType:      string(Ethereum),
                        ChainId:         "1",
                        SigningAlgorithm: string(ECDSA),
                        CurveType:       string(Secp256k1),
                        AddressPrefix:   "0x",
                        CoinType:        60,
                        Decimals:        18,
                        SymbolName:      "ETH",
                        DisplayName:     "Ethereum",
                        SigningConfig: &amp;types.SigningConfig{
                                ChainId:       "1",
                                GasToken:      "ETH",
                                AddressPrefix: "0x",
                        },
                },
                {
                        NetworkType:      string(Cosmos),
                        ChainId:         "cosmoshub-4",
                        SigningAlgorithm: string(ECDSA),
                        CurveType:       string(Secp256k1),
                        AddressPrefix:   "cosmos",
                        CoinType:        118,
                        Decimals:        6,
                        SymbolName:      "ATOM",
                        DisplayName:     "Cosmos Hub",
                        SigningConfig: &amp;types.SigningConfig{
                                ChainId:       "cosmoshub-4",
                                GasToken:      "ATOM",
                                AddressPrefix: "cosmos",
                        },
                },
                // Add more networks as needed
        }
}</span>

// GetDefaultNetworkParams returns network parameters for the specified network ID
func GetDefaultNetworkParams(networkID string) *types.NetworkParams <span class="cov0" title="0">{
        // Split network ID into network type and chain ID
        parts := strings.Split(networkID, ":")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">networkType, chainID := parts[0], parts[1]

        // Handle special cases
        switch </span>{
        case networkType == "bitcoin" &amp;&amp; chainID == "mainnet":<span class="cov0" title="0">
                chainID = "bitcoin-mainnet"</span>
        }

        <span class="cov0" title="0">networks := DefaultNetworks()
        for _, network := range networks </span><span class="cov0" title="0">{
                // Match both network type and chain ID
                if strings.EqualFold(network.NetworkType, networkType) &amp;&amp; strings.EqualFold(network.ChainId, chainID) </span><span class="cov0" title="0">{
                        return network
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package simulation

import (
        sdk "github.com/cosmos/cosmos-sdk/types"
        simtypes "github.com/cosmos/cosmos-sdk/types/simulation"
)

// FindAccount find a specific address from an account list
func FindAccount(accs []simtypes.Account, address string) (simtypes.Account, bool) <span class="cov0" title="0">{
        creator, err := sdk.AccAddressFromBech32(address)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return simtypes.FindAccount(accs, creator)</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package storage

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/cosmos/cosmos-sdk/store/prefix"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/bnb-chain/tss-lib/v2/ecdsa/keygen"

        "selfchain/x/keyless/types"
)

// Storage manages data persistence
type Storage struct {
        store sdk.KVStore
}

// NewStorage creates a new storage instance
func NewStorage(store sdk.KVStore) *Storage <span class="cov8" title="1">{
        return &amp;Storage{
                store: store,
        }
}</span>

// SavePartyShare stores an encrypted key share
func (s *Storage) SavePartyShare(ctx context.Context, key string, share *types.EncryptedShare) error <span class="cov0" title="0">{
        store := prefix.NewStore(s.store, types.KeyPrefix(types.KeyShareKey))
        bz, err := share.Marshal()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal share: %w", err)
        }</span>
        <span class="cov0" title="0">store.Set([]byte(key), bz)
        return nil</span>
}

// GetPartyShare retrieves an encrypted key share
func (s *Storage) GetPartyShare(ctx context.Context, key string) (*types.EncryptedShare, error) <span class="cov0" title="0">{
        store := prefix.NewStore(s.store, types.KeyPrefix(types.KeyShareKey))
        bz := store.Get([]byte(key))
        if bz == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("share not found: %s", key)
        }</span>

        <span class="cov0" title="0">var share types.EncryptedShare
        if err := share.Unmarshal(bz); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal share: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;share, nil</span>
}

// DeletePartyShare removes a key share
func (s *Storage) DeletePartyShare(ctx context.Context, key string) <span class="cov0" title="0">{
        store := prefix.NewStore(s.store, types.KeyPrefix(types.KeyShareKey))
        store.Delete([]byte(key))
}</span>

// SavePartyData stores TSS party data for a wallet
func (s *Storage) SavePartyData(ctx context.Context, walletAddress string, party1Data, party2Data *keygen.LocalPartySaveData) error <span class="cov8" title="1">{
        store := prefix.NewStore(s.store, types.KeyPrefix(types.PartyDataKey))
        party1Key := fmt.Sprintf("%s_party1", walletAddress)
        party2Key := fmt.Sprintf("%s_party2", walletAddress)

        party1Bytes, err := json.Marshal(party1Data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal party1 data: %w", err)
        }</span>

        <span class="cov8" title="1">party2Bytes, err := json.Marshal(party2Data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal party2 data: %w", err)
        }</span>

        <span class="cov8" title="1">store.Set([]byte(party1Key), party1Bytes)
        store.Set([]byte(party2Key), party2Bytes)
        return nil</span>
}

// GetPartyData retrieves TSS party data for a wallet
func (s *Storage) GetPartyData(ctx context.Context, walletAddress string) (*keygen.LocalPartySaveData, *keygen.LocalPartySaveData, error) <span class="cov8" title="1">{
        store := prefix.NewStore(s.store, types.KeyPrefix(types.PartyDataKey))
        party1Key := fmt.Sprintf("%s_party1", walletAddress)
        party2Key := fmt.Sprintf("%s_party2", walletAddress)

        party1Bytes := store.Get([]byte(party1Key))
        party2Bytes := store.Get([]byte(party2Key))

        if party1Bytes == nil || party2Bytes == nil </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("party data not found for wallet: %s", walletAddress)
        }</span>

        <span class="cov8" title="1">var party1Data, party2Data keygen.LocalPartySaveData
        if err := json.Unmarshal(party1Bytes, &amp;party1Data); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to unmarshal party1 data: %w", err)
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal(party2Bytes, &amp;party2Data); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to unmarshal party2 data: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;party1Data, &amp;party2Data, nil</span>
}

// DeletePartyData removes TSS party data for a wallet
func (s *Storage) DeletePartyData(ctx context.Context, walletAddress string) error <span class="cov8" title="1">{
        store := prefix.NewStore(s.store, types.KeyPrefix(types.PartyDataKey))
        party1Key := fmt.Sprintf("%s_party1", walletAddress)
        party2Key := fmt.Sprintf("%s_party2", walletAddress)
        
        store.Delete([]byte(party1Key))
        store.Delete([]byte(party2Key))
        return nil
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package testutil

import (
        "testing"

        "github.com/cosmos/cosmos-sdk/codec"
        codectypes "github.com/cosmos/cosmos-sdk/codec/types"
        "github.com/cosmos/cosmos-sdk/store"
        storetypes "github.com/cosmos/cosmos-sdk/store/types"
        sdk "github.com/cosmos/cosmos-sdk/types"
        typesparams "github.com/cosmos/cosmos-sdk/x/params/types"
        "github.com/cometbft/cometbft/libs/log"
        tmproto "github.com/cometbft/cometbft/proto/tendermint/types"
        dbm "github.com/cometbft/cometbft-db"
        "github.com/stretchr/testify/require"
        "selfchain/x/keyless/keeper"
        "selfchain/x/keyless/types"
        identitytypes "selfchain/x/identity/types"
)

// MockIdentityKeeper is a mock implementation of IdentityKeeper for testing
type MockIdentityKeeper struct{}

func (m MockIdentityKeeper) GetDIDDocument(ctx sdk.Context, did string) (identitytypes.DIDDocument, bool) <span class="cov0" title="0">{
        return identitytypes.DIDDocument{}, true
}</span>

func (m MockIdentityKeeper) VerifyDIDOwnership(ctx sdk.Context, did string, owner sdk.AccAddress) error <span class="cov0" title="0">{
        return nil
}</span>

func (m MockIdentityKeeper) VerifyOAuth2Token(ctx sdk.Context, did string, token string) error <span class="cov0" title="0">{
        return nil
}</span>

func (m MockIdentityKeeper) VerifyMFA(ctx sdk.Context, did string) error <span class="cov0" title="0">{
        return nil
}</span>

func (m MockIdentityKeeper) VerifyRecoveryToken(ctx sdk.Context, did string, token string) error <span class="cov0" title="0">{
        return nil
}</span>

func (m MockIdentityKeeper) GetKeyShare(ctx sdk.Context, did string) ([]byte, bool) <span class="cov0" title="0">{
        return []byte{}, true
}</span>

func (m MockIdentityKeeper) ReconstructWallet(ctx sdk.Context, didDoc identitytypes.DIDDocument) (interface{}, error) <span class="cov0" title="0">{
        return []byte{}, nil
}</span>

func (m MockIdentityKeeper) CheckRateLimit(ctx sdk.Context, did string, operation string) error <span class="cov0" title="0">{
        return nil
}</span>

func (m MockIdentityKeeper) LogAuditEvent(ctx sdk.Context, event *identitytypes.AuditEvent) error <span class="cov0" title="0">{
        return nil
}</span>

// NewTestKeeper creates a new keeper for testing
func NewTestKeeper(t testing.TB) (*keeper.Keeper, sdk.Context) <span class="cov0" title="0">{
        storeKey := storetypes.NewKVStoreKey(types.StoreKey)
        memStoreKey := storetypes.NewMemoryStoreKey(types.MemStoreKey)
        paramsStoreKey := storetypes.NewKVStoreKey("params")

        db := dbm.NewMemDB()
        stateStore := store.NewCommitMultiStore(db)
        stateStore.MountStoreWithDB(storeKey, storetypes.StoreTypeIAVL, db)
        stateStore.MountStoreWithDB(memStoreKey, storetypes.StoreTypeMemory, nil)
        stateStore.MountStoreWithDB(paramsStoreKey, storetypes.StoreTypeIAVL, db)
        require.NoError(t, stateStore.LoadLatestVersion())

        registry := codectypes.NewInterfaceRegistry()
        cdc := codec.NewProtoCodec(registry)
        paramsSubspace := typesparams.NewSubspace(cdc,
                types.Amino,
                storeKey,
                memStoreKey,
                "KeylessParams",
        )

        identityKeeper := MockIdentityKeeper{}

        k := keeper.NewKeeper(
                cdc,
                storeKey,
                memStoreKey,
                paramsSubspace,
                identityKeeper,
        )

        ctx := sdk.NewContext(stateStore, tmproto.Header{}, false, log.NewNopLogger())

        // Initialize params
        k.SetParams(ctx, types.DefaultParams())

        return k, ctx
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package mocks

import (
        "selfchain/x/identity/types"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/stretchr/testify/mock"
)

// IdentityKeeper is a mock implementation of the identity keeper
type IdentityKeeper struct {
        mock.Mock
}

func NewIdentityKeeper(t mock.TestingT) *IdentityKeeper <span class="cov8" title="1">{
        mock := &amp;IdentityKeeper{}
        mock.Test(t)
        return mock
}</span>

func (m *IdentityKeeper) GetDIDDocument(ctx sdk.Context, did string) (types.DIDDocument, bool) <span class="cov8" title="1">{
        args := m.Called(ctx, did)
        if doc := args.Get(0); doc != nil </span><span class="cov8" title="1">{
                return doc.(types.DIDDocument), args.Bool(1)
        }</span>
        <span class="cov0" title="0">return types.DIDDocument{}, args.Bool(1)</span>
}

func (m *IdentityKeeper) VerifyDIDOwnership(ctx sdk.Context, did string, owner sdk.AccAddress) error <span class="cov0" title="0">{
        args := m.Called(ctx, did, owner)
        return args.Error(0)
}</span>

func (m *IdentityKeeper) VerifyOAuth2Token(ctx sdk.Context, did string, token string) error <span class="cov8" title="1">{
        args := m.Called(ctx, did, token)
        return args.Error(0)
}</span>

func (m *IdentityKeeper) VerifyMFA(ctx sdk.Context, did string) error <span class="cov8" title="1">{
        args := m.Called(ctx, did)
        return args.Error(0)
}</span>

func (m *IdentityKeeper) VerifyRecoveryToken(ctx sdk.Context, did string, token string) error <span class="cov8" title="1">{
        args := m.Called(ctx, did, token)
        return args.Error(0)
}</span>

func (m *IdentityKeeper) GetKeyShare(ctx sdk.Context, did string) ([]byte, bool) <span class="cov8" title="1">{
        args := m.Called(ctx, did)
        return args.Get(0).([]byte), args.Bool(1)
}</span>

func (m *IdentityKeeper) ReconstructWallet(ctx sdk.Context, didDoc types.DIDDocument) (interface{}, error) <span class="cov8" title="1">{
        args := m.Called(ctx, didDoc)
        return args.Get(0), args.Error(1)
}</span>

func (m *IdentityKeeper) CheckRateLimit(ctx sdk.Context, did string, operation string) error <span class="cov8" title="1">{
        args := m.Called(ctx, did, operation)
        return args.Error(0)
}</span>

func (m *IdentityKeeper) LogAuditEvent(ctx sdk.Context, event *types.AuditEvent) error <span class="cov8" title="1">{
        args := m.Called(ctx, event)
        return args.Error(0)
}</span>

// Helper methods for tests

func (m *IdentityKeeper) StoreDIDDocument(ctx sdk.Context, doc *types.DIDDocument) error <span class="cov0" title="0">{
        args := m.Called(ctx, doc)
        return args.Error(0)
}</span>

func (m *IdentityKeeper) StoreOAuth2Token(ctx sdk.Context, did string, token string) error <span class="cov0" title="0">{
        args := m.Called(ctx, did, token)
        return args.Error(0)
}</span>

func (m *IdentityKeeper) StoreMFASession(ctx sdk.Context, did string) error <span class="cov0" title="0">{
        args := m.Called(ctx, did)
        return args.Error(0)
}</span>

func (m *IdentityKeeper) StoreRecoveryToken(ctx sdk.Context, did string, token string) error <span class="cov0" title="0">{
        args := m.Called(ctx, did, token)
        return args.Error(0)
}</span>

func (m *IdentityKeeper) StoreKeyShare(ctx sdk.Context, did string, share []byte) error <span class="cov0" title="0">{
        args := m.Called(ctx, did, share)
        return args.Error(0)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package tss

import (
        "fmt"
        "math/big"

        "github.com/bnb-chain/tss-lib/v2/tss"
)

const (
    // TotalPartyCount is the total number of parties in the TSS protocol
    TotalPartyCount = 2
    // Threshold is the minimum number of parties required to sign
    Threshold = TotalPartyCount - 1
)

// SharedPartyUpdater is a helper function to update a party with a message
func SharedPartyUpdater(party tss.Party, msg tss.Message, errCh chan&lt;- *tss.Error) <span class="cov8" title="1">{
    // do not send a message from this party back to itself
    if party.PartyID().Index == msg.GetFrom().Index </span><span class="cov0" title="0">{
        return
    }</span>

    // Convert message to wire format
    <span class="cov8" title="1">wireBytes, _, err := msg.WireBytes()
    if err != nil </span><span class="cov0" title="0">{
        errCh &lt;- party.WrapError(fmt.Errorf("failed to convert message to wire format: %w", err))
        return
    }</span>

    // Parse wire message
    <span class="cov8" title="1">parsedMsg, err := tss.ParseWireMessage(wireBytes, msg.GetFrom(), msg.IsBroadcast())
    if err != nil </span><span class="cov0" title="0">{
        errCh &lt;- party.WrapError(fmt.Errorf("failed to parse wire message: %w", err))
        return
    }</span>

    // Validate message
    <span class="cov8" title="1">if parsedMsg.GetFrom() == nil </span><span class="cov0" title="0">{
        errCh &lt;- party.WrapError(fmt.Errorf("message has nil sender"))
        return
    }</span>

    <span class="cov8" title="1">if parsedMsg.GetTo() != nil </span><span class="cov0" title="0">{
        // Point-to-point message
        isForMe := false
        for _, to := range parsedMsg.GetTo() </span><span class="cov0" title="0">{
            if to.Index == party.PartyID().Index </span><span class="cov0" title="0">{
                isForMe = true
                break</span>
            }
        }
        <span class="cov0" title="0">if !isForMe </span><span class="cov0" title="0">{
            return
        }</span>
    }

    // Update party state with the message
    <span class="cov8" title="1">if _, err := party.Update(parsedMsg); err != nil </span><span class="cov0" title="0">{
        errCh &lt;- party.WrapError(fmt.Errorf("failed to update party state: %w", err))
        return
    }</span>
}

// GeneratePartyID creates a new party ID for TSS
func GeneratePartyID(index int) *tss.PartyID <span class="cov8" title="1">{
    // Convert index to big.Int for party ID
    key := new(big.Int).SetInt64(int64(index + 1))
    
    // Create a unique moniker for the party
    moniker := fmt.Sprintf("P%d", index)
    
    // Create party ID with empty metadata
    return tss.NewPartyID(moniker, "", key)
}</span>

// GeneratePartyIDs creates a sorted list of party IDs
func GeneratePartyIDs(count int) ([]*tss.PartyID, error) <span class="cov0" title="0">{
    if count &lt; 2 </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("minimum 2 parties required, got %d", count)
    }</span>

    <span class="cov0" title="0">var parties []*tss.PartyID
    for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
        id := GeneratePartyID(i)
        parties = append(parties, id)
    }</span>

    <span class="cov0" title="0">return tss.SortPartyIDs(parties), nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package tss

import (
        "context"
        "encoding/json"
        "fmt"
        "math/big"
        "time"

        "github.com/bnb-chain/tss-lib/v2/ecdsa/keygen"
        "github.com/bnb-chain/tss-lib/v2/tss"
        "selfchain/x/keyless/crypto"
)

// KeygenResult contains the result of key generation
type KeygenResult struct {
        Party1Data     *keygen.LocalPartySaveData
        Party2Data     *keygen.LocalPartySaveData
        ChainID        string
        PublicKeyBytes []byte
}

// EncryptedShare represents an encrypted key share
type EncryptedShare struct {
        EncryptedData string
        ChainID      string
}

// EncryptShare encrypts a party's save data
func EncryptShare(key crypto.EncryptionKey, data *keygen.LocalPartySaveData) (*EncryptedShare, error) <span class="cov0" title="0">{
        if len(key) != 32 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid key length: expected 32 bytes, got %d", len(key))
        }</span>

        <span class="cov0" title="0">if data == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("share data cannot be nil")
        }</span>

        // Marshal the save data to JSON
        <span class="cov0" title="0">jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal share data: %w", err)
        }</span>

        // Encrypt the JSON data
        <span class="cov0" title="0">encryptedData, err := crypto.Encrypt(key, jsonData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encrypt share data: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;EncryptedShare{
                EncryptedData: encryptedData,
        }, nil</span>
}

// DecryptShare decrypts an encrypted share
func DecryptShare(key crypto.EncryptionKey, encryptedShare *EncryptedShare) (*keygen.LocalPartySaveData, error) <span class="cov0" title="0">{
        // Decrypt the data
        decryptedData, err := crypto.Decrypt(key, encryptedShare.EncryptedData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decrypt share data: %w", err)
        }</span>

        // Unmarshal the JSON data
        <span class="cov0" title="0">var saveData keygen.LocalPartySaveData
        if err := json.Unmarshal(decryptedData, &amp;saveData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal share data: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;saveData, nil</span>
}

// GenerateKey generates a key using TSS
func GenerateKey(ctx context.Context, preParams *keygen.LocalPreParams, chainID string) (*KeygenResult, error) <span class="cov8" title="1">{
        // Create separate communication channels for each party
        outCh1 := make(chan tss.Message, TotalPartyCount)
        outCh2 := make(chan tss.Message, TotalPartyCount)
        endCh := make(chan *keygen.LocalPartySaveData, TotalPartyCount)
        tssErrCh := make(chan *tss.Error, 2*TotalPartyCount)

        // Create party IDs with different IDs and moniker strings
        p1ID := tss.NewPartyID("party1", "P1", big.NewInt(1))
        p2ID := tss.NewPartyID("party2", "P2", big.NewInt(2))
        parties := tss.SortPartyIDs([]*tss.PartyID{p1ID, p2ID})

        // Create peer context
        peerCtx := tss.NewPeerContext(parties)
        params1 := tss.NewParameters(tss.S256(), peerCtx, p1ID, len(parties), Threshold)
        params2 := tss.NewParameters(tss.S256(), peerCtx, p2ID, len(parties), Threshold)

        // Generate separate pre-parameters for each party
        preParams2, err := keygen.GeneratePreParams(time.Minute)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate pre-parameters for party 2: %w", err)
        }</span>

        // Create keygen parties with unique pre-parameters
        <span class="cov8" title="1">p1 := keygen.NewLocalParty(params1, outCh1, endCh, *preParams).(*keygen.LocalParty)
        p2 := keygen.NewLocalParty(params2, outCh2, endCh, *preParams2).(*keygen.LocalParty)

        // Start both parties
        go func() </span><span class="cov8" title="1">{
                if err := p1.Start(); err != nil </span><span class="cov0" title="0">{
                        tssErrCh &lt;- err
                        return
                }</span>
        }()

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                if err := p2.Start(); err != nil </span><span class="cov0" title="0">{
                        tssErrCh &lt;- err
                        return
                }</span>
        }()

        // Message routing for party 1
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                for msg := range outCh1 </span><span class="cov8" title="1">{
                        dest := msg.GetTo()
                        if dest == nil </span><span class="cov8" title="1">{ // broadcast
                                SharedPartyUpdater(p2, msg, tssErrCh)
                        }</span> else<span class="cov8" title="1"> if dest[0].Index == p2.PartyID().Index </span><span class="cov8" title="1">{
                                SharedPartyUpdater(p2, msg, tssErrCh)
                        }</span>
                }
        }()

        // Message routing for party 2
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                for msg := range outCh2 </span><span class="cov8" title="1">{
                        dest := msg.GetTo()
                        if dest == nil </span><span class="cov8" title="1">{ // broadcast
                                SharedPartyUpdater(p1, msg, tssErrCh)
                        }</span> else<span class="cov8" title="1"> if dest[0].Index == p1.PartyID().Index </span><span class="cov8" title="1">{
                                SharedPartyUpdater(p1, msg, tssErrCh)
                        }</span>
                }
        }()

        // Wait for both parties to complete
        <span class="cov8" title="1">var party1Data, party2Data *keygen.LocalPartySaveData
        for i := 0; i &lt; 2; i++ </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return nil, ctx.Err()</span>
                case err := &lt;-tssErrCh:<span class="cov0" title="0">
                        return nil, fmt.Errorf("keygen error: %w", err)</span>
                case data := &lt;-endCh:<span class="cov8" title="1">
                        if data.ShareID.Cmp(big.NewInt(1)) == 0 </span><span class="cov8" title="1">{
                                party1Data = data
                        }</span> else<span class="cov8" title="1"> {
                                party2Data = data
                        }</span>
                }
        }

        <span class="cov8" title="1">if party1Data == nil || party2Data == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to receive data from both parties")
        }</span>

        <span class="cov8" title="1">publicKeyBytes := make([]byte, 33) // 33 bytes for compressed secp256k1 public key
        return &amp;KeygenResult{
                Party1Data:     party1Data,
                Party2Data:     party2Data,
                ChainID:        chainID,
                PublicKeyBytes: publicKeyBytes,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package tss

import (
        "context"
        "fmt"
        "math/big"
        "sync"

        "github.com/bnb-chain/tss-lib/v2/common"
        "github.com/bnb-chain/tss-lib/v2/ecdsa/keygen"
        "github.com/bnb-chain/tss-lib/v2/ecdsa/signing"
        "github.com/bnb-chain/tss-lib/v2/tss"
)

// SignResult contains the result of signing
type SignResult struct {
        R *big.Int
        S *big.Int
}

// SignMessage signs a message using TSS
func SignMessage(ctx context.Context, msg []byte, party1Data, party2Data *keygen.LocalPartySaveData) (*SignResult, error) <span class="cov8" title="1">{
        // Create communication channels with sufficient buffer
        outCh1 := make(chan tss.Message, TotalPartyCount*4) // Increased buffer size
        outCh2 := make(chan tss.Message, TotalPartyCount*4)
        endCh := make(chan *common.SignatureData, TotalPartyCount)
        tssErrCh := make(chan *tss.Error, 2*TotalPartyCount)
        errChan := make(chan error, 2)

        // Create party IDs with consistent indices
        p1ID := tss.NewPartyID("P1", "", new(big.Int).SetInt64(1))
        p2ID := tss.NewPartyID("P2", "", new(big.Int).SetInt64(2))
        parties := tss.SortPartyIDs([]*tss.PartyID{p1ID, p2ID})

        // Create peer context
        peerCtx := tss.NewPeerContext(parties)
        params1 := tss.NewParameters(tss.S256(), peerCtx, p1ID, len(parties), Threshold)
        params2 := tss.NewParameters(tss.S256(), peerCtx, p2ID, len(parties), Threshold)

        // Convert message to big.Int
        msgBigInt := new(big.Int).SetBytes(msg)

        // Create signing parties
        p1 := signing.NewLocalParty(msgBigInt, params1, *party1Data, outCh1, endCh).(*signing.LocalParty)
        p2 := signing.NewLocalParty(msgBigInt, params2, *party2Data, outCh2, endCh).(*signing.LocalParty)

        // Start both parties with error handling
        var wg sync.WaitGroup
        wg.Add(2)

        go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                if err := p1.Start(); err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- fmt.Errorf("party 1 error: %w", err)
                }</span>
        }()

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                if err := p2.Start(); err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- fmt.Errorf("party 2 error: %w", err)
                }</span>
        }()

        // Message routing for party 1
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                defer close(outCh1)
                for msg := range outCh1 </span><span class="cov8" title="1">{
                        dest := msg.GetTo()
                        if dest == nil </span><span class="cov8" title="1">{ // broadcast
                                SharedPartyUpdater(p2, msg, tssErrCh)
                        }</span> else<span class="cov8" title="1"> {
                                for _, to := range dest </span><span class="cov8" title="1">{
                                        if to.Index == p2.PartyID().Index </span><span class="cov8" title="1">{
                                                SharedPartyUpdater(p2, msg, tssErrCh)
                                                break</span>
                                        }
                                }
                        }
                }
        }()

        // Message routing for party 2
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                defer close(outCh2)
                for msg := range outCh2 </span><span class="cov8" title="1">{
                        dest := msg.GetTo()
                        if dest == nil </span><span class="cov8" title="1">{ // broadcast
                                SharedPartyUpdater(p1, msg, tssErrCh)
                        }</span> else<span class="cov8" title="1"> {
                                for _, to := range dest </span><span class="cov8" title="1">{
                                        if to.Index == p1.PartyID().Index </span><span class="cov8" title="1">{
                                                SharedPartyUpdater(p1, msg, tssErrCh)
                                                break</span>
                                        }
                                }
                        }
                }
        }()

        // Wait for completion or error with timeout
        <span class="cov8" title="1">done := make(chan struct{})
        go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(done)
        }</span>()

        <span class="cov8" title="1">select </span>{
        case &lt;-ctx.Done():<span class="cov8" title="1">
                return nil, ctx.Err()</span>
        case err := &lt;-errChan:<span class="cov0" title="0">
                return nil, err</span>
        case err := &lt;-tssErrCh:<span class="cov0" title="0">
                return nil, fmt.Errorf("signing error: %w", err)</span>
        case data := &lt;-endCh:<span class="cov8" title="1">
                // Wait for both parties to finish
                select </span>{
                case &lt;-done:<span class="cov8" title="1">
                        return &amp;SignResult{
                                R: new(big.Int).SetBytes(data.R),
                                S: new(big.Int).SetBytes(data.S),
                        }, nil</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package tss

import (
    "crypto/ecdsa"
    "crypto/elliptic"
    "math/big"
)

// reconstructPublicKey reconstructs the ECDSA public key from the TSS public key bytes
func reconstructPublicKey(pubKeyBytes []byte) (*ecdsa.PublicKey, error) <span class="cov0" title="0">{
    curve := elliptic.P256() // We use secp256k1 in TSS, but for testing P256 is fine
    x := new(big.Int).SetBytes(pubKeyBytes[:32])
    y := new(big.Int).SetBytes(pubKeyBytes[32:])

    if !curve.IsOnCurve(x, y) </span><span class="cov0" title="0">{
        return nil, ErrInvalidPublicKey
    }</span>

    <span class="cov0" title="0">return &amp;ecdsa.PublicKey{
        Curve: curve,
        X:     x,
        Y:     y,
    }, nil</span>
}

// ErrInvalidPublicKey is returned when the public key is not valid
var ErrInvalidPublicKey = &amp;customError{"invalid public key"}

// customError is a simple error type for testing
type customError struct {
    msg string
}

func (e *customError) Error() string <span class="cov0" title="0">{
    return e.msg
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: selfchain/keyless/audit.proto

package types

import (
        fmt "fmt"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
        _ "google.golang.org/protobuf/types/known/timestamppb"
        io "io"
        math "math"
        math_bits "math/bits"
        time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AuditEvent represents an auditable event in the keyless wallet system
type AuditEvent struct {
        WalletId  string     `protobuf:"bytes,1,opt,name=wallet_id,json=walletId,proto3" json:"wallet_id,omitempty"`
        EventType string     `protobuf:"bytes,2,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
        Success   bool       `protobuf:"varint,3,opt,name=success,proto3" json:"success,omitempty"`
        Details   string     `protobuf:"bytes,4,opt,name=details,proto3" json:"details,omitempty"`
        Timestamp *time.Time `protobuf:"bytes,5,opt,name=timestamp,proto3,stdtime" json:"timestamp,omitempty"`
        Creator   string     `protobuf:"bytes,6,opt,name=creator,proto3" json:"creator,omitempty"`
        ChainId   string     `protobuf:"bytes,7,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *AuditEvent) Reset()         <span class="cov0" title="0">{ *m = AuditEvent{} }</span>
func (m *AuditEvent) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*AuditEvent) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*AuditEvent) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_1a66d085beba2eb5, []int{0}
}</span>
func (m *AuditEvent) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *AuditEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_AuditEvent.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *AuditEvent) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_AuditEvent.Merge(m, src)
}</span>
func (m *AuditEvent) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *AuditEvent) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_AuditEvent.DiscardUnknown(m)
}</span>

var xxx_messageInfo_AuditEvent proto.InternalMessageInfo

func (m *AuditEvent) GetWalletId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WalletId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *AuditEvent) GetEventType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.EventType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *AuditEvent) GetSuccess() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *AuditEvent) GetDetails() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Details
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *AuditEvent) GetTimestamp() *time.Time <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Timestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *AuditEvent) GetCreator() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Creator
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *AuditEvent) GetChainId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ChainId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*AuditEvent)(nil), "selfchain.keyless.AuditEvent")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("selfchain/keyless/audit.proto", fileDescriptor_1a66d085beba2eb5) }</span>

var fileDescriptor_1a66d085beba2eb5 = []byte{
        // 296 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x44, 0x90, 0xbd, 0x4e, 0xc3, 0x30,
        0x14, 0x85, 0x6b, 0x28, 0x6d, 0x63, 0x26, 0x2c, 0x06, 0xb7, 0xa8, 0x6e, 0xc5, 0x94, 0x29, 0x91,
        0xe8, 0x8e, 0x44, 0x25, 0x86, 0xae, 0x51, 0x27, 0x96, 0xca, 0x4d, 0x6e, 0x43, 0x84, 0x5b, 0x47,
        0xb1, 0x03, 0xe4, 0x2d, 0xfa, 0x58, 0x8c, 0x1d, 0xd9, 0x40, 0xc9, 0x13, 0xf0, 0x06, 0xc8, 0xce,
        0x4f, 0x37, 0x1f, 0x7f, 0xe7, 0x5e, 0x9d, 0x7b, 0xf0, 0x54, 0x81, 0xd8, 0x85, 0xaf, 0x3c, 0x39,
        0xf8, 0x6f, 0x50, 0x08, 0x50, 0xca, 0xe7, 0x79, 0x94, 0x68, 0x2f, 0xcd, 0xa4, 0x96, 0xe4, 0xa6,
        0xc3, 0x5e, 0x83, 0x27, 0xb7, 0xb1, 0x8c, 0xa5, 0xa5, 0xbe, 0x79, 0xd5, 0xc6, 0xc9, 0x2c, 0x96,
        0x32, 0x16, 0xe0, 0x5b, 0xb5, 0xcd, 0x77, 0xbe, 0x4e, 0xf6, 0xa0, 0x34, 0xdf, 0xa7, 0xb5, 0xe1,
        0xfe, 0x0f, 0x61, 0xfc, 0x64, 0x36, 0x3f, 0xbf, 0xc3, 0x41, 0x93, 0x3b, 0xec, 0x7c, 0x70, 0x21,
        0x40, 0x6f, 0x92, 0x88, 0xa2, 0x39, 0x72, 0x9d, 0x60, 0x54, 0x7f, 0xac, 0x22, 0x32, 0xc5, 0x18,
        0x8c, 0x6b, 0xa3, 0x8b, 0x14, 0xe8, 0x85, 0xa5, 0x8e, 0xfd, 0x59, 0x17, 0x29, 0x10, 0x8a, 0x87,
        0x2a, 0x0f, 0x43, 0x50, 0x8a, 0x5e, 0xce, 0x91, 0x3b, 0x0a, 0x5a, 0x69, 0x48, 0x04, 0x9a, 0x27,
        0x42, 0xd1, 0xbe, 0x9d, 0x6a, 0x25, 0x79, 0xc4, 0x4e, 0x97, 0x88, 0x5e, 0xcd, 0x91, 0x7b, 0xfd,
        0x30, 0xf1, 0xea, 0xcc, 0x5e, 0x9b, 0xd9, 0x5b, 0xb7, 0x8e, 0x65, 0xff, 0xf8, 0x33, 0x43, 0xc1,
        0x79, 0xc4, 0x6c, 0x0e, 0x33, 0xe0, 0x5a, 0x66, 0x74, 0x50, 0x6f, 0x6e, 0x24, 0x19, 0xe3, 0x91,
        0x2d, 0xc8, 0x1c, 0x32, 0x6c, 0x90, 0xd1, 0xab, 0x68, 0xb9, 0xf8, 0x2a, 0x19, 0x3a, 0x95, 0x0c,
        0xfd, 0x96, 0x0c, 0x1d, 0x2b, 0xd6, 0x3b, 0x55, 0xac, 0xf7, 0x5d, 0xb1, 0xde, 0xcb, 0xf8, 0x5c,
        0xfb, 0x67, 0x57, 0xbc, 0xb9, 0x56, 0x6d, 0x07, 0x36, 0xce, 0xe2, 0x3f, 0x00, 0x00, 0xff, 0xff,
        0x57, 0xa3, 0xb7, 0xc1, 0x9a, 0x01, 0x00, 0x00,
}

func (m *AuditEvent) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *AuditEvent) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *AuditEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.ChainId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ChainId)
                copy(dAtA[i:], m.ChainId)
                i = encodeVarintAudit(dAtA, i, uint64(len(m.ChainId)))
                i--
                dAtA[i] = 0x3a
        }</span>
        <span class="cov0" title="0">if len(m.Creator) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Creator)
                copy(dAtA[i:], m.Creator)
                i = encodeVarintAudit(dAtA, i, uint64(len(m.Creator)))
                i--
                dAtA[i] = 0x32
        }</span>
        <span class="cov0" title="0">if m.Timestamp != nil </span><span class="cov0" title="0">{
                n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.Timestamp):])
                if err1 != nil </span><span class="cov0" title="0">{
                        return 0, err1
                }</span>
                <span class="cov0" title="0">i -= n1
                i = encodeVarintAudit(dAtA, i, uint64(n1))
                i--
                dAtA[i] = 0x2a</span>
        }
        <span class="cov0" title="0">if len(m.Details) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Details)
                copy(dAtA[i:], m.Details)
                i = encodeVarintAudit(dAtA, i, uint64(len(m.Details)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov0" title="0">if m.Success </span><span class="cov0" title="0">{
                i--
                if m.Success </span><span class="cov0" title="0">{
                        dAtA[i] = 1
                }</span> else<span class="cov0" title="0"> {
                        dAtA[i] = 0
                }</span>
                <span class="cov0" title="0">i--
                dAtA[i] = 0x18</span>
        }
        <span class="cov0" title="0">if len(m.EventType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.EventType)
                copy(dAtA[i:], m.EventType)
                i = encodeVarintAudit(dAtA, i, uint64(len(m.EventType)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.WalletId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.WalletId)
                copy(dAtA[i:], m.WalletId)
                i = encodeVarintAudit(dAtA, i, uint64(len(m.WalletId)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintAudit(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovAudit(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *AuditEvent) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.WalletId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovAudit(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.EventType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovAudit(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Success </span><span class="cov0" title="0">{
                n += 2
        }</span>
        <span class="cov0" title="0">l = len(m.Details)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovAudit(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Timestamp != nil </span><span class="cov0" title="0">{
                l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.Timestamp)
                n += 1 + l + sovAudit(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Creator)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovAudit(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.ChainId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovAudit(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovAudit(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozAudit(x uint64) (n int) <span class="cov0" title="0">{
        return sovAudit(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *AuditEvent) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowAudit
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: AuditEvent: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: AuditEvent: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WalletId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAudit
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAudit
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAudit
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.WalletId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAudit
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAudit
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAudit
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.EventType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
                        }</span>
                        <span class="cov0" title="0">var v int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAudit
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                v |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">m.Success = bool(v != 0)</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAudit
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAudit
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAudit
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Details = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 5:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAudit
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAudit
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAudit
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Timestamp == nil </span><span class="cov0" title="0">{
                                m.Timestamp = new(time.Time)
                        }</span>
                        <span class="cov0" title="0">if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.Timestamp, dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 6:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAudit
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAudit
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAudit
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Creator = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 7:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAudit
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAudit
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAudit
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ChainId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipAudit(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAudit
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipAudit(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowAudit
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowAudit
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowAudit
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthAudit
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupAudit
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthAudit
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthAudit        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowAudit          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupAudit = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file40" style="display: none">package types

import (
        "github.com/cosmos/cosmos-sdk/codec"
        cdctypes "github.com/cosmos/cosmos-sdk/codec/types"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/msgservice"
)

func RegisterCodec(cdc *codec.LegacyAmino) <span class="cov0" title="0">{
        cdc.RegisterConcrete(&amp;MsgCreateWallet{}, "keyless/CreateWallet", nil)
        cdc.RegisterConcrete(&amp;MsgRecoverWallet{}, "keyless/RecoverWallet", nil)
        cdc.RegisterConcrete(&amp;MsgSignTransaction{}, "keyless/SignTransaction", nil)
        cdc.RegisterConcrete(&amp;MsgBatchSign{}, "keyless/BatchSign", nil)
        cdc.RegisterConcrete(&amp;MsgInitiateKeyRotation{}, "keyless/InitiateKeyRotation", nil)
        cdc.RegisterConcrete(&amp;MsgCompleteKeyRotation{}, "keyless/CompleteKeyRotation", nil)
        cdc.RegisterConcrete(&amp;MsgCancelKeyRotation{}, "keyless/CancelKeyRotation", nil)
}</span>

func RegisterInterfaces(registry cdctypes.InterfaceRegistry) <span class="cov0" title="0">{
        registry.RegisterImplementations((*sdk.Msg)(nil),
                &amp;MsgCreateWallet{},
                &amp;MsgRecoverWallet{},
                &amp;MsgSignTransaction{},
                &amp;MsgBatchSign{},
                &amp;MsgInitiateKeyRotation{},
                &amp;MsgCompleteKeyRotation{},
                &amp;MsgCancelKeyRotation{},
        )

        msgservice.RegisterMsgServiceDesc(registry, &amp;_Msg_serviceDesc)
}</span>

var (
        Amino     = codec.NewLegacyAmino()
        ModuleCdc = codec.NewProtoCodec(cdctypes.NewInterfaceRegistry())
)
</pre>
		
		<pre class="file" id="file41" style="display: none">package types

import (
// this line is used by starport scaffolding # genesis/types/import
)

// DefaultIndex is the default global index
const DefaultIndex uint64 = 1

// DefaultGenesis returns the default genesis state
func DefaultGenesis() *GenesisState <span class="cov8" title="1">{
        return &amp;GenesisState{
                // this line is used by starport scaffolding # genesis/types/default
                Params: DefaultParams(),
        }
}</span>

// Validate performs basic genesis state validation returning an error upon any
// failure.
func (gs GenesisState) Validate() error <span class="cov8" title="1">{
        // this line is used by starport scaffolding # genesis/types/validate

        return gs.Params.Validate()
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: selfchain/keyless/genesis.proto

package types

import (
        fmt "fmt"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GenesisState defines the keyless module's genesis state.
type GenesisState struct {
        Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
}

func (m *GenesisState) Reset()         <span class="cov0" title="0">{ *m = GenesisState{} }</span>
func (m *GenesisState) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GenesisState) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GenesisState) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dd603c64dc408165, []int{0}
}</span>
func (m *GenesisState) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *GenesisState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_GenesisState.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *GenesisState) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GenesisState.Merge(m, src)
}</span>
func (m *GenesisState) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *GenesisState) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GenesisState.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GenesisState proto.InternalMessageInfo

func (m *GenesisState) GetParams() Params <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Params
        }</span>
        <span class="cov0" title="0">return Params{}</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*GenesisState)(nil), "selfchain.keyless.GenesisState")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("selfchain/keyless/genesis.proto", fileDescriptor_dd603c64dc408165) }</span>

var fileDescriptor_dd603c64dc408165 = []byte{
        // 176 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0x2f, 0x4e, 0xcd, 0x49,
        0x4b, 0xce, 0x48, 0xcc, 0xcc, 0xd3, 0xcf, 0x4e, 0xad, 0xcc, 0x49, 0x2d, 0x2e, 0xd6, 0x4f, 0x4f,
        0xcd, 0x4b, 0x2d, 0xce, 0x2c, 0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x12, 0x84, 0x2b, 0xd0,
        0x83, 0x2a, 0x90, 0x12, 0x49, 0xcf, 0x4f, 0xcf, 0x07, 0xcb, 0xea, 0x83, 0x58, 0x10, 0x85, 0x52,
        0x72, 0x98, 0x26, 0x15, 0x24, 0x16, 0x25, 0xe6, 0x42, 0x0d, 0x52, 0x72, 0xe7, 0xe2, 0x71, 0x87,
        0x98, 0x1c, 0x5c, 0x92, 0x58, 0x92, 0x2a, 0x64, 0xce, 0xc5, 0x06, 0x91, 0x97, 0x60, 0x54, 0x60,
        0xd4, 0xe0, 0x36, 0x92, 0xd4, 0xc3, 0xb0, 0x49, 0x2f, 0x00, 0xac, 0xc0, 0x89, 0xe5, 0xc4, 0x3d,
        0x79, 0x86, 0x20, 0xa8, 0x72, 0x27, 0xe3, 0x13, 0x8f, 0xe4, 0x18, 0x2f, 0x3c, 0x92, 0x63, 0x7c,
        0xf0, 0x48, 0x8e, 0x71, 0xc2, 0x63, 0x39, 0x86, 0x0b, 0x8f, 0xe5, 0x18, 0x6e, 0x3c, 0x96, 0x63,
        0x88, 0x92, 0x44, 0x38, 0xa1, 0x02, 0xee, 0x88, 0x92, 0xca, 0x82, 0xd4, 0xe2, 0x24, 0x36, 0xb0,
        0x23, 0x8c, 0x01, 0x01, 0x00, 0x00, 0xff, 0xff, 0xb9, 0x0c, 0x6a, 0xdb, 0xf0, 0x00, 0x00, 0x00,
}

func (m *GenesisState) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *GenesisState) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *GenesisState) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintGenesis(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func encodeVarintGenesis(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovGenesis(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *GenesisState) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Params.Size()
        n += 1 + l + sovGenesis(uint64(l))
        return n</span>
}

func sovGenesis(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozGenesis(x uint64) (n int) <span class="cov0" title="0">{
        return sovGenesis(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *GenesisState) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowGenesis
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GenesisState: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GenesisState: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipGenesis(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipGenesis(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowGenesis
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupGenesis
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthGenesis
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthGenesis        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowGenesis          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupGenesis = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file43" style="display: none">package types

// Validate validates a KeyGenRequest
func (r *KeyGenRequest) Validate() error <span class="cov0" title="0">{
        if r.WalletId == "" </span><span class="cov0" title="0">{
                return ErrInvalidRequest.Wrap("wallet ID is required")
        }</span>
        <span class="cov0" title="0">if r.ChainId == "" </span><span class="cov0" title="0">{
                return ErrInvalidRequest.Wrap("chain ID is required")
        }</span>
        <span class="cov0" title="0">if !r.SecurityLevel.IsValid() </span><span class="cov0" title="0">{
                return ErrInvalidRequest.Wrap("invalid security level")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ValidateBasic performs basic validation of an EncryptedShare
func (s *EncryptedShare) ValidateBasic() error <span class="cov0" title="0">{
        if s.EncryptedData == "" </span><span class="cov0" title="0">{
                return ErrInvalidShare.Wrap("encrypted data is required")
        }</span>
        <span class="cov0" title="0">if s.KeyId == "" </span><span class="cov0" title="0">{
                return ErrInvalidShare.Wrap("key ID is required")
        }</span>
        <span class="cov0" title="0">if s.Version == 0 </span><span class="cov0" title="0">{
                return ErrInvalidShare.Wrap("version is required")
        }</span>
        <span class="cov0" title="0">if s.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                return ErrInvalidShare.Wrap("creation time is required")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ValidateBasic performs basic validation of a KeyGenResponse
func (r *KeyGenResponse) ValidateBasic() error <span class="cov0" title="0">{
        if r.WalletId == "" </span><span class="cov0" title="0">{
                return ErrInvalidResponse.Wrap("wallet ID is required")
        }</span>
        <span class="cov0" title="0">if len(r.PublicKey) == 0 </span><span class="cov0" title="0">{
                return ErrInvalidResponse.Wrap("public key is required")
        }</span>
        <span class="cov0" title="0">if r.Metadata == nil </span><span class="cov0" title="0">{
                return ErrInvalidResponse.Wrap("metadata is required")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: selfchain/keyless/keygen.proto

package types

import (
        fmt "fmt"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
        _ "google.golang.org/protobuf/types/known/timestamppb"
        io "io"
        math "math"
        math_bits "math/bits"
        time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SecurityLevel defines the security requirements
type SecurityLevel int32

const (
        SecurityLevel_SECURITY_LEVEL_UNSPECIFIED SecurityLevel = 0
        SecurityLevel_SECURITY_LEVEL_STANDARD    SecurityLevel = 1
        SecurityLevel_SECURITY_LEVEL_HIGH        SecurityLevel = 2
        SecurityLevel_SECURITY_LEVEL_ENTERPRISE  SecurityLevel = 3
)

var SecurityLevel_name = map[int32]string{
        0: "SECURITY_LEVEL_UNSPECIFIED",
        1: "SECURITY_LEVEL_STANDARD",
        2: "SECURITY_LEVEL_HIGH",
        3: "SECURITY_LEVEL_ENTERPRISE",
}

var SecurityLevel_value = map[string]int32{
        "SECURITY_LEVEL_UNSPECIFIED": 0,
        "SECURITY_LEVEL_STANDARD":    1,
        "SECURITY_LEVEL_HIGH":        2,
        "SECURITY_LEVEL_ENTERPRISE":  3,
}

func (x SecurityLevel) String() string <span class="cov0" title="0">{
        return proto.EnumName(SecurityLevel_name, int32(x))
}</span>

func (SecurityLevel) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_855858f207a4fe63, []int{0}
}</span>

// BackupStatus represents the current backup state of key shares
type BackupStatus int32

const (
        BackupStatus_BACKUP_STATUS_UNSPECIFIED BackupStatus = 0
        BackupStatus_BACKUP_STATUS_NONE        BackupStatus = 1
        BackupStatus_BACKUP_STATUS_PENDING     BackupStatus = 2
        BackupStatus_BACKUP_STATUS_COMPLETED   BackupStatus = 3
        BackupStatus_BACKUP_STATUS_FAILED      BackupStatus = 4
)

var BackupStatus_name = map[int32]string{
        0: "BACKUP_STATUS_UNSPECIFIED",
        1: "BACKUP_STATUS_NONE",
        2: "BACKUP_STATUS_PENDING",
        3: "BACKUP_STATUS_COMPLETED",
        4: "BACKUP_STATUS_FAILED",
}

var BackupStatus_value = map[string]int32{
        "BACKUP_STATUS_UNSPECIFIED": 0,
        "BACKUP_STATUS_NONE":        1,
        "BACKUP_STATUS_PENDING":     2,
        "BACKUP_STATUS_COMPLETED":   3,
        "BACKUP_STATUS_FAILED":      4,
}

func (x BackupStatus) String() string <span class="cov0" title="0">{
        return proto.EnumName(BackupStatus_name, int32(x))
}</span>

func (BackupStatus) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_855858f207a4fe63, []int{1}
}</span>

// KeyMetadata tracks key status and usage
type KeyMetadata struct {
        CreatedAt     time.Time     `protobuf:"bytes,1,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at"`
        LastRotated   time.Time     `protobuf:"bytes,2,opt,name=last_rotated,json=lastRotated,proto3,stdtime" json:"last_rotated"`
        LastUsed      time.Time     `protobuf:"bytes,3,opt,name=last_used,json=lastUsed,proto3,stdtime" json:"last_used"`
        UsageCount    uint64        `protobuf:"varint,4,opt,name=usage_count,json=usageCount,proto3" json:"usage_count,omitempty"`
        BackupStatus  BackupStatus  `protobuf:"varint,5,opt,name=backup_status,json=backupStatus,proto3,enum=selfchain.keyless.BackupStatus" json:"backup_status,omitempty"`
        SecurityLevel SecurityLevel `protobuf:"varint,6,opt,name=security_level,json=securityLevel,proto3,enum=selfchain.keyless.SecurityLevel" json:"security_level,omitempty"`
}

func (m *KeyMetadata) Reset()         <span class="cov0" title="0">{ *m = KeyMetadata{} }</span>
func (m *KeyMetadata) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*KeyMetadata) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*KeyMetadata) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_855858f207a4fe63, []int{0}
}</span>
func (m *KeyMetadata) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *KeyMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_KeyMetadata.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *KeyMetadata) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_KeyMetadata.Merge(m, src)
}</span>
func (m *KeyMetadata) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *KeyMetadata) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_KeyMetadata.DiscardUnknown(m)
}</span>

var xxx_messageInfo_KeyMetadata proto.InternalMessageInfo

func (m *KeyMetadata) GetCreatedAt() time.Time <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CreatedAt
        }</span>
        <span class="cov0" title="0">return time.Time{}</span>
}

func (m *KeyMetadata) GetLastRotated() time.Time <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.LastRotated
        }</span>
        <span class="cov0" title="0">return time.Time{}</span>
}

func (m *KeyMetadata) GetLastUsed() time.Time <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.LastUsed
        }</span>
        <span class="cov0" title="0">return time.Time{}</span>
}

func (m *KeyMetadata) GetUsageCount() uint64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UsageCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *KeyMetadata) GetBackupStatus() BackupStatus <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BackupStatus
        }</span>
        <span class="cov0" title="0">return BackupStatus_BACKUP_STATUS_UNSPECIFIED</span>
}

func (m *KeyMetadata) GetSecurityLevel() SecurityLevel <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SecurityLevel
        }</span>
        <span class="cov0" title="0">return SecurityLevel_SECURITY_LEVEL_UNSPECIFIED</span>
}

// EncryptedShare represents an encrypted key share with metadata
type EncryptedShare struct {
        EncryptedData string    `protobuf:"bytes,1,opt,name=encrypted_data,json=encryptedData,proto3" json:"encrypted_data,omitempty"`
        KeyId         string    `protobuf:"bytes,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
        Version       uint32    `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
        CreatedAt     time.Time `protobuf:"bytes,4,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at"`
}

func (m *EncryptedShare) Reset()         <span class="cov0" title="0">{ *m = EncryptedShare{} }</span>
func (m *EncryptedShare) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*EncryptedShare) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*EncryptedShare) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_855858f207a4fe63, []int{1}
}</span>
func (m *EncryptedShare) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *EncryptedShare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_EncryptedShare.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *EncryptedShare) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_EncryptedShare.Merge(m, src)
}</span>
func (m *EncryptedShare) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *EncryptedShare) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_EncryptedShare.DiscardUnknown(m)
}</span>

var xxx_messageInfo_EncryptedShare proto.InternalMessageInfo

func (m *EncryptedShare) GetEncryptedData() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.EncryptedData
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *EncryptedShare) GetKeyId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *EncryptedShare) GetVersion() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Version
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *EncryptedShare) GetCreatedAt() time.Time <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CreatedAt
        }</span>
        <span class="cov0" title="0">return time.Time{}</span>
}

// PartyData represents TSS party data
type PartyData struct {
        PartyId          string `protobuf:"bytes,1,opt,name=party_id,json=partyId,proto3" json:"party_id,omitempty"`
        PublicKey        []byte `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
        PartyShare       []byte `protobuf:"bytes,3,opt,name=party_share,json=partyShare,proto3" json:"party_share,omitempty"`
        VerificationData []byte `protobuf:"bytes,4,opt,name=verification_data,json=verificationData,proto3" json:"verification_data,omitempty"`
        ChainId          string `protobuf:"bytes,5,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
        Status           string `protobuf:"bytes,6,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *PartyData) Reset()         <span class="cov0" title="0">{ *m = PartyData{} }</span>
func (m *PartyData) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*PartyData) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*PartyData) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_855858f207a4fe63, []int{2}
}</span>
func (m *PartyData) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *PartyData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_PartyData.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *PartyData) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_PartyData.Merge(m, src)
}</span>
func (m *PartyData) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *PartyData) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_PartyData.DiscardUnknown(m)
}</span>

var xxx_messageInfo_PartyData proto.InternalMessageInfo

func (m *PartyData) GetPartyId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PartyId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *PartyData) GetPublicKey() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PublicKey
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *PartyData) GetPartyShare() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PartyShare
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *PartyData) GetVerificationData() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VerificationData
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *PartyData) GetChainId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ChainId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *PartyData) GetStatus() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// KeyGenRequest represents a request to generate new key shares
type KeyGenRequest struct {
        WalletId      string        `protobuf:"bytes,1,opt,name=wallet_id,json=walletId,proto3" json:"wallet_id,omitempty"`
        ChainId       string        `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
        SecurityLevel SecurityLevel `protobuf:"varint,3,opt,name=security_level,json=securityLevel,proto3,enum=selfchain.keyless.SecurityLevel" json:"security_level,omitempty"`
}

func (m *KeyGenRequest) Reset()         <span class="cov0" title="0">{ *m = KeyGenRequest{} }</span>
func (m *KeyGenRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*KeyGenRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*KeyGenRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_855858f207a4fe63, []int{3}
}</span>
func (m *KeyGenRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *KeyGenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_KeyGenRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *KeyGenRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_KeyGenRequest.Merge(m, src)
}</span>
func (m *KeyGenRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *KeyGenRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_KeyGenRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_KeyGenRequest proto.InternalMessageInfo

func (m *KeyGenRequest) GetWalletId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WalletId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *KeyGenRequest) GetChainId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ChainId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *KeyGenRequest) GetSecurityLevel() SecurityLevel <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SecurityLevel
        }</span>
        <span class="cov0" title="0">return SecurityLevel_SECURITY_LEVEL_UNSPECIFIED</span>
}

// KeyGenResponse represents the response from key generation
type KeyGenResponse struct {
        WalletId  string       `protobuf:"bytes,1,opt,name=wallet_id,json=walletId,proto3" json:"wallet_id,omitempty"`
        PublicKey []byte       `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
        Metadata  *KeyMetadata `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *KeyGenResponse) Reset()         <span class="cov0" title="0">{ *m = KeyGenResponse{} }</span>
func (m *KeyGenResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*KeyGenResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*KeyGenResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_855858f207a4fe63, []int{4}
}</span>
func (m *KeyGenResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *KeyGenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_KeyGenResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *KeyGenResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_KeyGenResponse.Merge(m, src)
}</span>
func (m *KeyGenResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *KeyGenResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_KeyGenResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_KeyGenResponse proto.InternalMessageInfo

func (m *KeyGenResponse) GetWalletId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WalletId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *KeyGenResponse) GetPublicKey() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PublicKey
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *KeyGenResponse) GetMetadata() *KeyMetadata <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterEnum("selfchain.keyless.SecurityLevel", SecurityLevel_name, SecurityLevel_value)
        proto.RegisterEnum("selfchain.keyless.BackupStatus", BackupStatus_name, BackupStatus_value)
        proto.RegisterType((*KeyMetadata)(nil), "selfchain.keyless.KeyMetadata")
        proto.RegisterType((*EncryptedShare)(nil), "selfchain.keyless.EncryptedShare")
        proto.RegisterType((*PartyData)(nil), "selfchain.keyless.PartyData")
        proto.RegisterType((*KeyGenRequest)(nil), "selfchain.keyless.KeyGenRequest")
        proto.RegisterType((*KeyGenResponse)(nil), "selfchain.keyless.KeyGenResponse")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("selfchain/keyless/keygen.proto", fileDescriptor_855858f207a4fe63) }</span>

var fileDescriptor_855858f207a4fe63 = []byte{
        // 749 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0x4d, 0x6f, 0xdb, 0x46,
        0x10, 0xd5, 0x5a, 0xb2, 0x22, 0x8d, 0x25, 0x81, 0xd9, 0xe6, 0x43, 0x76, 0x10, 0xca, 0x30, 0x50,
        0xc0, 0x48, 0x01, 0x19, 0x48, 0x6e, 0xbd, 0xc9, 0x22, 0xa3, 0x10, 0x56, 0x14, 0x61, 0x29, 0x15,
        0x68, 0x2f, 0x04, 0x45, 0x8e, 0x15, 0x42, 0x34, 0xc9, 0x72, 0x97, 0x6e, 0x79, 0xef, 0xa1, 0xa7,
        0xc2, 0xb7, 0xfe, 0x8a, 0xfe, 0x8d, 0x22, 0xc7, 0x1c, 0x7b, 0x6a, 0x0b, 0xfb, 0x8f, 0x14, 0xbb,
        0x94, 0x1c, 0x49, 0x09, 0x1a, 0xc4, 0x27, 0x69, 0xde, 0x7b, 0xf3, 0xf8, 0x38, 0xc3, 0x5d, 0xd0,
        0x39, 0x86, 0xe7, 0xde, 0x5b, 0x37, 0x88, 0x4e, 0x16, 0x98, 0x87, 0xc8, 0xb9, 0xfc, 0x9d, 0x63,
        0xd4, 0x4d, 0xd2, 0x58, 0xc4, 0xf4, 0xfe, 0x2d, 0xdf, 0x5d, 0xf2, 0x07, 0x0f, 0xe6, 0xf1, 0x3c,
        0x56, 0xec, 0x89, 0xfc, 0x57, 0x08, 0x0f, 0x3a, 0xf3, 0x38, 0x9e, 0x87, 0x78, 0xa2, 0xaa, 0x59,
        0x76, 0x7e, 0x22, 0x82, 0x0b, 0xe4, 0xc2, 0xbd, 0x48, 0x0a, 0xc1, 0xd1, 0x6f, 0x65, 0xd8, 0x3b,
        0xc3, 0xfc, 0x35, 0x0a, 0xd7, 0x77, 0x85, 0x4b, 0xfb, 0x00, 0x5e, 0x8a, 0xae, 0x40, 0xdf, 0x71,
        0x45, 0x9b, 0x1c, 0x92, 0xe3, 0xbd, 0xe7, 0x07, 0xdd, 0xc2, 0xa5, 0xbb, 0x72, 0xe9, 0x4e, 0x56,
        0x2e, 0xa7, 0xb5, 0x77, 0x7f, 0x77, 0x4a, 0x57, 0xff, 0x74, 0x08, 0xab, 0x2f, 0xfb, 0x7a, 0x82,
        0x0e, 0xa0, 0x11, 0xba, 0x5c, 0x38, 0x69, 0x2c, 0x24, 0xd2, 0xde, 0xf9, 0x02, 0x9b, 0x3d, 0xd9,
        0xc9, 0x8a, 0x46, 0xda, 0x83, 0xba, 0x32, 0xca, 0x38, 0xfa, 0xed, 0xf2, 0x17, 0xb8, 0xd4, 0x64,
        0xdb, 0x94, 0xa3, 0x4f, 0x3b, 0xb0, 0x97, 0x71, 0x77, 0x8e, 0x8e, 0x17, 0x67, 0x91, 0x68, 0x57,
        0x0e, 0xc9, 0x71, 0x85, 0x81, 0x82, 0xfa, 0x12, 0xa1, 0x06, 0x34, 0x67, 0xae, 0xb7, 0xc8, 0x12,
        0x87, 0x0b, 0x57, 0x64, 0xbc, 0xbd, 0x7b, 0x48, 0x8e, 0x5b, 0xcf, 0x3b, 0xdd, 0x8f, 0x66, 0xdc,
        0x3d, 0x55, 0x3a, 0x5b, 0xc9, 0x58, 0x63, 0xb6, 0x56, 0xd1, 0x01, 0xb4, 0x38, 0x7a, 0x59, 0x1a,
        0x88, 0xdc, 0x09, 0xf1, 0x12, 0xc3, 0x76, 0x55, 0xd9, 0x1c, 0x7e, 0xc2, 0xc6, 0x5e, 0x0a, 0x87,
        0x52, 0xc7, 0x9a, 0x7c, 0xbd, 0x3c, 0xfa, 0x83, 0x40, 0xcb, 0x8c, 0xbc, 0x34, 0x4f, 0x04, 0xfa,
        0xf6, 0x5b, 0x37, 0x45, 0xfa, 0x35, 0xb4, 0x70, 0x85, 0x38, 0x72, 0x4b, 0x6a, 0x2f, 0x75, 0xd6,
        0xbc, 0x45, 0x0d, 0xb9, 0xba, 0x87, 0x50, 0x5d, 0x60, 0xee, 0x04, 0xc5, 0xbc, 0xeb, 0x6c, 0x77,
        0x81, 0xb9, 0xe5, 0xd3, 0x36, 0xdc, 0xbb, 0xc4, 0x94, 0x07, 0x71, 0xa4, 0x26, 0xd8, 0x64, 0xab,
        0x72, 0x6b, 0xd7, 0x95, 0x3b, 0xed, 0xfa, 0xe8, 0x4f, 0x02, 0xf5, 0xb1, 0x9b, 0x8a, 0x5c, 0x65,
        0xd8, 0x87, 0x5a, 0x22, 0x0b, 0x99, 0xa2, 0x08, 0x79, 0x4f, 0xd5, 0x96, 0x4f, 0x9f, 0x02, 0x24,
        0xd9, 0x2c, 0x0c, 0x3c, 0x67, 0x81, 0xb9, 0x8a, 0xd8, 0x60, 0xf5, 0x02, 0x39, 0xc3, 0x5c, 0xee,
        0xa9, 0xe8, 0xe4, 0xf2, 0x9d, 0x55, 0xd4, 0x06, 0x03, 0x05, 0x15, 0x53, 0xf8, 0x06, 0xee, 0x5f,
        0x62, 0x1a, 0x9c, 0x07, 0x9e, 0x2b, 0x82, 0x38, 0x2a, 0x06, 0x51, 0x51, 0x32, 0x6d, 0x9d, 0x58,
        0xe5, 0x50, 0x33, 0x97, 0x39, 0x76, 0x8b, 0x1c, 0xaa, 0xb6, 0x7c, 0xfa, 0x08, 0xaa, 0xcb, 0x45,
        0x57, 0x15, 0xb1, 0xac, 0x8e, 0xae, 0x08, 0x34, 0xcf, 0x30, 0x1f, 0x60, 0xc4, 0xf0, 0xc7, 0x0c,
        0xb9, 0xa0, 0x4f, 0xa0, 0xfe, 0x93, 0x1b, 0x86, 0x28, 0x3e, 0xbc, 0x4d, 0xad, 0x00, 0x2c, 0x7f,
        0xe3, 0x09, 0x3b, 0x9b, 0x4f, 0xf8, 0xf8, 0x5b, 0x28, 0xdf, 0xed, 0x5b, 0xf8, 0x95, 0x40, 0x6b,
        0x15, 0x89, 0x27, 0x71, 0xc4, 0xf1, 0xff, 0x33, 0x7d, 0x66, 0xc4, 0xdf, 0x42, 0xed, 0x62, 0x79,
        0xce, 0x97, 0x87, 0x49, 0xff, 0x44, 0xa2, 0xb5, 0xdb, 0x80, 0xdd, 0xea, 0x9f, 0xfd, 0x42, 0xa0,
        0xb9, 0x91, 0x95, 0xea, 0x70, 0x60, 0x9b, 0xfd, 0x29, 0xb3, 0x26, 0xdf, 0x3b, 0x43, 0xf3, 0x3b,
        0x73, 0xe8, 0x4c, 0x47, 0xf6, 0xd8, 0xec, 0x5b, 0x2f, 0x2d, 0xd3, 0xd0, 0x4a, 0xf4, 0x09, 0x3c,
        0xde, 0xe2, 0xed, 0x49, 0x6f, 0x64, 0xf4, 0x98, 0xa1, 0x11, 0xfa, 0x18, 0xbe, 0xda, 0x22, 0x5f,
        0x59, 0x83, 0x57, 0xda, 0x0e, 0x7d, 0x0a, 0xfb, 0x5b, 0x84, 0x39, 0x9a, 0x98, 0x6c, 0xcc, 0x2c,
        0xdb, 0xd4, 0xca, 0xcf, 0x7e, 0x27, 0xd0, 0x58, 0x3f, 0x85, 0x52, 0x7f, 0xda, 0xeb, 0x9f, 0x4d,
        0xc7, 0xd2, 0x7d, 0x32, 0xb5, 0xb7, 0x42, 0x3c, 0x02, 0xba, 0x49, 0x8f, 0xde, 0x8c, 0x4c, 0x8d,
        0xd0, 0x7d, 0x78, 0xb8, 0x89, 0x8f, 0xcd, 0x91, 0x61, 0x8d, 0x06, 0xda, 0x8e, 0xcc, 0xbd, 0x49,
        0xf5, 0xdf, 0xbc, 0x1e, 0x0f, 0xcd, 0x89, 0x69, 0x68, 0x65, 0xda, 0x86, 0x07, 0x9b, 0xe4, 0xcb,
        0x9e, 0x35, 0x34, 0x0d, 0xad, 0x72, 0xfa, 0xe2, 0xdd, 0xb5, 0x4e, 0xde, 0x5f, 0xeb, 0xe4, 0xdf,
        0x6b, 0x9d, 0x5c, 0xdd, 0xe8, 0xa5, 0xf7, 0x37, 0x7a, 0xe9, 0xaf, 0x1b, 0xbd, 0xf4, 0xc3, 0xfe,
        0x87, 0xcb, 0xfc, 0xe7, 0xdb, 0xeb, 0x5c, 0xe4, 0x09, 0xf2, 0x59, 0x55, 0x9d, 0xb2, 0x17, 0xff,
        0x05, 0x00, 0x00, 0xff, 0xff, 0xb0, 0xd5, 0x24, 0x19, 0xf0, 0x05, 0x00, 0x00,
}

func (m *KeyMetadata) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *KeyMetadata) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *KeyMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.SecurityLevel != 0 </span><span class="cov0" title="0">{
                i = encodeVarintKeygen(dAtA, i, uint64(m.SecurityLevel))
                i--
                dAtA[i] = 0x30
        }</span>
        <span class="cov0" title="0">if m.BackupStatus != 0 </span><span class="cov0" title="0">{
                i = encodeVarintKeygen(dAtA, i, uint64(m.BackupStatus))
                i--
                dAtA[i] = 0x28
        }</span>
        <span class="cov0" title="0">if m.UsageCount != 0 </span><span class="cov0" title="0">{
                i = encodeVarintKeygen(dAtA, i, uint64(m.UsageCount))
                i--
                dAtA[i] = 0x20
        }</span>
        <span class="cov0" title="0">n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastUsed, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastUsed):])
        if err1 != nil </span><span class="cov0" title="0">{
                return 0, err1
        }</span>
        <span class="cov0" title="0">i -= n1
        i = encodeVarintKeygen(dAtA, i, uint64(n1))
        i--
        dAtA[i] = 0x1a
        n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastRotated, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastRotated):])
        if err2 != nil </span><span class="cov0" title="0">{
                return 0, err2
        }</span>
        <span class="cov0" title="0">i -= n2
        i = encodeVarintKeygen(dAtA, i, uint64(n2))
        i--
        dAtA[i] = 0x12
        n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
        if err3 != nil </span><span class="cov0" title="0">{
                return 0, err3
        }</span>
        <span class="cov0" title="0">i -= n3
        i = encodeVarintKeygen(dAtA, i, uint64(n3))
        i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func (m *EncryptedShare) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *EncryptedShare) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *EncryptedShare) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
        if err4 != nil </span><span class="cov0" title="0">{
                return 0, err4
        }</span>
        <span class="cov0" title="0">i -= n4
        i = encodeVarintKeygen(dAtA, i, uint64(n4))
        i--
        dAtA[i] = 0x22
        if m.Version != 0 </span><span class="cov0" title="0">{
                i = encodeVarintKeygen(dAtA, i, uint64(m.Version))
                i--
                dAtA[i] = 0x18
        }</span>
        <span class="cov0" title="0">if len(m.KeyId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.KeyId)
                copy(dAtA[i:], m.KeyId)
                i = encodeVarintKeygen(dAtA, i, uint64(len(m.KeyId)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.EncryptedData) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.EncryptedData)
                copy(dAtA[i:], m.EncryptedData)
                i = encodeVarintKeygen(dAtA, i, uint64(len(m.EncryptedData)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *PartyData) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *PartyData) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *PartyData) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Status) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Status)
                copy(dAtA[i:], m.Status)
                i = encodeVarintKeygen(dAtA, i, uint64(len(m.Status)))
                i--
                dAtA[i] = 0x32
        }</span>
        <span class="cov0" title="0">if len(m.ChainId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ChainId)
                copy(dAtA[i:], m.ChainId)
                i = encodeVarintKeygen(dAtA, i, uint64(len(m.ChainId)))
                i--
                dAtA[i] = 0x2a
        }</span>
        <span class="cov0" title="0">if len(m.VerificationData) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.VerificationData)
                copy(dAtA[i:], m.VerificationData)
                i = encodeVarintKeygen(dAtA, i, uint64(len(m.VerificationData)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov0" title="0">if len(m.PartyShare) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.PartyShare)
                copy(dAtA[i:], m.PartyShare)
                i = encodeVarintKeygen(dAtA, i, uint64(len(m.PartyShare)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.PublicKey) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.PublicKey)
                copy(dAtA[i:], m.PublicKey)
                i = encodeVarintKeygen(dAtA, i, uint64(len(m.PublicKey)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.PartyId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.PartyId)
                copy(dAtA[i:], m.PartyId)
                i = encodeVarintKeygen(dAtA, i, uint64(len(m.PartyId)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *KeyGenRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *KeyGenRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *KeyGenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.SecurityLevel != 0 </span><span class="cov0" title="0">{
                i = encodeVarintKeygen(dAtA, i, uint64(m.SecurityLevel))
                i--
                dAtA[i] = 0x18
        }</span>
        <span class="cov0" title="0">if len(m.ChainId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ChainId)
                copy(dAtA[i:], m.ChainId)
                i = encodeVarintKeygen(dAtA, i, uint64(len(m.ChainId)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.WalletId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.WalletId)
                copy(dAtA[i:], m.WalletId)
                i = encodeVarintKeygen(dAtA, i, uint64(len(m.WalletId)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *KeyGenResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *KeyGenResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *KeyGenResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Metadata != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintKeygen(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0x1a</span>
        }
        <span class="cov0" title="0">if len(m.PublicKey) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.PublicKey)
                copy(dAtA[i:], m.PublicKey)
                i = encodeVarintKeygen(dAtA, i, uint64(len(m.PublicKey)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.WalletId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.WalletId)
                copy(dAtA[i:], m.WalletId)
                i = encodeVarintKeygen(dAtA, i, uint64(len(m.WalletId)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintKeygen(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovKeygen(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *KeyMetadata) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
        n += 1 + l + sovKeygen(uint64(l))
        l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastRotated)
        n += 1 + l + sovKeygen(uint64(l))
        l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastUsed)
        n += 1 + l + sovKeygen(uint64(l))
        if m.UsageCount != 0 </span><span class="cov0" title="0">{
                n += 1 + sovKeygen(uint64(m.UsageCount))
        }</span>
        <span class="cov0" title="0">if m.BackupStatus != 0 </span><span class="cov0" title="0">{
                n += 1 + sovKeygen(uint64(m.BackupStatus))
        }</span>
        <span class="cov0" title="0">if m.SecurityLevel != 0 </span><span class="cov0" title="0">{
                n += 1 + sovKeygen(uint64(m.SecurityLevel))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *EncryptedShare) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.EncryptedData)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovKeygen(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.KeyId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovKeygen(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Version != 0 </span><span class="cov0" title="0">{
                n += 1 + sovKeygen(uint64(m.Version))
        }</span>
        <span class="cov0" title="0">l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
        n += 1 + l + sovKeygen(uint64(l))
        return n</span>
}

func (m *PartyData) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.PartyId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovKeygen(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.PublicKey)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovKeygen(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.PartyShare)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovKeygen(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.VerificationData)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovKeygen(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.ChainId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovKeygen(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Status)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovKeygen(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *KeyGenRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.WalletId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovKeygen(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.ChainId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovKeygen(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.SecurityLevel != 0 </span><span class="cov0" title="0">{
                n += 1 + sovKeygen(uint64(m.SecurityLevel))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *KeyGenResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.WalletId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovKeygen(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.PublicKey)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovKeygen(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Metadata != nil </span><span class="cov0" title="0">{
                l = m.Metadata.Size()
                n += 1 + l + sovKeygen(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovKeygen(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozKeygen(x uint64) (n int) <span class="cov0" title="0">{
        return sovKeygen(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *KeyMetadata) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowKeygen
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyMetadata: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowKeygen
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&amp;m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field LastRotated", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowKeygen
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&amp;m.LastRotated, dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field LastUsed", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowKeygen
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&amp;m.LastUsed, dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field UsageCount", wireType)
                        }</span>
                        <span class="cov0" title="0">m.UsageCount = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowKeygen
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.UsageCount |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 5:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field BackupStatus", wireType)
                        }</span>
                        <span class="cov0" title="0">m.BackupStatus = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowKeygen
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.BackupStatus |= BackupStatus(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 6:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SecurityLevel", wireType)
                        }</span>
                        <span class="cov0" title="0">m.SecurityLevel = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowKeygen
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.SecurityLevel |= SecurityLevel(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipKeygen(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *EncryptedShare) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowKeygen
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: EncryptedShare: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: EncryptedShare: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field EncryptedData", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowKeygen
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.EncryptedData = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowKeygen
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.KeyId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Version = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowKeygen
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Version |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowKeygen
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&amp;m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipKeygen(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *PartyData) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowKeygen
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: PartyData: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: PartyData: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PartyId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowKeygen
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.PartyId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowKeygen
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
                        if m.PublicKey == nil </span><span class="cov0" title="0">{
                                m.PublicKey = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PartyShare", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowKeygen
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.PartyShare = append(m.PartyShare[:0], dAtA[iNdEx:postIndex]...)
                        if m.PartyShare == nil </span><span class="cov0" title="0">{
                                m.PartyShare = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VerificationData", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowKeygen
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.VerificationData = append(m.VerificationData[:0], dAtA[iNdEx:postIndex]...)
                        if m.VerificationData == nil </span><span class="cov0" title="0">{
                                m.VerificationData = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 5:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowKeygen
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ChainId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 6:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowKeygen
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Status = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipKeygen(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *KeyGenRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowKeygen
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyGenRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyGenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WalletId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowKeygen
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.WalletId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowKeygen
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ChainId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SecurityLevel", wireType)
                        }</span>
                        <span class="cov0" title="0">m.SecurityLevel = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowKeygen
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.SecurityLevel |= SecurityLevel(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipKeygen(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *KeyGenResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowKeygen
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyGenResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyGenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WalletId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowKeygen
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.WalletId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowKeygen
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
                        if m.PublicKey == nil </span><span class="cov0" title="0">{
                                m.PublicKey = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowKeygen
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Metadata == nil </span><span class="cov0" title="0">{
                                m.Metadata = &amp;KeyMetadata{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipKeygen(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipKeygen(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowKeygen
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowKeygen
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowKeygen
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthKeygen
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupKeygen
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthKeygen
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthKeygen        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowKeygen          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupKeygen = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file45" style="display: none">package types

const (
        // ModuleName defines the module name
        ModuleName = "keyless"

        // StoreKey defines the primary module store key
        StoreKey = ModuleName

        // RouterKey defines the module's message routing key
        RouterKey = ModuleName

        // MemStoreKey defines the in-memory store key
        MemStoreKey = "mem_keyless"

        // Key prefixes
        WalletKey    = "Wallet-"
        KeyShareKey  = "keyshare"
        ParamsKey    = "params"
        PartyDataKey = "PartyData-"
        KeyRotationKey = "key_rotation"
        AuditEventKey = "audit_event"
)

// KeyPrefix returns the KVStore key prefix for the given key type
func KeyPrefix(p string) []byte <span class="cov0" title="0">{
        return []byte(p)
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package types

// NewMsgCreateWallet creates a new MsgCreateWallet instance
func NewMsgCreateWallet(creator, pubKey, walletAddress, chainId string) *MsgCreateWallet <span class="cov0" title="0">{
        return &amp;MsgCreateWallet{
                Creator:       creator,
                PubKey:       pubKey,
                WalletAddress: walletAddress,
                ChainId:      chainId,
        }
}</span>

// NewMsgRecoverWallet creates a new MsgRecoverWallet instance
func NewMsgRecoverWallet(creator, walletAddress, recoveryProof, newPubKey, signature string) *MsgRecoverWallet <span class="cov0" title="0">{
        return &amp;MsgRecoverWallet{
                Creator:       creator,
                WalletAddress: walletAddress,
                RecoveryProof: recoveryProof,
                NewPubKey:    newPubKey,
                Signature:    signature,
        }
}</span>

// NewMsgSignTransaction creates a new MsgSignTransaction instance
func NewMsgSignTransaction(creator, walletAddress, unsignedTx, chainId string) *MsgSignTransaction <span class="cov0" title="0">{
        return &amp;MsgSignTransaction{
                Creator:       creator,
                WalletAddress: walletAddress,
                UnsignedTx:   unsignedTx,
                ChainId:      chainId,
        }
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package types

import (
        sdk "github.com/cosmos/cosmos-sdk/types"
        sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
)

var (
        _ sdk.Msg = &amp;MsgCreateWallet{}
        _ sdk.Msg = &amp;MsgRecoverWallet{}
        _ sdk.Msg = &amp;MsgSignTransaction{}
        _ sdk.Msg = &amp;MsgBatchSign{}
        _ sdk.Msg = &amp;MsgInitiateKeyRotation{}
        _ sdk.Msg = &amp;MsgCompleteKeyRotation{}
        _ sdk.Msg = &amp;MsgCancelKeyRotation{}
)

// Message type constants
const (
        TypeMsgCreateWallet          = "create_wallet"
        TypeMsgRecoverWallet         = "recover_wallet"
        TypeMsgSignTransaction       = "sign_transaction"
        TypeMsgBatchSign            = "batch_sign"
        TypeMsgInitiateKeyRotation  = "initiate_key_rotation"
        TypeMsgCompleteKeyRotation  = "complete_key_rotation"
        TypeMsgCancelKeyRotation    = "cancel_key_rotation"
)

// GetSigners returns the expected signers for MsgCreateWallet
func (msg *MsgCreateWallet) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        creator, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return []sdk.AccAddress{creator}</span>
}

// ValidateBasic performs stateless validation on MsgCreateWallet
func (msg *MsgCreateWallet) ValidateBasic() error <span class="cov0" title="0">{
        _, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov0" title="0">{
                return sdkerrors.Wrapf(sdkerrors.ErrInvalidAddress, "invalid creator address (%s)", err)
        }</span>
        <span class="cov0" title="0">if msg.PubKey == "" </span><span class="cov0" title="0">{
                return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "public key cannot be empty")
        }</span>
        <span class="cov0" title="0">if msg.WalletAddress == "" </span><span class="cov0" title="0">{
                return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "wallet address cannot be empty")
        }</span>
        <span class="cov0" title="0">if msg.ChainId == "" </span><span class="cov0" title="0">{
                return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "chain ID cannot be empty")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetSigners returns the expected signers for MsgRecoverWallet
func (msg *MsgRecoverWallet) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        creator, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return []sdk.AccAddress{creator}</span>
}

// ValidateBasic performs stateless validation on MsgRecoverWallet
func (msg *MsgRecoverWallet) ValidateBasic() error <span class="cov0" title="0">{
        _, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov0" title="0">{
                return sdkerrors.Wrapf(sdkerrors.ErrInvalidAddress, "invalid creator address (%s)", err)
        }</span>
        <span class="cov0" title="0">if msg.WalletAddress == "" </span><span class="cov0" title="0">{
                return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "wallet address cannot be empty")
        }</span>
        <span class="cov0" title="0">if msg.RecoveryProof == "" </span><span class="cov0" title="0">{
                return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "recovery proof cannot be empty")
        }</span>
        <span class="cov0" title="0">if msg.NewPubKey == "" </span><span class="cov0" title="0">{
                return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "new public key cannot be empty")
        }</span>
        <span class="cov0" title="0">if msg.Signature == "" </span><span class="cov0" title="0">{
                return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "signature cannot be empty")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetSigners returns the expected signers for MsgSignTransaction
func (msg *MsgSignTransaction) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        creator, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return []sdk.AccAddress{creator}</span>
}

// ValidateBasic performs stateless validation on MsgSignTransaction
func (msg *MsgSignTransaction) ValidateBasic() error <span class="cov0" title="0">{
        _, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov0" title="0">{
                return sdkerrors.Wrapf(sdkerrors.ErrInvalidAddress, "invalid creator address (%s)", err)
        }</span>
        <span class="cov0" title="0">if msg.WalletAddress == "" </span><span class="cov0" title="0">{
                return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "wallet address cannot be empty")
        }</span>
        <span class="cov0" title="0">if msg.UnsignedTx == "" </span><span class="cov0" title="0">{
                return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "unsigned transaction cannot be empty")
        }</span>
        <span class="cov0" title="0">if msg.ChainId == "" </span><span class="cov0" title="0">{
                return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "chain ID cannot be empty")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetSigners returns the expected signers for MsgBatchSign
func (msg *MsgBatchSign) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        creator, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return []sdk.AccAddress{creator}</span>
}

// ValidateBasic performs stateless validation on MsgBatchSign
func (msg *MsgBatchSign) ValidateBasic() error <span class="cov0" title="0">{
        _, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov0" title="0">{
                return sdkerrors.Wrapf(sdkerrors.ErrInvalidAddress, "invalid creator address (%s)", err)
        }</span>
        <span class="cov0" title="0">if msg.WalletAddress == "" </span><span class="cov0" title="0">{
                return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "wallet address cannot be empty")
        }</span>
        <span class="cov0" title="0">if len(msg.UnsignedTxs) == 0 </span><span class="cov0" title="0">{
                return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "unsigned transactions cannot be empty")
        }</span>
        <span class="cov0" title="0">if msg.ChainId == "" </span><span class="cov0" title="0">{
                return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "chain ID cannot be empty")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetSigners returns the expected signers for MsgInitiateKeyRotation
func (msg *MsgInitiateKeyRotation) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        creator, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return []sdk.AccAddress{creator}</span>
}

// ValidateBasic performs stateless validation on MsgInitiateKeyRotation
func (msg *MsgInitiateKeyRotation) ValidateBasic() error <span class="cov0" title="0">{
        _, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov0" title="0">{
                return sdkerrors.Wrapf(sdkerrors.ErrInvalidAddress, "invalid creator address (%s)", err)
        }</span>
        <span class="cov0" title="0">if msg.WalletAddress == "" </span><span class="cov0" title="0">{
                return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "wallet address cannot be empty")
        }</span>
        <span class="cov0" title="0">if msg.NewPubKey == "" </span><span class="cov0" title="0">{
                return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "new public key cannot be empty")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetSigners returns the expected signers for MsgCompleteKeyRotation
func (msg *MsgCompleteKeyRotation) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        creator, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return []sdk.AccAddress{creator}</span>
}

// ValidateBasic performs stateless validation on MsgCompleteKeyRotation
func (msg *MsgCompleteKeyRotation) ValidateBasic() error <span class="cov0" title="0">{
        _, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov0" title="0">{
                return sdkerrors.Wrapf(sdkerrors.ErrInvalidAddress, "invalid creator address (%s)", err)
        }</span>
        <span class="cov0" title="0">if msg.WalletAddress == "" </span><span class="cov0" title="0">{
                return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "wallet address cannot be empty")
        }</span>
        <span class="cov0" title="0">if msg.Signature == "" </span><span class="cov0" title="0">{
                return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "signature cannot be empty")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetSigners returns the expected signers for MsgCancelKeyRotation
func (msg *MsgCancelKeyRotation) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        creator, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return []sdk.AccAddress{creator}</span>
}

// ValidateBasic performs stateless validation on MsgCancelKeyRotation
func (msg *MsgCancelKeyRotation) ValidateBasic() error <span class="cov0" title="0">{
        _, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov0" title="0">{
                return sdkerrors.Wrapf(sdkerrors.ErrInvalidAddress, "invalid creator address (%s)", err)
        }</span>
        <span class="cov0" title="0">if msg.WalletAddress == "" </span><span class="cov0" title="0">{
                return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "wallet address cannot be empty")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: selfchain/keyless/network.proto

package types

import (
        fmt "fmt"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// NetworkParams defines the parameters for network-specific signing operations
type NetworkParams struct {
        NetworkType      string         `protobuf:"bytes,1,opt,name=network_type,json=networkType,proto3" json:"network_type,omitempty"`
        ChainId          string         `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
        SigningAlgorithm string         `protobuf:"bytes,3,opt,name=signing_algorithm,json=signingAlgorithm,proto3" json:"signing_algorithm,omitempty"`
        CurveType        string         `protobuf:"bytes,4,opt,name=curve_type,json=curveType,proto3" json:"curve_type,omitempty"`
        AddressPrefix    string         `protobuf:"bytes,5,opt,name=address_prefix,json=addressPrefix,proto3" json:"address_prefix,omitempty"`
        CoinType         uint32         `protobuf:"varint,6,opt,name=coin_type,json=coinType,proto3" json:"coin_type,omitempty"`
        Decimals         uint32         `protobuf:"varint,7,opt,name=decimals,proto3" json:"decimals,omitempty"`
        SymbolName       string         `protobuf:"bytes,8,opt,name=symbol_name,json=symbolName,proto3" json:"symbol_name,omitempty"`
        DisplayName      string         `protobuf:"bytes,9,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
        SigningConfig    *SigningConfig `protobuf:"bytes,10,opt,name=signing_config,json=signingConfig,proto3" json:"signing_config,omitempty"`
}

func (m *NetworkParams) Reset()         <span class="cov0" title="0">{ *m = NetworkParams{} }</span>
func (m *NetworkParams) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*NetworkParams) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*NetworkParams) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_1c830b3db207baaa, []int{0}
}</span>
func (m *NetworkParams) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *NetworkParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_NetworkParams.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *NetworkParams) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_NetworkParams.Merge(m, src)
}</span>
func (m *NetworkParams) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *NetworkParams) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_NetworkParams.DiscardUnknown(m)
}</span>

var xxx_messageInfo_NetworkParams proto.InternalMessageInfo

func (m *NetworkParams) GetNetworkType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.NetworkType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *NetworkParams) GetChainId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ChainId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *NetworkParams) GetSigningAlgorithm() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SigningAlgorithm
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *NetworkParams) GetCurveType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CurveType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *NetworkParams) GetAddressPrefix() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.AddressPrefix
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *NetworkParams) GetCoinType() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CoinType
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *NetworkParams) GetDecimals() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Decimals
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *NetworkParams) GetSymbolName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SymbolName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *NetworkParams) GetDisplayName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DisplayName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *NetworkParams) GetSigningConfig() *SigningConfig <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SigningConfig
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SigningConfig contains network-specific signing configuration
type SigningConfig struct {
        P2PkhPrefix   uint32 `protobuf:"varint,1,opt,name=p2pkh_prefix,json=p2pkhPrefix,proto3" json:"p2pkh_prefix,omitempty"`
        P2ShPrefix    uint32 `protobuf:"varint,2,opt,name=p2sh_prefix,json=p2shPrefix,proto3" json:"p2sh_prefix,omitempty"`
        Hrp           string `protobuf:"bytes,3,opt,name=hrp,proto3" json:"hrp,omitempty"`
        Base58Hasher  string `protobuf:"bytes,4,opt,name=base58_hasher,json=base58Hasher,proto3" json:"base58_hasher,omitempty"`
        ChainId       string `protobuf:"bytes,5,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
        GasToken      string `protobuf:"bytes,6,opt,name=gas_token,json=gasToken,proto3" json:"gas_token,omitempty"`
        AddressPrefix string `protobuf:"bytes,7,opt,name=address_prefix,json=addressPrefix,proto3" json:"address_prefix,omitempty"`
        PubKeyPrefix  string `protobuf:"bytes,8,opt,name=pub_key_prefix,json=pubKeyPrefix,proto3" json:"pub_key_prefix,omitempty"`
}

func (m *SigningConfig) Reset()         <span class="cov0" title="0">{ *m = SigningConfig{} }</span>
func (m *SigningConfig) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SigningConfig) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SigningConfig) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_1c830b3db207baaa, []int{1}
}</span>
func (m *SigningConfig) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SigningConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SigningConfig.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SigningConfig) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SigningConfig.Merge(m, src)
}</span>
func (m *SigningConfig) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SigningConfig) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SigningConfig.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SigningConfig proto.InternalMessageInfo

func (m *SigningConfig) GetP2PkhPrefix() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.P2PkhPrefix
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *SigningConfig) GetP2ShPrefix() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.P2ShPrefix
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *SigningConfig) GetHrp() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Hrp
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SigningConfig) GetBase58Hasher() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Base58Hasher
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SigningConfig) GetChainId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ChainId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SigningConfig) GetGasToken() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.GasToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SigningConfig) GetAddressPrefix() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.AddressPrefix
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SigningConfig) GetPubKeyPrefix() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PubKeyPrefix
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*NetworkParams)(nil), "selfchain.keyless.NetworkParams")
        proto.RegisterType((*SigningConfig)(nil), "selfchain.keyless.SigningConfig")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("selfchain/keyless/network.proto", fileDescriptor_1c830b3db207baaa) }</span>

var fileDescriptor_1c830b3db207baaa = []byte{
        // 461 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x92, 0xcf, 0x6e, 0xd3, 0x40,
        0x10, 0x87, 0xe3, 0x84, 0x36, 0xf6, 0x38, 0x8e, 0x5a, 0x9f, 0x5c, 0x2a, 0x9c, 0x50, 0x40, 0x8a,
        0x84, 0x94, 0x4a, 0xa9, 0x90, 0xb8, 0x02, 0x07, 0x40, 0x48, 0x55, 0x15, 0x7a, 0xe2, 0x62, 0xad,
        0xed, 0x8d, 0xbd, 0xf2, 0xbf, 0xd5, 0xae, 0x03, 0xf5, 0x0b, 0x70, 0x85, 0xc7, 0xe2, 0xd8, 0x23,
        0x47, 0x94, 0xbc, 0x08, 0xf2, 0xec, 0x3a, 0x10, 0x35, 0xb7, 0xcc, 0xb7, 0x5f, 0x66, 0xbd, 0xf3,
        0x1b, 0x98, 0x48, 0x9a, 0xaf, 0xa2, 0x94, 0xb0, 0xf2, 0x32, 0xa3, 0x4d, 0x4e, 0xa5, 0xbc, 0x2c,
        0x69, 0xfd, 0xad, 0x12, 0xd9, 0x9c, 0x8b, 0xaa, 0xae, 0xdc, 0xd3, 0x9d, 0x30, 0xd7, 0xc2, 0xc5,
        0xf7, 0x01, 0x38, 0xd7, 0x4a, 0xba, 0x21, 0x82, 0x14, 0xd2, 0x7d, 0x0a, 0x23, 0xfd, 0xaf, 0xa0,
        0x6e, 0x38, 0xf5, 0x8c, 0xa9, 0x31, 0xb3, 0x96, 0xb6, 0x66, 0xb7, 0x0d, 0xa7, 0xee, 0x19, 0x98,
        0xd8, 0x25, 0x60, 0xb1, 0xd7, 0xc7, 0xe3, 0x21, 0xd6, 0x1f, 0x63, 0xf7, 0x25, 0x9c, 0x4a, 0x96,
        0x94, 0xac, 0x4c, 0x02, 0x92, 0x27, 0x95, 0x60, 0x75, 0x5a, 0x78, 0x03, 0x74, 0x4e, 0xf4, 0xc1,
        0x9b, 0x8e, 0xbb, 0x4f, 0x00, 0xa2, 0xb5, 0xf8, 0x4a, 0xd5, 0x45, 0x8f, 0xd0, 0xb2, 0x90, 0xe0,
        0x35, 0x2f, 0x60, 0x4c, 0xe2, 0x58, 0x50, 0x29, 0x03, 0x2e, 0xe8, 0x8a, 0xdd, 0x79, 0x47, 0xa8,
        0x38, 0x9a, 0xde, 0x20, 0x74, 0xcf, 0xc1, 0x8a, 0x2a, 0x56, 0xaa, 0x26, 0xc7, 0x53, 0x63, 0xe6,
        0x2c, 0xcd, 0x16, 0x60, 0x8f, 0xc7, 0x60, 0xc6, 0x34, 0x62, 0x05, 0xc9, 0xa5, 0x37, 0x54, 0x67,
        0x5d, 0xed, 0x4e, 0xc0, 0x96, 0x4d, 0x11, 0x56, 0x79, 0x50, 0x92, 0x82, 0x7a, 0x26, 0x36, 0x07,
        0x85, 0xae, 0x49, 0x41, 0xdb, 0x51, 0xc4, 0x4c, 0xf2, 0x9c, 0x34, 0xca, 0xb0, 0xd4, 0x28, 0x34,
        0x43, 0xe5, 0x3d, 0x8c, 0xbb, 0xf7, 0x46, 0x55, 0xb9, 0x62, 0x89, 0x07, 0x53, 0x63, 0x66, 0x2f,
        0xa6, 0xf3, 0x07, 0xb3, 0x9e, 0x7f, 0x56, 0xe2, 0x3b, 0xf4, 0x96, 0x8e, 0xfc, 0xbf, 0xbc, 0xf8,
        0xd1, 0x07, 0x67, 0x4f, 0x68, 0x6f, 0xe7, 0x0b, 0x9e, 0xa5, 0xdd, 0xe3, 0x0d, 0xfc, 0x7c, 0x1b,
        0x99, 0x7e, 0xfa, 0x04, 0x6c, 0xbe, 0x90, 0x3b, 0xa3, 0x8f, 0x06, 0xb4, 0x48, 0x0b, 0x27, 0x30,
        0x48, 0x05, 0xd7, 0x01, 0xb4, 0x3f, 0xdd, 0x67, 0xe0, 0x84, 0x44, 0xd2, 0x57, 0xaf, 0x83, 0x94,
        0xc8, 0x94, 0x0a, 0x3d, 0xf6, 0x91, 0x82, 0x1f, 0x90, 0xed, 0x05, 0x7c, 0xb4, 0x1f, 0xf0, 0x39,
        0x58, 0x09, 0x91, 0x41, 0x5d, 0x65, 0xb4, 0xc4, 0x69, 0x5b, 0x4b, 0x33, 0x21, 0xf2, 0xb6, 0xad,
        0x0f, 0x24, 0x36, 0x3c, 0x94, 0xd8, 0x73, 0x18, 0xf3, 0x75, 0x18, 0x64, 0xb4, 0xe9, 0x34, 0x35,
        0xfb, 0x11, 0x5f, 0x87, 0x9f, 0x68, 0xa3, 0xac, 0xb7, 0x57, 0xbf, 0x36, 0xbe, 0x71, 0xbf, 0xf1,
        0x8d, 0x3f, 0x1b, 0xdf, 0xf8, 0xb9, 0xf5, 0x7b, 0xf7, 0x5b, 0xbf, 0xf7, 0x7b, 0xeb, 0xf7, 0xbe,
        0x9c, 0xfd, 0x5b, 0xf4, 0xbb, 0xdd, 0xaa, 0xb7, 0xf1, 0xcb, 0xf0, 0x18, 0x37, 0xfd, 0xea, 0x6f,
        0x00, 0x00, 0x00, 0xff, 0xff, 0x18, 0x50, 0x29, 0x8c, 0x0c, 0x03, 0x00, 0x00,
}

func (m *NetworkParams) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *NetworkParams) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *NetworkParams) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.SigningConfig != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.SigningConfig.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintNetwork(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0x52</span>
        }
        <span class="cov0" title="0">if len(m.DisplayName) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.DisplayName)
                copy(dAtA[i:], m.DisplayName)
                i = encodeVarintNetwork(dAtA, i, uint64(len(m.DisplayName)))
                i--
                dAtA[i] = 0x4a
        }</span>
        <span class="cov0" title="0">if len(m.SymbolName) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.SymbolName)
                copy(dAtA[i:], m.SymbolName)
                i = encodeVarintNetwork(dAtA, i, uint64(len(m.SymbolName)))
                i--
                dAtA[i] = 0x42
        }</span>
        <span class="cov0" title="0">if m.Decimals != 0 </span><span class="cov0" title="0">{
                i = encodeVarintNetwork(dAtA, i, uint64(m.Decimals))
                i--
                dAtA[i] = 0x38
        }</span>
        <span class="cov0" title="0">if m.CoinType != 0 </span><span class="cov0" title="0">{
                i = encodeVarintNetwork(dAtA, i, uint64(m.CoinType))
                i--
                dAtA[i] = 0x30
        }</span>
        <span class="cov0" title="0">if len(m.AddressPrefix) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.AddressPrefix)
                copy(dAtA[i:], m.AddressPrefix)
                i = encodeVarintNetwork(dAtA, i, uint64(len(m.AddressPrefix)))
                i--
                dAtA[i] = 0x2a
        }</span>
        <span class="cov0" title="0">if len(m.CurveType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.CurveType)
                copy(dAtA[i:], m.CurveType)
                i = encodeVarintNetwork(dAtA, i, uint64(len(m.CurveType)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov0" title="0">if len(m.SigningAlgorithm) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.SigningAlgorithm)
                copy(dAtA[i:], m.SigningAlgorithm)
                i = encodeVarintNetwork(dAtA, i, uint64(len(m.SigningAlgorithm)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.ChainId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ChainId)
                copy(dAtA[i:], m.ChainId)
                i = encodeVarintNetwork(dAtA, i, uint64(len(m.ChainId)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.NetworkType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.NetworkType)
                copy(dAtA[i:], m.NetworkType)
                i = encodeVarintNetwork(dAtA, i, uint64(len(m.NetworkType)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *SigningConfig) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *SigningConfig) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SigningConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.PubKeyPrefix) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.PubKeyPrefix)
                copy(dAtA[i:], m.PubKeyPrefix)
                i = encodeVarintNetwork(dAtA, i, uint64(len(m.PubKeyPrefix)))
                i--
                dAtA[i] = 0x42
        }</span>
        <span class="cov0" title="0">if len(m.AddressPrefix) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.AddressPrefix)
                copy(dAtA[i:], m.AddressPrefix)
                i = encodeVarintNetwork(dAtA, i, uint64(len(m.AddressPrefix)))
                i--
                dAtA[i] = 0x3a
        }</span>
        <span class="cov0" title="0">if len(m.GasToken) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.GasToken)
                copy(dAtA[i:], m.GasToken)
                i = encodeVarintNetwork(dAtA, i, uint64(len(m.GasToken)))
                i--
                dAtA[i] = 0x32
        }</span>
        <span class="cov0" title="0">if len(m.ChainId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ChainId)
                copy(dAtA[i:], m.ChainId)
                i = encodeVarintNetwork(dAtA, i, uint64(len(m.ChainId)))
                i--
                dAtA[i] = 0x2a
        }</span>
        <span class="cov0" title="0">if len(m.Base58Hasher) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Base58Hasher)
                copy(dAtA[i:], m.Base58Hasher)
                i = encodeVarintNetwork(dAtA, i, uint64(len(m.Base58Hasher)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov0" title="0">if len(m.Hrp) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Hrp)
                copy(dAtA[i:], m.Hrp)
                i = encodeVarintNetwork(dAtA, i, uint64(len(m.Hrp)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if m.P2ShPrefix != 0 </span><span class="cov0" title="0">{
                i = encodeVarintNetwork(dAtA, i, uint64(m.P2ShPrefix))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if m.P2PkhPrefix != 0 </span><span class="cov0" title="0">{
                i = encodeVarintNetwork(dAtA, i, uint64(m.P2PkhPrefix))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintNetwork(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovNetwork(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *NetworkParams) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.NetworkType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovNetwork(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.ChainId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovNetwork(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.SigningAlgorithm)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovNetwork(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.CurveType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovNetwork(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.AddressPrefix)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovNetwork(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.CoinType != 0 </span><span class="cov0" title="0">{
                n += 1 + sovNetwork(uint64(m.CoinType))
        }</span>
        <span class="cov0" title="0">if m.Decimals != 0 </span><span class="cov0" title="0">{
                n += 1 + sovNetwork(uint64(m.Decimals))
        }</span>
        <span class="cov0" title="0">l = len(m.SymbolName)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovNetwork(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.DisplayName)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovNetwork(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.SigningConfig != nil </span><span class="cov0" title="0">{
                l = m.SigningConfig.Size()
                n += 1 + l + sovNetwork(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *SigningConfig) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.P2PkhPrefix != 0 </span><span class="cov0" title="0">{
                n += 1 + sovNetwork(uint64(m.P2PkhPrefix))
        }</span>
        <span class="cov0" title="0">if m.P2ShPrefix != 0 </span><span class="cov0" title="0">{
                n += 1 + sovNetwork(uint64(m.P2ShPrefix))
        }</span>
        <span class="cov0" title="0">l = len(m.Hrp)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovNetwork(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Base58Hasher)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovNetwork(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.ChainId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovNetwork(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.GasToken)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovNetwork(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.AddressPrefix)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovNetwork(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.PubKeyPrefix)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovNetwork(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovNetwork(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozNetwork(x uint64) (n int) <span class="cov0" title="0">{
        return sovNetwork(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *NetworkParams) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowNetwork
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: NetworkParams: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: NetworkParams: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field NetworkType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowNetwork
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.NetworkType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowNetwork
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ChainId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SigningAlgorithm", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowNetwork
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.SigningAlgorithm = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CurveType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowNetwork
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.CurveType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 5:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field AddressPrefix", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowNetwork
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.AddressPrefix = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 6:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CoinType", wireType)
                        }</span>
                        <span class="cov0" title="0">m.CoinType = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowNetwork
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.CoinType |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 7:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Decimals = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowNetwork
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Decimals |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 8:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SymbolName", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowNetwork
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.SymbolName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 9:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowNetwork
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.DisplayName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 10:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SigningConfig", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowNetwork
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.SigningConfig == nil </span><span class="cov0" title="0">{
                                m.SigningConfig = &amp;SigningConfig{}
                        }</span>
                        <span class="cov0" title="0">if err := m.SigningConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipNetwork(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *SigningConfig) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowNetwork
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SigningConfig: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SigningConfig: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field P2PkhPrefix", wireType)
                        }</span>
                        <span class="cov0" title="0">m.P2PkhPrefix = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowNetwork
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.P2PkhPrefix |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field P2ShPrefix", wireType)
                        }</span>
                        <span class="cov0" title="0">m.P2ShPrefix = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowNetwork
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.P2ShPrefix |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Hrp", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowNetwork
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Hrp = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Base58Hasher", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowNetwork
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Base58Hasher = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 5:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowNetwork
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ChainId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 6:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field GasToken", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowNetwork
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.GasToken = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 7:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field AddressPrefix", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowNetwork
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.AddressPrefix = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 8:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PubKeyPrefix", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowNetwork
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.PubKeyPrefix = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipNetwork(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipNetwork(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowNetwork
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowNetwork
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowNetwork
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthNetwork
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupNetwork
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthNetwork
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthNetwork        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowNetwork          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupNetwork = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file49" style="display: none">package types

import (
        paramtypes "github.com/cosmos/cosmos-sdk/x/params/types"
        "gopkg.in/yaml.v2"
)

var _ paramtypes.ParamSet = (*Params)(nil)

const (
        // Default values for wallet limits
        DefaultMaxParties       = uint32(5)
        DefaultMaxThreshold     = uint32(3)
        DefaultMaxSecurityLevel = uint32(3)
        DefaultMaxBatchSize     = uint32(100)
        DefaultMaxMetadataSize  = uint32(1024) // 1KB

        // Default values for recovery settings
        DefaultMaxWalletsPerDid     = uint32(5)
        DefaultMaxSharesPerWallet   = uint32(3)
        DefaultMinRecoveryThreshold = uint32(2)
        DefaultMaxRecoveryThreshold = uint32(3)
        DefaultRecoveryWindowSeconds = uint32(86400) // 24 hours
        DefaultMaxSigningAttempts    = uint32(3)
)

// Parameter store keys
var (
        // Wallet limit keys
        KeyMaxParties       = []byte("MaxParties")
        KeyMaxThreshold     = []byte("MaxThreshold")
        KeyMaxSecurityLevel = []byte("MaxSecurityLevel")
        KeyMaxBatchSize     = []byte("MaxBatchSize")
        KeyMaxMetadataSize  = []byte("MaxMetadataSize")

        // Recovery setting keys
        KeyMaxWalletsPerDid      = []byte("MaxWalletsPerDid")
        KeyMaxSharesPerWallet    = []byte("MaxSharesPerWallet")
        KeyMinRecoveryThreshold  = []byte("MinRecoveryThreshold")
        KeyMaxRecoveryThreshold  = []byte("MaxRecoveryThreshold")
        KeyRecoveryWindowSeconds = []byte("RecoveryWindowSeconds")
        KeyMaxSigningAttempts    = []byte("MaxSigningAttempts")
)

// ParamKeyTable the param key table for launch module
func ParamKeyTable() paramtypes.KeyTable <span class="cov0" title="0">{
        return paramtypes.NewKeyTable().RegisterParamSet(&amp;Params{})
}</span>

// DefaultParams returns a default set of parameters
func DefaultParams() Params <span class="cov8" title="1">{
        return Params{
                // Wallet limits
                MaxParties:       DefaultMaxParties,
                MaxThreshold:     DefaultMaxThreshold,
                MaxSecurityLevel: DefaultMaxSecurityLevel,
                MaxBatchSize:     DefaultMaxBatchSize,
                MaxMetadataSize:  DefaultMaxMetadataSize,

                // Recovery settings
                MaxWalletsPerDid:      DefaultMaxWalletsPerDid,
                MaxSharesPerWallet:    DefaultMaxSharesPerWallet,
                MinRecoveryThreshold:  DefaultMinRecoveryThreshold,
                MaxRecoveryThreshold:  DefaultMaxRecoveryThreshold,
                RecoveryWindowSeconds: DefaultRecoveryWindowSeconds,
                MaxSigningAttempts:    DefaultMaxSigningAttempts,
        }
}</span>

// NewParams creates a new Params instance
func NewParams(
        maxParties uint32,           // Wallet limit params
        maxThreshold uint32,
        maxSecurityLevel uint32,
        maxBatchSize uint32,
        maxMetadataSize uint32,
        maxWalletsPerDid uint32,     // Recovery params
        maxSharesPerWallet uint32,
        minRecoveryThreshold uint32,
        maxRecoveryThreshold uint32,
        recoveryWindowSeconds uint32,
        maxSigningAttempts uint32,
) Params <span class="cov0" title="0">{
        return Params{
                // Wallet limits
                MaxParties:       maxParties,
                MaxThreshold:     maxThreshold,
                MaxSecurityLevel: maxSecurityLevel,
                MaxBatchSize:     maxBatchSize,
                MaxMetadataSize:  maxMetadataSize,

                // Recovery settings
                MaxWalletsPerDid:      maxWalletsPerDid,
                MaxSharesPerWallet:    maxSharesPerWallet,
                MinRecoveryThreshold:  minRecoveryThreshold,
                MaxRecoveryThreshold:  maxRecoveryThreshold,
                RecoveryWindowSeconds: recoveryWindowSeconds,
                MaxSigningAttempts:    maxSigningAttempts,
        }
}</span>

// ParamSetPairs implements params.ParamSet
func (p *Params) ParamSetPairs() paramtypes.ParamSetPairs <span class="cov0" title="0">{
        return paramtypes.ParamSetPairs{
                paramtypes.NewParamSetPair(KeyMaxParties, &amp;p.MaxParties, validateUint32Param),
                paramtypes.NewParamSetPair(KeyMaxThreshold, &amp;p.MaxThreshold, validateUint32Param),
                paramtypes.NewParamSetPair(KeyMaxSecurityLevel, &amp;p.MaxSecurityLevel, validateUint32Param),
                paramtypes.NewParamSetPair(KeyMaxBatchSize, &amp;p.MaxBatchSize, validateUint32Param),
                paramtypes.NewParamSetPair(KeyMaxMetadataSize, &amp;p.MaxMetadataSize, validateUint32Param),
                paramtypes.NewParamSetPair(KeyMaxWalletsPerDid, &amp;p.MaxWalletsPerDid, validateUint32Param),
                paramtypes.NewParamSetPair(KeyMaxSharesPerWallet, &amp;p.MaxSharesPerWallet, validateUint32Param),
                paramtypes.NewParamSetPair(KeyMinRecoveryThreshold, &amp;p.MinRecoveryThreshold, validateUint32Param),
                paramtypes.NewParamSetPair(KeyMaxRecoveryThreshold, &amp;p.MaxRecoveryThreshold, validateUint32Param),
                paramtypes.NewParamSetPair(KeyRecoveryWindowSeconds, &amp;p.RecoveryWindowSeconds, validateUint32Param),
                paramtypes.NewParamSetPair(KeyMaxSigningAttempts, &amp;p.MaxSigningAttempts, validateUint32Param),
        }
}</span>

func validateUint32Param(i interface{}) error <span class="cov0" title="0">{
        v, ok := i.(uint32)
        if !ok </span><span class="cov0" title="0">{
                return ErrInvalidParam.Wrap("invalid parameter type: expected uint32")
        }</span>

        <span class="cov0" title="0">if v == 0 </span><span class="cov0" title="0">{
                return ErrInvalidParam.Wrap("parameter must be greater than 0")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Validate validates the set of params
func (p Params) Validate() error <span class="cov8" title="1">{
        // Validate wallet limits
        if p.MaxParties == 0 </span><span class="cov8" title="1">{
                return ErrInvalidParam.Wrap("MaxParties must be greater than 0")
        }</span>
        <span class="cov8" title="1">if p.MaxThreshold == 0 || p.MaxThreshold &gt; p.MaxParties </span><span class="cov8" title="1">{
                return ErrInvalidParam.Wrap("MaxThreshold must be greater than 0 and less than or equal to MaxParties")
        }</span>
        <span class="cov8" title="1">if p.MaxSecurityLevel == 0 </span><span class="cov0" title="0">{
                return ErrInvalidParam.Wrap("MaxSecurityLevel must be greater than 0")
        }</span>
        <span class="cov8" title="1">if p.MaxBatchSize == 0 </span><span class="cov0" title="0">{
                return ErrInvalidParam.Wrap("MaxBatchSize must be greater than 0")
        }</span>
        <span class="cov8" title="1">if p.MaxMetadataSize == 0 </span><span class="cov0" title="0">{
                return ErrInvalidParam.Wrap("MaxMetadataSize must be greater than 0")
        }</span>

        // Validate recovery settings
        <span class="cov8" title="1">if p.MaxWalletsPerDid == 0 </span><span class="cov0" title="0">{
                return ErrInvalidParam.Wrap("MaxWalletsPerDid must be greater than 0")
        }</span>
        <span class="cov8" title="1">if p.MaxSharesPerWallet == 0 </span><span class="cov0" title="0">{
                return ErrInvalidParam.Wrap("MaxSharesPerWallet must be greater than 0")
        }</span>
        <span class="cov8" title="1">if p.MinRecoveryThreshold == 0 || p.MinRecoveryThreshold &gt; p.MaxSharesPerWallet </span><span class="cov0" title="0">{
                return ErrInvalidParam.Wrap("MinRecoveryThreshold must be greater than 0 and less than or equal to MaxSharesPerWallet")
        }</span>
        <span class="cov8" title="1">if p.MaxRecoveryThreshold &lt; p.MinRecoveryThreshold || p.MaxRecoveryThreshold &gt; p.MaxSharesPerWallet </span><span class="cov0" title="0">{
                return ErrInvalidParam.Wrap("MaxRecoveryThreshold must be greater than or equal to MinRecoveryThreshold and less than or equal to MaxSharesPerWallet")
        }</span>
        <span class="cov8" title="1">if p.RecoveryWindowSeconds == 0 </span><span class="cov0" title="0">{
                return ErrInvalidParam.Wrap("RecoveryWindowSeconds must be greater than 0")
        }</span>
        <span class="cov8" title="1">if p.MaxSigningAttempts == 0 </span><span class="cov0" title="0">{
                return ErrInvalidParam.Wrap("MaxSigningAttempts must be greater than 0")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// String implements the Stringer interface.
func (p Params) String() string <span class="cov0" title="0">{
        out, _ := yaml.Marshal(p)
        return string(out)
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: selfchain/keyless/params.proto

package types

import (
        fmt "fmt"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params defines the parameters for the module.
type Params struct {
        // Wallet limits
        MaxParties       uint32 `protobuf:"varint,1,opt,name=max_parties,json=maxParties,proto3" json:"max_parties,omitempty" yaml:"max_parties"`
        MaxThreshold     uint32 `protobuf:"varint,2,opt,name=max_threshold,json=maxThreshold,proto3" json:"max_threshold,omitempty" yaml:"max_threshold"`
        MaxSecurityLevel uint32 `protobuf:"varint,3,opt,name=max_security_level,json=maxSecurityLevel,proto3" json:"max_security_level,omitempty" yaml:"max_security_level"`
        MaxBatchSize     uint32 `protobuf:"varint,4,opt,name=max_batch_size,json=maxBatchSize,proto3" json:"max_batch_size,omitempty" yaml:"max_batch_size"`
        MaxMetadataSize  uint32 `protobuf:"varint,5,opt,name=max_metadata_size,json=maxMetadataSize,proto3" json:"max_metadata_size,omitempty" yaml:"max_metadata_size"`
        // Recovery settings
        MaxWalletsPerDid      uint32 `protobuf:"varint,6,opt,name=max_wallets_per_did,json=maxWalletsPerDid,proto3" json:"max_wallets_per_did,omitempty" yaml:"max_wallets_per_did"`
        MaxSharesPerWallet    uint32 `protobuf:"varint,7,opt,name=max_shares_per_wallet,json=maxSharesPerWallet,proto3" json:"max_shares_per_wallet,omitempty" yaml:"max_shares_per_wallet"`
        MinRecoveryThreshold  uint32 `protobuf:"varint,8,opt,name=min_recovery_threshold,json=minRecoveryThreshold,proto3" json:"min_recovery_threshold,omitempty" yaml:"min_recovery_threshold"`
        MaxRecoveryThreshold  uint32 `protobuf:"varint,9,opt,name=max_recovery_threshold,json=maxRecoveryThreshold,proto3" json:"max_recovery_threshold,omitempty" yaml:"max_recovery_threshold"`
        RecoveryWindowSeconds uint32 `protobuf:"varint,10,opt,name=recovery_window_seconds,json=recoveryWindowSeconds,proto3" json:"recovery_window_seconds,omitempty" yaml:"recovery_window_seconds"`
        MaxSigningAttempts    uint32 `protobuf:"varint,11,opt,name=max_signing_attempts,json=maxSigningAttempts,proto3" json:"max_signing_attempts,omitempty" yaml:"max_signing_attempts"`
}

func (m *Params) Reset()      <span class="cov0" title="0">{ *m = Params{} }</span>
func (*Params) ProtoMessage() {<span class="cov0" title="0">}</span>
func (*Params) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_7a0ecc1f0b22d62f, []int{0}
}</span>
func (m *Params) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Params.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Params) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Params.Merge(m, src)
}</span>
func (m *Params) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Params) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Params.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetMaxParties() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MaxParties
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Params) GetMaxThreshold() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MaxThreshold
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Params) GetMaxSecurityLevel() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MaxSecurityLevel
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Params) GetMaxBatchSize() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MaxBatchSize
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Params) GetMaxMetadataSize() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MaxMetadataSize
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Params) GetMaxWalletsPerDid() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MaxWalletsPerDid
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Params) GetMaxSharesPerWallet() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MaxSharesPerWallet
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Params) GetMinRecoveryThreshold() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MinRecoveryThreshold
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Params) GetMaxRecoveryThreshold() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MaxRecoveryThreshold
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Params) GetRecoveryWindowSeconds() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.RecoveryWindowSeconds
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Params) GetMaxSigningAttempts() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MaxSigningAttempts
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*Params)(nil), "selfchain.keyless.Params")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("selfchain/keyless/params.proto", fileDescriptor_7a0ecc1f0b22d62f) }</span>

var fileDescriptor_7a0ecc1f0b22d62f = []byte{
        // 529 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x93, 0xc1, 0x6e, 0xd3, 0x30,
        0x18, 0xc7, 0x5b, 0x18, 0x05, 0x3c, 0x06, 0xcc, 0x74, 0x23, 0x1d, 0x5b, 0x3c, 0x72, 0xe2, 0xb4,
        0x1e, 0x76, 0x40, 0x9a, 0x84, 0x10, 0x15, 0x07, 0x24, 0x98, 0x54, 0x52, 0xa4, 0x4a, 0xbb, 0x44,
        0x5e, 0xf3, 0xd1, 0x5a, 0xc4, 0x49, 0x64, 0x9b, 0x35, 0xd9, 0x53, 0x70, 0xe4, 0xc8, 0xe3, 0x70,
        0xdc, 0x91, 0x53, 0x84, 0xda, 0x37, 0xc8, 0x13, 0x20, 0xdb, 0x59, 0xd3, 0x75, 0xe5, 0x56, 0xff,
        0xff, 0xbf, 0xef, 0xa7, 0xf6, 0x73, 0x8d, 0x5c, 0x09, 0xd1, 0xd7, 0xd1, 0x84, 0xb2, 0xb8, 0xfb,
        0x0d, 0xf2, 0x08, 0xa4, 0xec, 0xa6, 0x54, 0x50, 0x2e, 0x8f, 0x52, 0x91, 0xa8, 0x04, 0x6f, 0x2f,
        0xfa, 0xa3, 0xaa, 0xdf, 0x6b, 0x8f, 0x93, 0x71, 0x62, 0xda, 0xae, 0xfe, 0x64, 0x41, 0x6f, 0xde,
        0x42, 0xad, 0xbe, 0x99, 0xc4, 0xaf, 0xd1, 0x26, 0xa7, 0x59, 0x90, 0x52, 0xa1, 0x18, 0x48, 0xa7,
        0x79, 0xd8, 0x7c, 0xb5, 0xd5, 0xdb, 0x2d, 0x0b, 0x82, 0x73, 0xca, 0xa3, 0x13, 0x6f, 0xa9, 0xf4,
        0x7c, 0xc4, 0x69, 0xd6, 0xb7, 0x07, 0xfc, 0x06, 0x6d, 0xe9, 0x4e, 0x4d, 0x04, 0xc8, 0x49, 0x12,
        0x85, 0xce, 0x1d, 0x33, 0xea, 0x94, 0x05, 0x69, 0xd7, 0xa3, 0x8b, 0xda, 0xf3, 0x1f, 0x71, 0x9a,
        0x7d, 0xb9, 0x3e, 0xe2, 0x8f, 0x08, 0xeb, 0x5e, 0xc2, 0xe8, 0xbb, 0x60, 0x2a, 0x0f, 0x22, 0xb8,
        0x80, 0xc8, 0xb9, 0x6b, 0x1c, 0x07, 0x65, 0x41, 0x3a, 0xb5, 0xe3, 0x26, 0xe3, 0xf9, 0x4f, 0x39,
        0xcd, 0x06, 0x55, 0xf6, 0x49, 0x47, 0xf8, 0x2d, 0x7a, 0xac, 0xc1, 0x73, 0xaa, 0x46, 0x93, 0x40,
        0xb2, 0x4b, 0x70, 0x36, 0x8c, 0xa8, 0x53, 0x16, 0x64, 0xa7, 0x16, 0xd5, 0xbd, 0xfd, 0x36, 0x3d,
        0x7d, 0x1e, 0xb0, 0x4b, 0xc0, 0x1f, 0xd0, 0xb6, 0x06, 0x38, 0x28, 0x1a, 0x52, 0x45, 0xad, 0xe3,
        0x9e, 0x71, 0xec, 0x97, 0x05, 0x71, 0x6a, 0xc7, 0x0d, 0xc4, 0xf3, 0x9f, 0x70, 0x9a, 0x9d, 0x56,
        0x91, 0x31, 0x9d, 0xa2, 0x67, 0x1a, 0x9b, 0xd2, 0x28, 0x02, 0x25, 0x83, 0x14, 0x44, 0x10, 0xb2,
        0xd0, 0x69, 0x19, 0x97, 0x5b, 0x16, 0x64, 0xaf, 0x76, 0xad, 0x40, 0xf6, 0x97, 0x0d, 0x6d, 0xd8,
        0x07, 0xf1, 0x9e, 0x85, 0x78, 0x80, 0x76, 0xcc, 0x0a, 0x26, 0x54, 0x80, 0x05, 0xed, 0x90, 0x73,
        0xdf, 0x08, 0x0f, 0xcb, 0x82, 0xec, 0x2f, 0x6d, 0x6a, 0x15, 0xf3, 0x7c, 0xbd, 0xe5, 0x81, 0x89,
        0xfb, 0x20, 0xac, 0x1b, 0x0f, 0xd1, 0x2e, 0x67, 0x71, 0x20, 0x60, 0x94, 0x5c, 0x80, 0xc8, 0x97,
        0xee, 0xf0, 0x81, 0xb1, 0xbe, 0x2c, 0x0b, 0x72, 0x50, 0x59, 0xd7, 0x72, 0x9e, 0xdf, 0xe6, 0x2c,
        0xf6, 0xab, 0xbc, 0xbe, 0x54, 0x2d, 0xa6, 0xd9, 0x3a, 0xf1, 0xc3, 0x5b, 0xe2, 0xb5, 0x9c, 0x16,
        0xd3, 0xec, 0xb6, 0xf8, 0x0c, 0x3d, 0x5f, 0xc0, 0x53, 0x16, 0x87, 0xc9, 0x54, 0xff, 0x2b, 0x92,
        0x38, 0x94, 0x0e, 0x32, 0x66, 0xaf, 0x2c, 0x88, 0x6b, 0xcd, 0xff, 0x01, 0x3d, 0x7f, 0xe7, 0xba,
        0x19, 0x9a, 0x62, 0x60, 0x73, 0xfc, 0x19, 0xb5, 0xcd, 0xee, 0xd8, 0x38, 0x66, 0xf1, 0x38, 0xa0,
        0x4a, 0x01, 0x4f, 0x95, 0x74, 0x36, 0x8d, 0x98, 0x94, 0x05, 0x79, 0xb1, 0xb4, 0xe1, 0x15, 0xaa,
        0x5a, 0xb0, 0x4d, 0xdf, 0x55, 0xe1, 0xc9, 0xc6, 0xcf, 0x5f, 0xa4, 0xd1, 0x3b, 0xfe, 0x3d, 0x73,
        0x9b, 0x57, 0x33, 0xb7, 0xf9, 0x77, 0xe6, 0x36, 0x7f, 0xcc, 0xdd, 0xc6, 0xd5, 0xdc, 0x6d, 0xfc,
        0x99, 0xbb, 0x8d, 0xb3, 0x4e, 0xfd, 0x90, 0xb3, 0xc5, 0x53, 0x56, 0x79, 0x0a, 0xf2, 0xbc, 0x65,
        0x5e, 0xe8, 0xf1, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x47, 0xf3, 0x71, 0x71, 0xec, 0x03, 0x00,
        0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.MaxSigningAttempts != 0 </span><span class="cov0" title="0">{
                i = encodeVarintParams(dAtA, i, uint64(m.MaxSigningAttempts))
                i--
                dAtA[i] = 0x58
        }</span>
        <span class="cov0" title="0">if m.RecoveryWindowSeconds != 0 </span><span class="cov0" title="0">{
                i = encodeVarintParams(dAtA, i, uint64(m.RecoveryWindowSeconds))
                i--
                dAtA[i] = 0x50
        }</span>
        <span class="cov0" title="0">if m.MaxRecoveryThreshold != 0 </span><span class="cov0" title="0">{
                i = encodeVarintParams(dAtA, i, uint64(m.MaxRecoveryThreshold))
                i--
                dAtA[i] = 0x48
        }</span>
        <span class="cov0" title="0">if m.MinRecoveryThreshold != 0 </span><span class="cov0" title="0">{
                i = encodeVarintParams(dAtA, i, uint64(m.MinRecoveryThreshold))
                i--
                dAtA[i] = 0x40
        }</span>
        <span class="cov0" title="0">if m.MaxSharesPerWallet != 0 </span><span class="cov0" title="0">{
                i = encodeVarintParams(dAtA, i, uint64(m.MaxSharesPerWallet))
                i--
                dAtA[i] = 0x38
        }</span>
        <span class="cov0" title="0">if m.MaxWalletsPerDid != 0 </span><span class="cov0" title="0">{
                i = encodeVarintParams(dAtA, i, uint64(m.MaxWalletsPerDid))
                i--
                dAtA[i] = 0x30
        }</span>
        <span class="cov0" title="0">if m.MaxMetadataSize != 0 </span><span class="cov0" title="0">{
                i = encodeVarintParams(dAtA, i, uint64(m.MaxMetadataSize))
                i--
                dAtA[i] = 0x28
        }</span>
        <span class="cov0" title="0">if m.MaxBatchSize != 0 </span><span class="cov0" title="0">{
                i = encodeVarintParams(dAtA, i, uint64(m.MaxBatchSize))
                i--
                dAtA[i] = 0x20
        }</span>
        <span class="cov0" title="0">if m.MaxSecurityLevel != 0 </span><span class="cov0" title="0">{
                i = encodeVarintParams(dAtA, i, uint64(m.MaxSecurityLevel))
                i--
                dAtA[i] = 0x18
        }</span>
        <span class="cov0" title="0">if m.MaxThreshold != 0 </span><span class="cov0" title="0">{
                i = encodeVarintParams(dAtA, i, uint64(m.MaxThreshold))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if m.MaxParties != 0 </span><span class="cov0" title="0">{
                i = encodeVarintParams(dAtA, i, uint64(m.MaxParties))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintParams(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovParams(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *Params) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.MaxParties != 0 </span><span class="cov0" title="0">{
                n += 1 + sovParams(uint64(m.MaxParties))
        }</span>
        <span class="cov0" title="0">if m.MaxThreshold != 0 </span><span class="cov0" title="0">{
                n += 1 + sovParams(uint64(m.MaxThreshold))
        }</span>
        <span class="cov0" title="0">if m.MaxSecurityLevel != 0 </span><span class="cov0" title="0">{
                n += 1 + sovParams(uint64(m.MaxSecurityLevel))
        }</span>
        <span class="cov0" title="0">if m.MaxBatchSize != 0 </span><span class="cov0" title="0">{
                n += 1 + sovParams(uint64(m.MaxBatchSize))
        }</span>
        <span class="cov0" title="0">if m.MaxMetadataSize != 0 </span><span class="cov0" title="0">{
                n += 1 + sovParams(uint64(m.MaxMetadataSize))
        }</span>
        <span class="cov0" title="0">if m.MaxWalletsPerDid != 0 </span><span class="cov0" title="0">{
                n += 1 + sovParams(uint64(m.MaxWalletsPerDid))
        }</span>
        <span class="cov0" title="0">if m.MaxSharesPerWallet != 0 </span><span class="cov0" title="0">{
                n += 1 + sovParams(uint64(m.MaxSharesPerWallet))
        }</span>
        <span class="cov0" title="0">if m.MinRecoveryThreshold != 0 </span><span class="cov0" title="0">{
                n += 1 + sovParams(uint64(m.MinRecoveryThreshold))
        }</span>
        <span class="cov0" title="0">if m.MaxRecoveryThreshold != 0 </span><span class="cov0" title="0">{
                n += 1 + sovParams(uint64(m.MaxRecoveryThreshold))
        }</span>
        <span class="cov0" title="0">if m.RecoveryWindowSeconds != 0 </span><span class="cov0" title="0">{
                n += 1 + sovParams(uint64(m.RecoveryWindowSeconds))
        }</span>
        <span class="cov0" title="0">if m.MaxSigningAttempts != 0 </span><span class="cov0" title="0">{
                n += 1 + sovParams(uint64(m.MaxSigningAttempts))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovParams(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozParams(x uint64) (n int) <span class="cov0" title="0">{
        return sovParams(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *Params) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowParams
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Params: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field MaxParties", wireType)
                        }</span>
                        <span class="cov0" title="0">m.MaxParties = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.MaxParties |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field MaxThreshold", wireType)
                        }</span>
                        <span class="cov0" title="0">m.MaxThreshold = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.MaxThreshold |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 3:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field MaxSecurityLevel", wireType)
                        }</span>
                        <span class="cov0" title="0">m.MaxSecurityLevel = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.MaxSecurityLevel |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 4:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field MaxBatchSize", wireType)
                        }</span>
                        <span class="cov0" title="0">m.MaxBatchSize = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.MaxBatchSize |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 5:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field MaxMetadataSize", wireType)
                        }</span>
                        <span class="cov0" title="0">m.MaxMetadataSize = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.MaxMetadataSize |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 6:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field MaxWalletsPerDid", wireType)
                        }</span>
                        <span class="cov0" title="0">m.MaxWalletsPerDid = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.MaxWalletsPerDid |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 7:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field MaxSharesPerWallet", wireType)
                        }</span>
                        <span class="cov0" title="0">m.MaxSharesPerWallet = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.MaxSharesPerWallet |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 8:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field MinRecoveryThreshold", wireType)
                        }</span>
                        <span class="cov0" title="0">m.MinRecoveryThreshold = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.MinRecoveryThreshold |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 9:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field MaxRecoveryThreshold", wireType)
                        }</span>
                        <span class="cov0" title="0">m.MaxRecoveryThreshold = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.MaxRecoveryThreshold |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 10:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field RecoveryWindowSeconds", wireType)
                        }</span>
                        <span class="cov0" title="0">m.RecoveryWindowSeconds = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.RecoveryWindowSeconds |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 11:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field MaxSigningAttempts", wireType)
                        }</span>
                        <span class="cov0" title="0">m.MaxSigningAttempts = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.MaxSigningAttempts |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipParams(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipParams(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowParams
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupParams
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthParams
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthParams        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowParams          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupParams = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file51" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: selfchain/keyless/query.proto

package types

import (
        context "context"
        fmt "fmt"
        query "github.com/cosmos/cosmos-sdk/types/query"
        _ "github.com/cosmos/gogoproto/gogoproto"
        grpc1 "github.com/cosmos/gogoproto/grpc"
        proto "github.com/cosmos/gogoproto/proto"
        _ "google.golang.org/genproto/googleapis/api/annotations"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// QueryParamsRequest is request type for the Query/Params RPC method.
type QueryParamsRequest struct {
}

func (m *QueryParamsRequest) Reset()         <span class="cov0" title="0">{ *m = QueryParamsRequest{} }</span>
func (m *QueryParamsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryParamsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryParamsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_055fc6244ffb94fc, []int{0}
}</span>
func (m *QueryParamsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryParamsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryParamsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsRequest.Merge(m, src)
}</span>
func (m *QueryParamsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryParamsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryParamsRequest proto.InternalMessageInfo

// QueryParamsResponse is response type for the Query/Params RPC method.
type QueryParamsResponse struct {
        // params holds all the parameters of this module.
        Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
}

func (m *QueryParamsResponse) Reset()         <span class="cov0" title="0">{ *m = QueryParamsResponse{} }</span>
func (m *QueryParamsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryParamsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryParamsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_055fc6244ffb94fc, []int{1}
}</span>
func (m *QueryParamsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryParamsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryParamsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsResponse.Merge(m, src)
}</span>
func (m *QueryParamsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryParamsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryParamsResponse proto.InternalMessageInfo

func (m *QueryParamsResponse) GetParams() Params <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Params
        }</span>
        <span class="cov0" title="0">return Params{}</span>
}

// QueryWalletRequest is request type for the Query/Wallet RPC method.
type QueryWalletRequest struct {
        Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *QueryWalletRequest) Reset()         <span class="cov0" title="0">{ *m = QueryWalletRequest{} }</span>
func (m *QueryWalletRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryWalletRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryWalletRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_055fc6244ffb94fc, []int{2}
}</span>
func (m *QueryWalletRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryWalletRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryWalletRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryWalletRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryWalletRequest.Merge(m, src)
}</span>
func (m *QueryWalletRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryWalletRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryWalletRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryWalletRequest proto.InternalMessageInfo

func (m *QueryWalletRequest) GetAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Address
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// QueryWalletResponse is response type for the Query/Wallet RPC method.
type QueryWalletResponse struct {
        Wallet *Wallet `protobuf:"bytes,1,opt,name=wallet,proto3" json:"wallet,omitempty"`
}

func (m *QueryWalletResponse) Reset()         <span class="cov0" title="0">{ *m = QueryWalletResponse{} }</span>
func (m *QueryWalletResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryWalletResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryWalletResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_055fc6244ffb94fc, []int{3}
}</span>
func (m *QueryWalletResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryWalletResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryWalletResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryWalletResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryWalletResponse.Merge(m, src)
}</span>
func (m *QueryWalletResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryWalletResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryWalletResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryWalletResponse proto.InternalMessageInfo

func (m *QueryWalletResponse) GetWallet() *Wallet <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Wallet
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// QueryWalletsRequest is request type for the Query/Wallets RPC method.
type QueryWalletsRequest struct {
        Pagination *query.PageRequest `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryWalletsRequest) Reset()         <span class="cov0" title="0">{ *m = QueryWalletsRequest{} }</span>
func (m *QueryWalletsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryWalletsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryWalletsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_055fc6244ffb94fc, []int{4}
}</span>
func (m *QueryWalletsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryWalletsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryWalletsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryWalletsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryWalletsRequest.Merge(m, src)
}</span>
func (m *QueryWalletsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryWalletsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryWalletsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryWalletsRequest proto.InternalMessageInfo

func (m *QueryWalletsRequest) GetPagination() *query.PageRequest <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Pagination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// QueryWalletsResponse is response type for the Query/Wallets RPC method.
type QueryWalletsResponse struct {
        Wallets    []*Wallet           `protobuf:"bytes,1,rep,name=wallets,proto3" json:"wallets,omitempty"`
        Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryWalletsResponse) Reset()         <span class="cov0" title="0">{ *m = QueryWalletsResponse{} }</span>
func (m *QueryWalletsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryWalletsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryWalletsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_055fc6244ffb94fc, []int{5}
}</span>
func (m *QueryWalletsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryWalletsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryWalletsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryWalletsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryWalletsResponse.Merge(m, src)
}</span>
func (m *QueryWalletsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryWalletsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryWalletsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryWalletsResponse proto.InternalMessageInfo

func (m *QueryWalletsResponse) GetWallets() []*Wallet <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Wallets
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *QueryWalletsResponse) GetPagination() *query.PageResponse <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Pagination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// QueryPartyDataRequest is request type for the Query/PartyData RPC method.
type QueryPartyDataRequest struct {
        WalletAddress string `protobuf:"bytes,1,opt,name=wallet_address,json=walletAddress,proto3" json:"wallet_address,omitempty"`
}

func (m *QueryPartyDataRequest) Reset()         <span class="cov0" title="0">{ *m = QueryPartyDataRequest{} }</span>
func (m *QueryPartyDataRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryPartyDataRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryPartyDataRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_055fc6244ffb94fc, []int{6}
}</span>
func (m *QueryPartyDataRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryPartyDataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryPartyDataRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryPartyDataRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryPartyDataRequest.Merge(m, src)
}</span>
func (m *QueryPartyDataRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryPartyDataRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryPartyDataRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryPartyDataRequest proto.InternalMessageInfo

func (m *QueryPartyDataRequest) GetWalletAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WalletAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// QueryPartyDataResponse is response type for the Query/PartyData RPC method.
type QueryPartyDataResponse struct {
        WalletAddress string     `protobuf:"bytes,1,opt,name=wallet_address,json=walletAddress,proto3" json:"wallet_address,omitempty"`
        PartyData     *PartyData `protobuf:"bytes,2,opt,name=party_data,json=partyData,proto3" json:"party_data,omitempty"`
}

func (m *QueryPartyDataResponse) Reset()         <span class="cov0" title="0">{ *m = QueryPartyDataResponse{} }</span>
func (m *QueryPartyDataResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryPartyDataResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryPartyDataResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_055fc6244ffb94fc, []int{7}
}</span>
func (m *QueryPartyDataResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryPartyDataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryPartyDataResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryPartyDataResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryPartyDataResponse.Merge(m, src)
}</span>
func (m *QueryPartyDataResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryPartyDataResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryPartyDataResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryPartyDataResponse proto.InternalMessageInfo

func (m *QueryPartyDataResponse) GetWalletAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WalletAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *QueryPartyDataResponse) GetPartyData() *PartyData <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PartyData
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// QueryKeyRotationRequest is request type for the Query/KeyRotation RPC method.
type QueryKeyRotationRequest struct {
        WalletId string `protobuf:"bytes,1,opt,name=wallet_id,json=walletId,proto3" json:"wallet_id,omitempty"`
        Version  uint64 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *QueryKeyRotationRequest) Reset()         <span class="cov0" title="0">{ *m = QueryKeyRotationRequest{} }</span>
func (m *QueryKeyRotationRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryKeyRotationRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryKeyRotationRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_055fc6244ffb94fc, []int{8}
}</span>
func (m *QueryKeyRotationRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryKeyRotationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryKeyRotationRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryKeyRotationRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryKeyRotationRequest.Merge(m, src)
}</span>
func (m *QueryKeyRotationRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryKeyRotationRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryKeyRotationRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryKeyRotationRequest proto.InternalMessageInfo

func (m *QueryKeyRotationRequest) GetWalletId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WalletId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *QueryKeyRotationRequest) GetVersion() uint64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Version
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// QueryKeyRotationResponse is response type for the Query/KeyRotation RPC method.
type QueryKeyRotationResponse struct {
        Rotation *KeyRotation `protobuf:"bytes,1,opt,name=rotation,proto3" json:"rotation,omitempty"`
}

func (m *QueryKeyRotationResponse) Reset()         <span class="cov0" title="0">{ *m = QueryKeyRotationResponse{} }</span>
func (m *QueryKeyRotationResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryKeyRotationResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryKeyRotationResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_055fc6244ffb94fc, []int{9}
}</span>
func (m *QueryKeyRotationResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryKeyRotationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryKeyRotationResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryKeyRotationResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryKeyRotationResponse.Merge(m, src)
}</span>
func (m *QueryKeyRotationResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryKeyRotationResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryKeyRotationResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryKeyRotationResponse proto.InternalMessageInfo

func (m *QueryKeyRotationResponse) GetRotation() *KeyRotation <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Rotation
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// QueryKeyRotationsRequest is request type for the Query/KeyRotations RPC method.
type QueryKeyRotationsRequest struct {
        WalletId   string             `protobuf:"bytes,1,opt,name=wallet_id,json=walletId,proto3" json:"wallet_id,omitempty"`
        Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryKeyRotationsRequest) Reset()         <span class="cov0" title="0">{ *m = QueryKeyRotationsRequest{} }</span>
func (m *QueryKeyRotationsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryKeyRotationsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryKeyRotationsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_055fc6244ffb94fc, []int{10}
}</span>
func (m *QueryKeyRotationsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryKeyRotationsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryKeyRotationsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryKeyRotationsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryKeyRotationsRequest.Merge(m, src)
}</span>
func (m *QueryKeyRotationsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryKeyRotationsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryKeyRotationsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryKeyRotationsRequest proto.InternalMessageInfo

func (m *QueryKeyRotationsRequest) GetWalletId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WalletId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *QueryKeyRotationsRequest) GetPagination() *query.PageRequest <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Pagination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// QueryKeyRotationsResponse is response type for the Query/KeyRotations RPC method.
type QueryKeyRotationsResponse struct {
        Rotations  []*KeyRotation      `protobuf:"bytes,1,rep,name=rotations,proto3" json:"rotations,omitempty"`
        Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryKeyRotationsResponse) Reset()         <span class="cov0" title="0">{ *m = QueryKeyRotationsResponse{} }</span>
func (m *QueryKeyRotationsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryKeyRotationsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryKeyRotationsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_055fc6244ffb94fc, []int{11}
}</span>
func (m *QueryKeyRotationsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryKeyRotationsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryKeyRotationsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryKeyRotationsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryKeyRotationsResponse.Merge(m, src)
}</span>
func (m *QueryKeyRotationsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryKeyRotationsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryKeyRotationsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryKeyRotationsResponse proto.InternalMessageInfo

func (m *QueryKeyRotationsResponse) GetRotations() []*KeyRotation <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Rotations
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *QueryKeyRotationsResponse) GetPagination() *query.PageResponse <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Pagination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// QueryListAuditEventsRequest is request type for the Query/ListAuditEvents RPC method.
type QueryListAuditEventsRequest struct {
        WalletId   string             `protobuf:"bytes,1,opt,name=wallet_id,json=walletId,proto3" json:"wallet_id,omitempty"`
        EventType  string             `protobuf:"bytes,2,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
        Success    bool               `protobuf:"varint,3,opt,name=success,proto3" json:"success,omitempty"`
        Pagination *query.PageRequest `protobuf:"bytes,4,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryListAuditEventsRequest) Reset()         <span class="cov0" title="0">{ *m = QueryListAuditEventsRequest{} }</span>
func (m *QueryListAuditEventsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryListAuditEventsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryListAuditEventsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_055fc6244ffb94fc, []int{12}
}</span>
func (m *QueryListAuditEventsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryListAuditEventsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryListAuditEventsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryListAuditEventsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryListAuditEventsRequest.Merge(m, src)
}</span>
func (m *QueryListAuditEventsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryListAuditEventsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryListAuditEventsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryListAuditEventsRequest proto.InternalMessageInfo

func (m *QueryListAuditEventsRequest) GetWalletId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WalletId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *QueryListAuditEventsRequest) GetEventType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.EventType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *QueryListAuditEventsRequest) GetSuccess() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *QueryListAuditEventsRequest) GetPagination() *query.PageRequest <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Pagination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// QueryListAuditEventsResponse is response type for the Query/ListAuditEvents RPC method.
type QueryListAuditEventsResponse struct {
        Events     []*AuditEvent       `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
        Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryListAuditEventsResponse) Reset()         <span class="cov0" title="0">{ *m = QueryListAuditEventsResponse{} }</span>
func (m *QueryListAuditEventsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryListAuditEventsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryListAuditEventsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_055fc6244ffb94fc, []int{13}
}</span>
func (m *QueryListAuditEventsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryListAuditEventsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryListAuditEventsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryListAuditEventsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryListAuditEventsResponse.Merge(m, src)
}</span>
func (m *QueryListAuditEventsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryListAuditEventsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryListAuditEventsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryListAuditEventsResponse proto.InternalMessageInfo

func (m *QueryListAuditEventsResponse) GetEvents() []*AuditEvent <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Events
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *QueryListAuditEventsResponse) GetPagination() *query.PageResponse <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Pagination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*QueryParamsRequest)(nil), "selfchain.keyless.QueryParamsRequest")
        proto.RegisterType((*QueryParamsResponse)(nil), "selfchain.keyless.QueryParamsResponse")
        proto.RegisterType((*QueryWalletRequest)(nil), "selfchain.keyless.QueryWalletRequest")
        proto.RegisterType((*QueryWalletResponse)(nil), "selfchain.keyless.QueryWalletResponse")
        proto.RegisterType((*QueryWalletsRequest)(nil), "selfchain.keyless.QueryWalletsRequest")
        proto.RegisterType((*QueryWalletsResponse)(nil), "selfchain.keyless.QueryWalletsResponse")
        proto.RegisterType((*QueryPartyDataRequest)(nil), "selfchain.keyless.QueryPartyDataRequest")
        proto.RegisterType((*QueryPartyDataResponse)(nil), "selfchain.keyless.QueryPartyDataResponse")
        proto.RegisterType((*QueryKeyRotationRequest)(nil), "selfchain.keyless.QueryKeyRotationRequest")
        proto.RegisterType((*QueryKeyRotationResponse)(nil), "selfchain.keyless.QueryKeyRotationResponse")
        proto.RegisterType((*QueryKeyRotationsRequest)(nil), "selfchain.keyless.QueryKeyRotationsRequest")
        proto.RegisterType((*QueryKeyRotationsResponse)(nil), "selfchain.keyless.QueryKeyRotationsResponse")
        proto.RegisterType((*QueryListAuditEventsRequest)(nil), "selfchain.keyless.QueryListAuditEventsRequest")
        proto.RegisterType((*QueryListAuditEventsResponse)(nil), "selfchain.keyless.QueryListAuditEventsResponse")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("selfchain/keyless/query.proto", fileDescriptor_055fc6244ffb94fc) }</span>

var fileDescriptor_055fc6244ffb94fc = []byte{
        // 879 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x96, 0x4d, 0x6f, 0xe3, 0x44,
        0x18, 0xc7, 0x33, 0xbb, 0x25, 0x4d, 0x9e, 0xe5, 0x45, 0x0c, 0x05, 0x9a, 0x34, 0x35, 0xc5, 0xa8,
        0xbb, 0x65, 0xbb, 0x78, 0xe8, 0x06, 0xe8, 0xa1, 0x02, 0xd1, 0x0a, 0x0a, 0x08, 0x84, 0x8a, 0x85,
        0x84, 0x84, 0x40, 0xd1, 0x34, 0x19, 0x82, 0xd5, 0x34, 0x76, 0x33, 0x4e, 0xc1, 0x94, 0x80, 0x84,
        0xf8, 0x00, 0x48, 0x70, 0x80, 0x13, 0x17, 0x10, 0x7c, 0x07, 0xbe, 0x40, 0x8f, 0x95, 0xb8, 0x70,
        0x42, 0xa8, 0xe5, 0x83, 0xac, 0x3c, 0xf3, 0x4c, 0x12, 0x37, 0x76, 0x62, 0x55, 0xbd, 0xc5, 0x9e,
        0xe7, 0xe5, 0xf7, 0xbc, 0xe4, 0x3f, 0x86, 0x65, 0x29, 0x3a, 0x9f, 0x35, 0x3f, 0xe7, 0x5e, 0x97,
        0x1d, 0x88, 0xa8, 0x23, 0xa4, 0x64, 0x47, 0x7d, 0xd1, 0x8b, 0x9c, 0xa0, 0xe7, 0x87, 0x3e, 0x7d,
        0x7c, 0x78, 0xec, 0xe0, 0x71, 0x75, 0xa1, 0xed, 0xb7, 0x7d, 0x75, 0xca, 0xe2, 0x5f, 0xda, 0xb0,
        0x5a, 0x6b, 0xfb, 0x7e, 0xbb, 0x23, 0x18, 0x0f, 0x3c, 0xc6, 0xbb, 0x5d, 0x3f, 0xe4, 0xa1, 0xe7,
        0x77, 0x25, 0x9e, 0xde, 0x6d, 0xfa, 0xf2, 0xd0, 0x97, 0x6c, 0x9f, 0x4b, 0xa1, 0xe3, 0xb3, 0xe3,
        0x8d, 0x7d, 0x11, 0xf2, 0x0d, 0x16, 0xf0, 0xb6, 0xd7, 0x55, 0xc6, 0x68, 0x6b, 0x4d, 0x12, 0x05,
        0xbc, 0xc7, 0x0f, 0x65, 0xf6, 0xf9, 0x81, 0x88, 0xda, 0x62, 0x8a, 0xff, 0x17, 0xbc, 0xd3, 0x11,
        0x21, 0x9e, 0xaf, 0x4c, 0x9e, 0xf7, 0x10, 0x17, 0x2d, 0x52, 0x7a, 0xc2, 0xfb, 0x2d, 0x0f, 0x03,
        0xd8, 0x0b, 0x40, 0x3f, 0x88, 0x4b, 0xd8, 0x53, 0x54, 0xae, 0x38, 0xea, 0x0b, 0x19, 0xda, 0xef,
        0xc3, 0x13, 0x89, 0xb7, 0x32, 0xf0, 0xbb, 0x52, 0xd0, 0x4d, 0x28, 0x6a, 0xfa, 0x45, 0xb2, 0x42,
        0xd6, 0x6e, 0xdd, 0xaf, 0x38, 0x13, 0x1d, 0x75, 0xb4, 0xcb, 0xce, 0xdc, 0xe9, 0xbf, 0xcf, 0x14,
        0x5c, 0x34, 0xb7, 0x1d, 0xcc, 0xf2, 0x91, 0x62, 0xc7, 0x2c, 0x74, 0x11, 0xe6, 0x79, 0xab, 0xd5,
        0x13, 0x52, 0xc7, 0x2b, 0xbb, 0xe6, 0xd1, 0x7e, 0x1b, 0xf3, 0x1b, 0x7b, 0xcc, 0xbf, 0x01, 0x45,
        0x5d, 0xfd, 0x94, 0xfc, 0xe8, 0x82, 0x86, 0xf6, 0xa7, 0x89, 0x48, 0xa6, 0x40, 0xba, 0x0b, 0x30,
        0x9a, 0x15, 0x46, 0xbb, 0xed, 0xe8, 0xc1, 0x3a, 0xf1, 0x60, 0x1d, 0xbd, 0x38, 0x38, 0x58, 0x67,
        0x8f, 0xb7, 0x05, 0xfa, 0xba, 0x63, 0x9e, 0xf6, 0x4f, 0x04, 0x16, 0x92, 0xf1, 0x11, 0xb5, 0x0e,
        0xf3, 0x9a, 0x20, 0xae, 0xed, 0xe6, 0x74, 0x56, 0x63, 0x49, 0xdf, 0x4a, 0x50, 0xdd, 0x50, 0x54,
        0x77, 0x66, 0x52, 0xe9, 0x8c, 0x09, 0xac, 0xd7, 0xe0, 0x49, 0x33, 0xbf, 0x30, 0x7a, 0x83, 0x87,
        0xdc, 0xd4, 0xbd, 0x0a, 0x8f, 0xea, 0x64, 0x8d, 0x64, 0xe7, 0x1f, 0xd1, 0x6f, 0xb7, 0xb1, 0xff,
        0x5f, 0xc3, 0x53, 0x97, 0xfd, 0xb1, 0xae, 0x7c, 0x01, 0xe8, 0x56, 0x5c, 0x49, 0x2f, 0x8c, 0x1a,
        0x2d, 0x1e, 0x72, 0xac, 0xa4, 0x96, 0xbe, 0x2d, 0x98, 0xa0, 0x1c, 0x98, 0x9f, 0xf6, 0x1e, 0x3c,
        0xad, 0xb2, 0xbf, 0x2b, 0x22, 0x17, 0x97, 0xd9, 0xf0, 0x2f, 0x41, 0x19, 0xd3, 0x7b, 0x2d, 0xcc,
        0x5c, 0xd2, 0x2f, 0xde, 0x69, 0xc5, 0xfb, 0x74, 0x2c, 0x7a, 0xd2, 0xf4, 0x6e, 0xce, 0x35, 0x8f,
        0xf6, 0x27, 0xb0, 0x38, 0x19, 0x11, 0x2b, 0x7a, 0x1d, 0x4a, 0xe6, 0x2f, 0x83, 0x8b, 0x60, 0xa5,
        0x80, 0x8e, 0x79, 0xaa, 0xdd, 0x26, 0xee, 0xd0, 0xcb, 0xfe, 0x76, 0x32, 0xba, 0xcc, 0x05, 0xbc,
        0x9b, 0x32, 0xef, 0xab, 0x6c, 0xe1, 0x9f, 0x04, 0x2a, 0x29, 0x04, 0x58, 0xe0, 0x0e, 0x94, 0x0d,
        0xaa, 0x59, 0xc6, 0x7c, 0x15, 0x8e, 0xdc, 0xae, 0x6f, 0x33, 0xff, 0x22, 0xb0, 0xa4, 0x50, 0xdf,
        0xf3, 0x64, 0xb8, 0x1d, 0x0b, 0xd1, 0x9b, 0xc7, 0xa2, 0x1b, 0xe6, 0xeb, 0xd7, 0x32, 0x80, 0x88,
        0xad, 0x1b, 0x61, 0x14, 0x08, 0x45, 0x51, 0x76, 0xcb, 0xea, 0xcd, 0x87, 0x51, 0x20, 0xe2, 0xf9,
        0xcb, 0x7e, 0xb3, 0x19, 0x2f, 0xe5, 0xcd, 0x15, 0xb2, 0x56, 0x72, 0xcd, 0xe3, 0xa5, 0x46, 0xcf,
        0x5d, 0xb9, 0xd1, 0xbf, 0x11, 0xa8, 0xa5, 0xd3, 0x63, 0xaf, 0xb7, 0xa0, 0xa8, 0x78, 0x4c, 0xa3,
        0x97, 0x53, 0x1a, 0x3d, 0xf2, 0xc3, 0x3e, 0xa3, 0xcb, 0xb5, 0x35, 0xf9, 0xfe, 0x2f, 0x25, 0x78,
        0x48, 0x61, 0xd2, 0xaf, 0xa0, 0xa8, 0x05, 0x99, 0xae, 0xa6, 0x90, 0x4c, 0x2a, 0x7f, 0xf5, 0xf6,
        0x2c, 0x33, 0x9d, 0xce, 0x7e, 0xf6, 0xbb, 0xbf, 0xff, 0xff, 0xf1, 0xc6, 0x12, 0xad, 0xb0, 0xac,
        0x1b, 0x8e, 0x7e, 0x4f, 0xa0, 0xa8, 0x15, 0x2e, 0x3b, 0x79, 0xe2, 0x42, 0xc8, 0x4e, 0x9e, 0xbc,
        0x07, 0xec, 0x75, 0x95, 0x7c, 0x95, 0x3e, 0xc7, 0xb2, 0xae, 0x47, 0x76, 0x82, 0xf2, 0x34, 0xa0,
        0xdf, 0xc0, 0x3c, 0x8a, 0x33, 0x9d, 0x11, 0x7f, 0xd8, 0x84, 0x3b, 0x33, 0xed, 0x10, 0xc4, 0x56,
        0x20, 0x35, 0x5a, 0xcd, 0x04, 0x91, 0xf4, 0x67, 0x02, 0xe5, 0xa1, 0xcc, 0xd1, 0xb5, 0x29, 0xfd,
        0x4d, 0x48, 0x75, 0xf5, 0xf9, 0x1c, 0x96, 0x88, 0xf1, 0x8a, 0xc2, 0x78, 0x91, 0x3a, 0xe9, 0xc3,
        0x40, 0x19, 0x66, 0x27, 0x49, 0xe5, 0x1e, 0xd0, 0xdf, 0x09, 0xdc, 0x1a, 0xfb, 0xdb, 0xd3, 0xbb,
        0x59, 0x29, 0x27, 0x95, 0xb8, 0xba, 0x9e, 0xcb, 0x16, 0x01, 0x5f, 0x55, 0x80, 0x9b, 0xf4, 0x65,
        0x96, 0xfa, 0xbd, 0xd3, 0x30, 0x42, 0x33, 0x44, 0xf4, 0x5a, 0x03, 0x76, 0x82, 0xea, 0x3d, 0xa0,
        0xbf, 0x12, 0x78, 0x78, 0x5c, 0xda, 0x68, 0x9e, 0xe4, 0xc3, 0x69, 0xde, 0xcb, 0x67, 0x8c, 0xa8,
        0x2f, 0x29, 0x54, 0x87, 0xde, 0x9b, 0x81, 0x2a, 0xc7, 0x59, 0xe9, 0x1f, 0x04, 0x1e, 0xbb, 0xa4,
        0x09, 0xd4, 0xc9, 0xca, 0x9b, 0x2e, 0x7d, 0x55, 0x96, 0xdb, 0x1e, 0x51, 0xeb, 0x0a, 0xf5, 0x05,
        0xba, 0xce, 0x32, 0xbe, 0xf1, 0x1a, 0x5a, 0x58, 0xc6, 0x49, 0x77, 0xea, 0xa7, 0xe7, 0x16, 0x39,
        0x3b, 0xb7, 0xc8, 0x7f, 0xe7, 0x16, 0xf9, 0xe1, 0xc2, 0x2a, 0x9c, 0x5d, 0x58, 0x85, 0x7f, 0x2e,
        0xac, 0xc2, 0xc7, 0x95, 0x51, 0x94, 0x2f, 0x87, 0x71, 0x62, 0xa5, 0x95, 0xfb, 0x45, 0xf5, 0xb1,
        0x58, 0x7f, 0x10, 0x00, 0x00, 0xff, 0xff, 0x9a, 0xf1, 0x65, 0x79, 0x61, 0x0b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
        // Parameters queries the parameters of the module.
        Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error)
        // Wallet queries a wallet by address
        Wallet(ctx context.Context, in *QueryWalletRequest, opts ...grpc.CallOption) (*QueryWalletResponse, error)
        // Wallets queries all wallets
        Wallets(ctx context.Context, in *QueryWalletsRequest, opts ...grpc.CallOption) (*QueryWalletsResponse, error)
        // PartyData queries TSS party data for a wallet
        PartyData(ctx context.Context, in *QueryPartyDataRequest, opts ...grpc.CallOption) (*QueryPartyDataResponse, error)
        // KeyRotation queries a specific key rotation by wallet ID and version
        KeyRotation(ctx context.Context, in *QueryKeyRotationRequest, opts ...grpc.CallOption) (*QueryKeyRotationResponse, error)
        // KeyRotations queries all key rotations for a wallet
        KeyRotations(ctx context.Context, in *QueryKeyRotationsRequest, opts ...grpc.CallOption) (*QueryKeyRotationsResponse, error)
        // ListAuditEvents queries audit events for a wallet with filtering
        ListAuditEvents(ctx context.Context, in *QueryListAuditEventsRequest, opts ...grpc.CallOption) (*QueryListAuditEventsResponse, error)
}

type queryClient struct {
        cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient <span class="cov0" title="0">{
        return &amp;queryClient{cc}
}</span>

func (c *queryClient) Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error) <span class="cov0" title="0">{
        out := new(QueryParamsResponse)
        err := c.cc.Invoke(ctx, "/selfchain.keyless.Query/Params", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) Wallet(ctx context.Context, in *QueryWalletRequest, opts ...grpc.CallOption) (*QueryWalletResponse, error) <span class="cov0" title="0">{
        out := new(QueryWalletResponse)
        err := c.cc.Invoke(ctx, "/selfchain.keyless.Query/Wallet", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) Wallets(ctx context.Context, in *QueryWalletsRequest, opts ...grpc.CallOption) (*QueryWalletsResponse, error) <span class="cov0" title="0">{
        out := new(QueryWalletsResponse)
        err := c.cc.Invoke(ctx, "/selfchain.keyless.Query/Wallets", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) PartyData(ctx context.Context, in *QueryPartyDataRequest, opts ...grpc.CallOption) (*QueryPartyDataResponse, error) <span class="cov0" title="0">{
        out := new(QueryPartyDataResponse)
        err := c.cc.Invoke(ctx, "/selfchain.keyless.Query/PartyData", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) KeyRotation(ctx context.Context, in *QueryKeyRotationRequest, opts ...grpc.CallOption) (*QueryKeyRotationResponse, error) <span class="cov0" title="0">{
        out := new(QueryKeyRotationResponse)
        err := c.cc.Invoke(ctx, "/selfchain.keyless.Query/KeyRotation", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) KeyRotations(ctx context.Context, in *QueryKeyRotationsRequest, opts ...grpc.CallOption) (*QueryKeyRotationsResponse, error) <span class="cov0" title="0">{
        out := new(QueryKeyRotationsResponse)
        err := c.cc.Invoke(ctx, "/selfchain.keyless.Query/KeyRotations", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) ListAuditEvents(ctx context.Context, in *QueryListAuditEventsRequest, opts ...grpc.CallOption) (*QueryListAuditEventsResponse, error) <span class="cov0" title="0">{
        out := new(QueryListAuditEventsResponse)
        err := c.cc.Invoke(ctx, "/selfchain.keyless.Query/ListAuditEvents", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// QueryServer is the server API for Query service.
type QueryServer interface {
        // Parameters queries the parameters of the module.
        Params(context.Context, *QueryParamsRequest) (*QueryParamsResponse, error)
        // Wallet queries a wallet by address
        Wallet(context.Context, *QueryWalletRequest) (*QueryWalletResponse, error)
        // Wallets queries all wallets
        Wallets(context.Context, *QueryWalletsRequest) (*QueryWalletsResponse, error)
        // PartyData queries TSS party data for a wallet
        PartyData(context.Context, *QueryPartyDataRequest) (*QueryPartyDataResponse, error)
        // KeyRotation queries a specific key rotation by wallet ID and version
        KeyRotation(context.Context, *QueryKeyRotationRequest) (*QueryKeyRotationResponse, error)
        // KeyRotations queries all key rotations for a wallet
        KeyRotations(context.Context, *QueryKeyRotationsRequest) (*QueryKeyRotationsResponse, error)
        // ListAuditEvents queries audit events for a wallet with filtering
        ListAuditEvents(context.Context, *QueryListAuditEventsRequest) (*QueryListAuditEventsResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) Params(ctx context.Context, req *QueryParamsRequest) (*QueryParamsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Params not implemented")
}</span>
func (*UnimplementedQueryServer) Wallet(ctx context.Context, req *QueryWalletRequest) (*QueryWalletResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Wallet not implemented")
}</span>
func (*UnimplementedQueryServer) Wallets(ctx context.Context, req *QueryWalletsRequest) (*QueryWalletsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Wallets not implemented")
}</span>
func (*UnimplementedQueryServer) PartyData(ctx context.Context, req *QueryPartyDataRequest) (*QueryPartyDataResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method PartyData not implemented")
}</span>
func (*UnimplementedQueryServer) KeyRotation(ctx context.Context, req *QueryKeyRotationRequest) (*QueryKeyRotationResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method KeyRotation not implemented")
}</span>
func (*UnimplementedQueryServer) KeyRotations(ctx context.Context, req *QueryKeyRotationsRequest) (*QueryKeyRotationsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method KeyRotations not implemented")
}</span>
func (*UnimplementedQueryServer) ListAuditEvents(ctx context.Context, req *QueryListAuditEventsRequest) (*QueryListAuditEventsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListAuditEvents not implemented")
}</span>

func RegisterQueryServer(s grpc1.Server, srv QueryServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;_Query_serviceDesc, srv)
}</span>

func _Query_Params_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryParamsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).Params(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/selfchain.keyless.Query/Params",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).Params(ctx, req.(*QueryParamsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_Wallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryWalletRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).Wallet(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/selfchain.keyless.Query/Wallet",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).Wallet(ctx, req.(*QueryWalletRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_Wallets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryWalletsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).Wallets(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/selfchain.keyless.Query/Wallets",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).Wallets(ctx, req.(*QueryWalletsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_PartyData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryPartyDataRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).PartyData(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/selfchain.keyless.Query/PartyData",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).PartyData(ctx, req.(*QueryPartyDataRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_KeyRotation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryKeyRotationRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).KeyRotation(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/selfchain.keyless.Query/KeyRotation",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).KeyRotation(ctx, req.(*QueryKeyRotationRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_KeyRotations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryKeyRotationsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).KeyRotations(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/selfchain.keyless.Query/KeyRotations",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).KeyRotations(ctx, req.(*QueryKeyRotationsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_ListAuditEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryListAuditEventsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).ListAuditEvents(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/selfchain.keyless.Query/ListAuditEvents",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).ListAuditEvents(ctx, req.(*QueryListAuditEventsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

var _Query_serviceDesc = grpc.ServiceDesc{
        ServiceName: "selfchain.keyless.Query",
        HandlerType: (*QueryServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Params",
                        Handler:    _Query_Params_Handler,
                },
                {
                        MethodName: "Wallet",
                        Handler:    _Query_Wallet_Handler,
                },
                {
                        MethodName: "Wallets",
                        Handler:    _Query_Wallets_Handler,
                },
                {
                        MethodName: "PartyData",
                        Handler:    _Query_PartyData_Handler,
                },
                {
                        MethodName: "KeyRotation",
                        Handler:    _Query_KeyRotation_Handler,
                },
                {
                        MethodName: "KeyRotations",
                        Handler:    _Query_KeyRotations_Handler,
                },
                {
                        MethodName: "ListAuditEvents",
                        Handler:    _Query_ListAuditEvents_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "selfchain/keyless/query.proto",
}

func (m *QueryParamsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryParamsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryParamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *QueryParamsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryParamsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func (m *QueryWalletRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryWalletRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryWalletRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Address) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Address)
                copy(dAtA[i:], m.Address)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryWalletResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryWalletResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryWalletResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Wallet != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Wallet.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryWalletsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryWalletsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryWalletsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Pagination != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryWalletsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryWalletsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryWalletsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Pagination != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0x12</span>
        }
        <span class="cov0" title="0">if len(m.Wallets) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Wallets) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Wallets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryPartyDataRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryPartyDataRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryPartyDataRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.WalletAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.WalletAddress)
                copy(dAtA[i:], m.WalletAddress)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.WalletAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryPartyDataResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryPartyDataResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryPartyDataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.PartyData != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.PartyData.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0x12</span>
        }
        <span class="cov0" title="0">if len(m.WalletAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.WalletAddress)
                copy(dAtA[i:], m.WalletAddress)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.WalletAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryKeyRotationRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryKeyRotationRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryKeyRotationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Version != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuery(dAtA, i, uint64(m.Version))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.WalletId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.WalletId)
                copy(dAtA[i:], m.WalletId)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.WalletId)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryKeyRotationResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryKeyRotationResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryKeyRotationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Rotation != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Rotation.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryKeyRotationsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryKeyRotationsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryKeyRotationsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Pagination != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0x12</span>
        }
        <span class="cov0" title="0">if len(m.WalletId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.WalletId)
                copy(dAtA[i:], m.WalletId)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.WalletId)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryKeyRotationsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryKeyRotationsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryKeyRotationsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Pagination != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0x12</span>
        }
        <span class="cov0" title="0">if len(m.Rotations) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Rotations) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Rotations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryListAuditEventsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryListAuditEventsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryListAuditEventsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Pagination != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0x22</span>
        }
        <span class="cov0" title="0">if m.Success </span><span class="cov0" title="0">{
                i--
                if m.Success </span><span class="cov0" title="0">{
                        dAtA[i] = 1
                }</span> else<span class="cov0" title="0"> {
                        dAtA[i] = 0
                }</span>
                <span class="cov0" title="0">i--
                dAtA[i] = 0x18</span>
        }
        <span class="cov0" title="0">if len(m.EventType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.EventType)
                copy(dAtA[i:], m.EventType)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.EventType)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.WalletId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.WalletId)
                copy(dAtA[i:], m.WalletId)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.WalletId)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryListAuditEventsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryListAuditEventsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryListAuditEventsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Pagination != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0x12</span>
        }
        <span class="cov0" title="0">if len(m.Events) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Events) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovQuery(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *QueryParamsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *QueryParamsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Params.Size()
        n += 1 + l + sovQuery(uint64(l))
        return n</span>
}

func (m *QueryWalletRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Address)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryWalletResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Wallet != nil </span><span class="cov0" title="0">{
                l = m.Wallet.Size()
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryWalletsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Pagination != nil </span><span class="cov0" title="0">{
                l = m.Pagination.Size()
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryWalletsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Wallets) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Wallets </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovQuery(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">if m.Pagination != nil </span><span class="cov0" title="0">{
                l = m.Pagination.Size()
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryPartyDataRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.WalletAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryPartyDataResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.WalletAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.PartyData != nil </span><span class="cov0" title="0">{
                l = m.PartyData.Size()
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryKeyRotationRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.WalletId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Version != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuery(uint64(m.Version))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryKeyRotationResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Rotation != nil </span><span class="cov0" title="0">{
                l = m.Rotation.Size()
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryKeyRotationsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.WalletId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Pagination != nil </span><span class="cov0" title="0">{
                l = m.Pagination.Size()
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryKeyRotationsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Rotations) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Rotations </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovQuery(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">if m.Pagination != nil </span><span class="cov0" title="0">{
                l = m.Pagination.Size()
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryListAuditEventsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.WalletId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.EventType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Success </span><span class="cov0" title="0">{
                n += 2
        }</span>
        <span class="cov0" title="0">if m.Pagination != nil </span><span class="cov0" title="0">{
                l = m.Pagination.Size()
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryListAuditEventsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Events) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Events </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovQuery(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">if m.Pagination != nil </span><span class="cov0" title="0">{
                l = m.Pagination.Size()
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovQuery(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozQuery(x uint64) (n int) <span class="cov0" title="0">{
        return sovQuery(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *QueryParamsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryParamsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryWalletRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryWalletRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryWalletRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Address = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryWalletResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryWalletResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryWalletResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Wallet", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Wallet == nil </span><span class="cov0" title="0">{
                                m.Wallet = &amp;Wallet{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Wallet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryWalletsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryWalletsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryWalletsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Pagination == nil </span><span class="cov0" title="0">{
                                m.Pagination = &amp;query.PageRequest{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryWalletsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryWalletsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryWalletsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Wallets", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Wallets = append(m.Wallets, &amp;Wallet{})
                        if err := m.Wallets[len(m.Wallets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Pagination == nil </span><span class="cov0" title="0">{
                                m.Pagination = &amp;query.PageResponse{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryPartyDataRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryPartyDataRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryPartyDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WalletAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.WalletAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryPartyDataResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryPartyDataResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryPartyDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WalletAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.WalletAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PartyData", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.PartyData == nil </span><span class="cov0" title="0">{
                                m.PartyData = &amp;PartyData{}
                        }</span>
                        <span class="cov0" title="0">if err := m.PartyData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryKeyRotationRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryKeyRotationRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryKeyRotationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WalletId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.WalletId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Version = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Version |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryKeyRotationResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryKeyRotationResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryKeyRotationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Rotation", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Rotation == nil </span><span class="cov0" title="0">{
                                m.Rotation = &amp;KeyRotation{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Rotation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryKeyRotationsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryKeyRotationsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryKeyRotationsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WalletId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.WalletId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Pagination == nil </span><span class="cov0" title="0">{
                                m.Pagination = &amp;query.PageRequest{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryKeyRotationsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryKeyRotationsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryKeyRotationsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Rotations", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Rotations = append(m.Rotations, &amp;KeyRotation{})
                        if err := m.Rotations[len(m.Rotations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Pagination == nil </span><span class="cov0" title="0">{
                                m.Pagination = &amp;query.PageResponse{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryListAuditEventsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryListAuditEventsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryListAuditEventsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WalletId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.WalletId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.EventType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
                        }</span>
                        <span class="cov0" title="0">var v int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                v |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">m.Success = bool(v != 0)</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Pagination == nil </span><span class="cov0" title="0">{
                                m.Pagination = &amp;query.PageRequest{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryListAuditEventsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryListAuditEventsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryListAuditEventsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Events = append(m.Events, &amp;AuditEvent{})
                        if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Pagination == nil </span><span class="cov0" title="0">{
                                m.Pagination = &amp;query.PageResponse{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipQuery(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupQuery
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthQuery
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file52" style="display: none">// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: selfchain/keyless/query.proto

/*
Package types is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
package types

import (
        "context"
        "io"
        "net/http"

        "github.com/golang/protobuf/descriptor"
        "github.com/golang/protobuf/proto"
        "github.com/grpc-ecosystem/grpc-gateway/runtime"
        "github.com/grpc-ecosystem/grpc-gateway/utilities"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/grpclog"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// Suppress "imported and not used" errors
var _ codes.Code
var _ io.Reader
var _ status.Status
var _ = runtime.String
var _ = utilities.NewDoubleArray
var _ = descriptor.ForMessage
var _ = metadata.Join

func request_Query_Params_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryParamsRequest
        var metadata runtime.ServerMetadata

        msg, err := client.Params(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err

}</span>

func local_request_Query_Params_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryParamsRequest
        var metadata runtime.ServerMetadata

        msg, err := server.Params(ctx, &amp;protoReq)
        return msg, metadata, err

}</span>

func request_Query_Wallet_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryWalletRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["address"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "address")
        }</span>

        <span class="cov0" title="0">protoReq.Address, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "address", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.Wallet(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_Wallet_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryWalletRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["address"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "address")
        }</span>

        <span class="cov0" title="0">protoReq.Address, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "address", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.Wallet(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

var (
        filter_Query_Wallets_0 = &amp;utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}
)

func request_Query_Wallets_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryWalletsRequest
        var metadata runtime.ServerMetadata

        if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_Query_Wallets_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.Wallets(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_Wallets_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryWalletsRequest
        var metadata runtime.ServerMetadata

        if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_Query_Wallets_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.Wallets(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_PartyData_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryPartyDataRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["wallet_address"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "wallet_address")
        }</span>

        <span class="cov0" title="0">protoReq.WalletAddress, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "wallet_address", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.PartyData(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_PartyData_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryPartyDataRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["wallet_address"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "wallet_address")
        }</span>

        <span class="cov0" title="0">protoReq.WalletAddress, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "wallet_address", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.PartyData(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_KeyRotation_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryKeyRotationRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["wallet_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "wallet_id")
        }</span>

        <span class="cov0" title="0">protoReq.WalletId, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "wallet_id", err)
        }</span>

        <span class="cov0" title="0">val, ok = pathParams["version"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "version")
        }</span>

        <span class="cov0" title="0">protoReq.Version, err = runtime.Uint64(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "version", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.KeyRotation(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_KeyRotation_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryKeyRotationRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["wallet_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "wallet_id")
        }</span>

        <span class="cov0" title="0">protoReq.WalletId, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "wallet_id", err)
        }</span>

        <span class="cov0" title="0">val, ok = pathParams["version"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "version")
        }</span>

        <span class="cov0" title="0">protoReq.Version, err = runtime.Uint64(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "version", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.KeyRotation(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

var (
        filter_Query_KeyRotations_0 = &amp;utilities.DoubleArray{Encoding: map[string]int{"wallet_id": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_Query_KeyRotations_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryKeyRotationsRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["wallet_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "wallet_id")
        }</span>

        <span class="cov0" title="0">protoReq.WalletId, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "wallet_id", err)
        }</span>

        <span class="cov0" title="0">if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_Query_KeyRotations_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.KeyRotations(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_KeyRotations_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryKeyRotationsRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["wallet_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "wallet_id")
        }</span>

        <span class="cov0" title="0">protoReq.WalletId, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "wallet_id", err)
        }</span>

        <span class="cov0" title="0">if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_Query_KeyRotations_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.KeyRotations(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

var (
        filter_Query_ListAuditEvents_0 = &amp;utilities.DoubleArray{Encoding: map[string]int{"wallet_id": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_Query_ListAuditEvents_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryListAuditEventsRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["wallet_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "wallet_id")
        }</span>

        <span class="cov0" title="0">protoReq.WalletId, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "wallet_id", err)
        }</span>

        <span class="cov0" title="0">if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_Query_ListAuditEvents_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.ListAuditEvents(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_ListAuditEvents_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryListAuditEventsRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["wallet_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "wallet_id")
        }</span>

        <span class="cov0" title="0">protoReq.WalletId, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "wallet_id", err)
        }</span>

        <span class="cov0" title="0">if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_Query_ListAuditEvents_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.ListAuditEvents(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

// RegisterQueryHandlerServer registers the http handlers for service Query to "mux".
// UnaryRPC     :call QueryServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterQueryHandlerFromEndpoint instead.
func RegisterQueryHandlerServer(ctx context.Context, mux *runtime.ServeMux, server QueryServer) error <span class="cov0" title="0">{

        mux.Handle("GET", pattern_Query_Params_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_Params_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_Params_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_Wallet_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_Wallet_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_Wallet_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_Wallets_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_Wallets_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_Wallets_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_PartyData_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_PartyData_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_PartyData_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_KeyRotation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_KeyRotation_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_KeyRotation_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_KeyRotations_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_KeyRotations_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_KeyRotations_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_ListAuditEvents_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_ListAuditEvents_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_ListAuditEvents_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">return nil</span>
}

// RegisterQueryHandlerFromEndpoint is same as RegisterQueryHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterQueryHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) <span class="cov0" title="0">{
        conn, err := grpc.Dial(endpoint, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                }()
        }()

        <span class="cov0" title="0">return RegisterQueryHandler(ctx, mux, conn)</span>
}

// RegisterQueryHandler registers the http handlers for service Query to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterQueryHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error <span class="cov0" title="0">{
        return RegisterQueryHandlerClient(ctx, mux, NewQueryClient(conn))
}</span>

// RegisterQueryHandlerClient registers the http handlers for service Query
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "QueryClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "QueryClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "QueryClient" to call the correct interceptors.
func RegisterQueryHandlerClient(ctx context.Context, mux *runtime.ServeMux, client QueryClient) error <span class="cov0" title="0">{

        mux.Handle("GET", pattern_Query_Params_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_Params_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_Params_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_Wallet_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_Wallet_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_Wallet_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_Wallets_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_Wallets_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_Wallets_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_PartyData_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_PartyData_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_PartyData_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_KeyRotation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_KeyRotation_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_KeyRotation_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_KeyRotations_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_KeyRotations_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_KeyRotations_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_ListAuditEvents_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_ListAuditEvents_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_ListAuditEvents_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">return nil</span>
}

var (
        pattern_Query_Params_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"selfchain", "keyless", "params"}, "", runtime.AssumeColonVerbOpt(true)))

        pattern_Query_Wallet_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"selfchain", "keyless", "wallet", "address"}, "", runtime.AssumeColonVerbOpt(true)))

        pattern_Query_Wallets_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"selfchain", "keyless", "wallets"}, "", runtime.AssumeColonVerbOpt(true)))

        pattern_Query_PartyData_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"selfchain", "keyless", "party_data", "wallet_address"}, "", runtime.AssumeColonVerbOpt(true)))

        pattern_Query_KeyRotation_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 1, 0, 4, 1, 5, 4}, []string{"selfchain", "keyless", "key_rotation", "wallet_id", "version"}, "", runtime.AssumeColonVerbOpt(true)))

        pattern_Query_KeyRotations_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"selfchain", "keyless", "key_rotations", "wallet_id"}, "", runtime.AssumeColonVerbOpt(true)))

        pattern_Query_ListAuditEvents_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"selfchain", "keyless", "audit_events", "wallet_id"}, "", runtime.AssumeColonVerbOpt(true)))
)

var (
        forward_Query_Params_0 = runtime.ForwardResponseMessage

        forward_Query_Wallet_0 = runtime.ForwardResponseMessage

        forward_Query_Wallets_0 = runtime.ForwardResponseMessage

        forward_Query_PartyData_0 = runtime.ForwardResponseMessage

        forward_Query_KeyRotation_0 = runtime.ForwardResponseMessage

        forward_Query_KeyRotations_0 = runtime.ForwardResponseMessage

        forward_Query_ListAuditEvents_0 = runtime.ForwardResponseMessage
)
</pre>
		
		<pre class="file" id="file53" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: selfchain/keyless/recovery.proto

package types

import (
        fmt "fmt"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type RecoveryStatus int32

const (
        RecoveryStatus_PENDING   RecoveryStatus = 0
        RecoveryStatus_COMPLETED RecoveryStatus = 1
        RecoveryStatus_FAILED    RecoveryStatus = 2
)

var RecoveryStatus_name = map[int32]string{
        0: "PENDING",
        1: "COMPLETED",
        2: "FAILED",
}

var RecoveryStatus_value = map[string]int32{
        "PENDING":   0,
        "COMPLETED": 1,
        "FAILED":    2,
}

func (x RecoveryStatus) String() string <span class="cov0" title="0">{
        return proto.EnumName(RecoveryStatus_name, int32(x))
}</span>

func (RecoveryStatus) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e7a4f73f4a14eb1f, []int{0}
}</span>

type RecoveryInfo struct {
        Did             string         `protobuf:"bytes,1,opt,name=did,proto3" json:"did,omitempty"`
        RecoveryToken   string         `protobuf:"bytes,2,opt,name=recovery_token,json=recoveryToken,proto3" json:"recovery_token,omitempty"`
        RecoveryAddress string         `protobuf:"bytes,3,opt,name=recovery_address,json=recoveryAddress,proto3" json:"recovery_address,omitempty"`
        Status          RecoveryStatus `protobuf:"varint,4,opt,name=status,proto3,enum=selfchain.keyless.RecoveryStatus" json:"status,omitempty"`
        CreatedAt       int64          `protobuf:"varint,5,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
}

func (m *RecoveryInfo) Reset()         <span class="cov0" title="0">{ *m = RecoveryInfo{} }</span>
func (m *RecoveryInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*RecoveryInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*RecoveryInfo) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e7a4f73f4a14eb1f, []int{0}
}</span>
func (m *RecoveryInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *RecoveryInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_RecoveryInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *RecoveryInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_RecoveryInfo.Merge(m, src)
}</span>
func (m *RecoveryInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *RecoveryInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_RecoveryInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_RecoveryInfo proto.InternalMessageInfo

func (m *RecoveryInfo) GetDid() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Did
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *RecoveryInfo) GetRecoveryToken() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.RecoveryToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *RecoveryInfo) GetRecoveryAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.RecoveryAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *RecoveryInfo) GetStatus() RecoveryStatus <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Status
        }</span>
        <span class="cov0" title="0">return RecoveryStatus_PENDING</span>
}

func (m *RecoveryInfo) GetCreatedAt() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CreatedAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterEnum("selfchain.keyless.RecoveryStatus", RecoveryStatus_name, RecoveryStatus_value)
        proto.RegisterType((*RecoveryInfo)(nil), "selfchain.keyless.RecoveryInfo")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("selfchain/keyless/recovery.proto", fileDescriptor_e7a4f73f4a14eb1f) }</span>

var fileDescriptor_e7a4f73f4a14eb1f = []byte{
        // 286 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x52, 0x28, 0x4e, 0xcd, 0x49,
        0x4b, 0xce, 0x48, 0xcc, 0xcc, 0xd3, 0xcf, 0x4e, 0xad, 0xcc, 0x49, 0x2d, 0x2e, 0xd6, 0x2f, 0x4a,
        0x4d, 0xce, 0x2f, 0x4b, 0x2d, 0xaa, 0xd4, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x12, 0x84, 0xab,
        0xd0, 0x83, 0xaa, 0x50, 0x3a, 0xc3, 0xc8, 0xc5, 0x13, 0x04, 0x55, 0xe5, 0x99, 0x97, 0x96, 0x2f,
        0x24, 0xc0, 0xc5, 0x9c, 0x92, 0x99, 0x22, 0xc1, 0xa8, 0xc0, 0xa8, 0xc1, 0x19, 0x04, 0x62, 0x0a,
        0xa9, 0x72, 0xf1, 0xc1, 0xcc, 0x89, 0x2f, 0xc9, 0xcf, 0x4e, 0xcd, 0x93, 0x60, 0x02, 0x4b, 0xf2,
        0xc2, 0x44, 0x43, 0x40, 0x82, 0x42, 0x9a, 0x5c, 0x02, 0x70, 0x65, 0x89, 0x29, 0x29, 0x45, 0xa9,
        0xc5, 0xc5, 0x12, 0xcc, 0x60, 0x85, 0xfc, 0x30, 0x71, 0x47, 0x88, 0xb0, 0x90, 0x25, 0x17, 0x5b,
        0x71, 0x49, 0x62, 0x49, 0x69, 0xb1, 0x04, 0x8b, 0x02, 0xa3, 0x06, 0x9f, 0x91, 0xa2, 0x1e, 0x86,
        0xc3, 0xf4, 0x60, 0x8e, 0x0a, 0x06, 0x2b, 0x0c, 0x82, 0x6a, 0x10, 0x92, 0xe5, 0xe2, 0x4a, 0x2e,
        0x4a, 0x4d, 0x2c, 0x49, 0x4d, 0x89, 0x4f, 0x2c, 0x91, 0x60, 0x55, 0x60, 0xd4, 0x60, 0x0e, 0xe2,
        0x84, 0x8a, 0x38, 0x96, 0x68, 0x59, 0x70, 0xf1, 0xa1, 0x6a, 0x14, 0xe2, 0xe6, 0x62, 0x0f, 0x70,
        0xf5, 0x73, 0xf1, 0xf4, 0x73, 0x17, 0x60, 0x10, 0xe2, 0xe5, 0xe2, 0x74, 0xf6, 0xf7, 0x0d, 0xf0,
        0x71, 0x0d, 0x71, 0x75, 0x11, 0x60, 0x14, 0xe2, 0xe2, 0x62, 0x73, 0x73, 0xf4, 0xf4, 0x71, 0x75,
        0x11, 0x60, 0x72, 0x32, 0x3e, 0xf1, 0x48, 0x8e, 0xf1, 0xc2, 0x23, 0x39, 0xc6, 0x07, 0x8f, 0xe4,
        0x18, 0x27, 0x3c, 0x96, 0x63, 0xb8, 0xf0, 0x58, 0x8e, 0xe1, 0xc6, 0x63, 0x39, 0x86, 0x28, 0x49,
        0x44, 0xb8, 0x56, 0xc0, 0x43, 0xb6, 0xa4, 0xb2, 0x20, 0xb5, 0x38, 0x89, 0x0d, 0x1c, 0xae, 0xc6,
        0x80, 0x00, 0x00, 0x00, 0xff, 0xff, 0xeb, 0x8a, 0xd6, 0xf6, 0x7b, 0x01, 0x00, 0x00,
}

func (m *RecoveryInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *RecoveryInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *RecoveryInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.CreatedAt != 0 </span><span class="cov0" title="0">{
                i = encodeVarintRecovery(dAtA, i, uint64(m.CreatedAt))
                i--
                dAtA[i] = 0x28
        }</span>
        <span class="cov0" title="0">if m.Status != 0 </span><span class="cov0" title="0">{
                i = encodeVarintRecovery(dAtA, i, uint64(m.Status))
                i--
                dAtA[i] = 0x20
        }</span>
        <span class="cov0" title="0">if len(m.RecoveryAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.RecoveryAddress)
                copy(dAtA[i:], m.RecoveryAddress)
                i = encodeVarintRecovery(dAtA, i, uint64(len(m.RecoveryAddress)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.RecoveryToken) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.RecoveryToken)
                copy(dAtA[i:], m.RecoveryToken)
                i = encodeVarintRecovery(dAtA, i, uint64(len(m.RecoveryToken)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Did) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Did)
                copy(dAtA[i:], m.Did)
                i = encodeVarintRecovery(dAtA, i, uint64(len(m.Did)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintRecovery(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovRecovery(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *RecoveryInfo) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Did)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovRecovery(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.RecoveryToken)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovRecovery(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.RecoveryAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovRecovery(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Status != 0 </span><span class="cov0" title="0">{
                n += 1 + sovRecovery(uint64(m.Status))
        }</span>
        <span class="cov0" title="0">if m.CreatedAt != 0 </span><span class="cov0" title="0">{
                n += 1 + sovRecovery(uint64(m.CreatedAt))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovRecovery(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozRecovery(x uint64) (n int) <span class="cov0" title="0">{
        return sovRecovery(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *RecoveryInfo) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowRecovery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: RecoveryInfo: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: RecoveryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Did", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowRecovery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthRecovery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthRecovery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Did = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field RecoveryToken", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowRecovery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthRecovery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthRecovery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.RecoveryToken = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field RecoveryAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowRecovery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthRecovery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthRecovery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.RecoveryAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Status = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowRecovery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Status |= RecoveryStatus(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 5:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
                        }</span>
                        <span class="cov0" title="0">m.CreatedAt = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowRecovery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.CreatedAt |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipRecovery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthRecovery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipRecovery(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowRecovery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowRecovery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowRecovery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthRecovery
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupRecovery
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthRecovery
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthRecovery        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowRecovery          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupRecovery = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file54" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: selfchain/keyless/rotation.proto

package types

import (
        fmt "fmt"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
        _ "google.golang.org/protobuf/types/known/timestamppb"
        io "io"
        math "math"
        math_bits "math/bits"
        time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// KeyRotation represents a key rotation operation for a wallet
type KeyRotation struct {
        WalletId    string     `protobuf:"bytes,1,opt,name=wallet_id,json=walletId,proto3" json:"wallet_id,omitempty"`
        Version     uint64     `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
        NewPubKey   string     `protobuf:"bytes,3,opt,name=new_pub_key,json=newPubKey,proto3" json:"new_pub_key,omitempty"`
        Status      string     `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`
        CreatedAt   *time.Time `protobuf:"bytes,5,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at,omitempty"`
        CompletedAt *time.Time `protobuf:"bytes,6,opt,name=completed_at,json=completedAt,proto3,stdtime" json:"completed_at,omitempty"`
        Signature   string     `protobuf:"bytes,7,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *KeyRotation) Reset()         <span class="cov0" title="0">{ *m = KeyRotation{} }</span>
func (m *KeyRotation) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*KeyRotation) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*KeyRotation) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_c82a5763159cea2e, []int{0}
}</span>
func (m *KeyRotation) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *KeyRotation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_KeyRotation.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *KeyRotation) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_KeyRotation.Merge(m, src)
}</span>
func (m *KeyRotation) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *KeyRotation) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_KeyRotation.DiscardUnknown(m)
}</span>

var xxx_messageInfo_KeyRotation proto.InternalMessageInfo

func (m *KeyRotation) GetWalletId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WalletId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *KeyRotation) GetVersion() uint64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Version
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *KeyRotation) GetNewPubKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.NewPubKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *KeyRotation) GetStatus() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *KeyRotation) GetCreatedAt() *time.Time <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *KeyRotation) GetCompletedAt() *time.Time <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CompletedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *KeyRotation) GetSignature() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Signature
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*KeyRotation)(nil), "selfchain.keyless.KeyRotation")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("selfchain/keyless/rotation.proto", fileDescriptor_c82a5763159cea2e) }</span>

var fileDescriptor_c82a5763159cea2e = []byte{
        // 329 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x91, 0xcf, 0x4e, 0xf2, 0x40,
        0x14, 0xc5, 0x19, 0x3e, 0x3e, 0xa0, 0x53, 0x37, 0x4e, 0x8c, 0x19, 0xd1, 0x0c, 0x8d, 0x2b, 0x56,
        0x6d, 0x22, 0x0f, 0x60, 0x60, 0x63, 0x0c, 0x1b, 0xd3, 0xb8, 0x72, 0xd3, 0x4c, 0xe1, 0x52, 0x1b,
        0x4a, 0xa7, 0xe9, 0xdc, 0x8a, 0x7d, 0x0b, 0x1e, 0xc2, 0x87, 0x61, 0xc9, 0xd2, 0x95, 0x1a, 0x78,
        0x11, 0x63, 0xff, 0xb9, 0x74, 0x37, 0xe7, 0xde, 0x73, 0xce, 0xfc, 0x92, 0x4b, 0x2d, 0x0d, 0xd1,
        0x72, 0xfe, 0x2c, 0xc3, 0xd8, 0x59, 0x41, 0x1e, 0x81, 0xd6, 0x4e, 0xaa, 0x50, 0x62, 0xa8, 0x62,
        0x3b, 0x49, 0x15, 0x2a, 0x76, 0xda, 0x38, 0xec, 0xca, 0x31, 0x38, 0x0b, 0x54, 0xa0, 0x8a, 0xad,
        0xf3, 0xf3, 0x2a, 0x8d, 0x83, 0x61, 0xa0, 0x54, 0x10, 0x81, 0x53, 0x28, 0x3f, 0x5b, 0x3a, 0x18,
        0xae, 0x41, 0xa3, 0x5c, 0x27, 0xa5, 0xe1, 0xfa, 0xad, 0x4d, 0xcd, 0x19, 0xe4, 0x6e, 0xd5, 0xcf,
        0x2e, 0xa9, 0xb1, 0x91, 0x51, 0x04, 0xe8, 0x85, 0x0b, 0x4e, 0x2c, 0x32, 0x32, 0xdc, 0x7e, 0x39,
        0xb8, 0x5f, 0x30, 0x4e, 0x7b, 0x2f, 0x90, 0xea, 0x50, 0xc5, 0xbc, 0x6d, 0x91, 0x51, 0xc7, 0xad,
        0x25, 0x13, 0xd4, 0x8c, 0x61, 0xe3, 0x25, 0x99, 0xef, 0xad, 0x20, 0xe7, 0xff, 0x8a, 0xa0, 0x11,
        0xc3, 0xe6, 0x21, 0xf3, 0x67, 0x90, 0xb3, 0x73, 0xda, 0xd5, 0x28, 0x31, 0xd3, 0xbc, 0x53, 0xac,
        0x2a, 0xc5, 0x6e, 0x29, 0x9d, 0xa7, 0x20, 0x11, 0x16, 0x9e, 0x44, 0xfe, 0xdf, 0x22, 0x23, 0xf3,
        0x66, 0x60, 0x97, 0xd0, 0x76, 0x0d, 0x6d, 0x3f, 0xd6, 0xd0, 0xd3, 0xce, 0xf6, 0x73, 0x48, 0x5c,
        0xa3, 0xca, 0x4c, 0x90, 0xdd, 0xd1, 0x93, 0xb9, 0x5a, 0x27, 0x11, 0x54, 0x15, 0xdd, 0x3f, 0x2b,
        0xfa, 0xbb, 0x8f, 0x21, 0x29, 0x6a, 0xcc, 0x26, 0x39, 0x41, 0x76, 0x45, 0x0d, 0x1d, 0x06, 0xb1,
        0xc4, 0x2c, 0x05, 0xde, 0x2b, 0xf9, 0x9b, 0xc1, 0x74, 0xbc, 0x3b, 0x08, 0xb2, 0x3f, 0x08, 0xf2,
        0x75, 0x10, 0x64, 0x7b, 0x14, 0xad, 0xfd, 0x51, 0xb4, 0xde, 0x8f, 0xa2, 0xf5, 0x74, 0xf1, 0x7b,
        0xac, 0xd7, 0xe6, 0x5c, 0x98, 0x27, 0xa0, 0xfd, 0x6e, 0xf1, 0xfb, 0xf8, 0x3b, 0x00, 0x00, 0xff,
        0xff, 0xbb, 0xed, 0xec, 0x29, 0xd0, 0x01, 0x00, 0x00,
}

func (m *KeyRotation) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *KeyRotation) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *KeyRotation) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Signature) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Signature)
                copy(dAtA[i:], m.Signature)
                i = encodeVarintRotation(dAtA, i, uint64(len(m.Signature)))
                i--
                dAtA[i] = 0x3a
        }</span>
        <span class="cov0" title="0">if m.CompletedAt != nil </span><span class="cov0" title="0">{
                n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.CompletedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.CompletedAt):])
                if err1 != nil </span><span class="cov0" title="0">{
                        return 0, err1
                }</span>
                <span class="cov0" title="0">i -= n1
                i = encodeVarintRotation(dAtA, i, uint64(n1))
                i--
                dAtA[i] = 0x32</span>
        }
        <span class="cov0" title="0">if m.CreatedAt != nil </span><span class="cov0" title="0">{
                n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.CreatedAt):])
                if err2 != nil </span><span class="cov0" title="0">{
                        return 0, err2
                }</span>
                <span class="cov0" title="0">i -= n2
                i = encodeVarintRotation(dAtA, i, uint64(n2))
                i--
                dAtA[i] = 0x2a</span>
        }
        <span class="cov0" title="0">if len(m.Status) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Status)
                copy(dAtA[i:], m.Status)
                i = encodeVarintRotation(dAtA, i, uint64(len(m.Status)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov0" title="0">if len(m.NewPubKey) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.NewPubKey)
                copy(dAtA[i:], m.NewPubKey)
                i = encodeVarintRotation(dAtA, i, uint64(len(m.NewPubKey)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if m.Version != 0 </span><span class="cov0" title="0">{
                i = encodeVarintRotation(dAtA, i, uint64(m.Version))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.WalletId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.WalletId)
                copy(dAtA[i:], m.WalletId)
                i = encodeVarintRotation(dAtA, i, uint64(len(m.WalletId)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintRotation(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovRotation(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *KeyRotation) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.WalletId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovRotation(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Version != 0 </span><span class="cov0" title="0">{
                n += 1 + sovRotation(uint64(m.Version))
        }</span>
        <span class="cov0" title="0">l = len(m.NewPubKey)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovRotation(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Status)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovRotation(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.CreatedAt != nil </span><span class="cov0" title="0">{
                l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.CreatedAt)
                n += 1 + l + sovRotation(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.CompletedAt != nil </span><span class="cov0" title="0">{
                l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.CompletedAt)
                n += 1 + l + sovRotation(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Signature)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovRotation(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovRotation(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozRotation(x uint64) (n int) <span class="cov0" title="0">{
        return sovRotation(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *KeyRotation) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowRotation
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyRotation: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyRotation: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WalletId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowRotation
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthRotation
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthRotation
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.WalletId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Version = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowRotation
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Version |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field NewPubKey", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowRotation
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthRotation
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthRotation
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.NewPubKey = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowRotation
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthRotation
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthRotation
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Status = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 5:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowRotation
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthRotation
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthRotation
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.CreatedAt == nil </span><span class="cov0" title="0">{
                                m.CreatedAt = new(time.Time)
                        }</span>
                        <span class="cov0" title="0">if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 6:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CompletedAt", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowRotation
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthRotation
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthRotation
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.CompletedAt == nil </span><span class="cov0" title="0">{
                                m.CompletedAt = new(time.Time)
                        }</span>
                        <span class="cov0" title="0">if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.CompletedAt, dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 7:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowRotation
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthRotation
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthRotation
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Signature = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipRotation(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthRotation
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipRotation(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowRotation
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowRotation
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowRotation
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthRotation
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupRotation
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthRotation
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthRotation        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowRotation          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupRotation = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file55" style="display: none">package types

// IsValid returns whether the security level is valid
func (s SecurityLevel) IsValid() bool <span class="cov0" title="0">{
        switch s </span>{
        case SecurityLevel_SECURITY_LEVEL_STANDARD,
                SecurityLevel_SECURITY_LEVEL_HIGH,
                SecurityLevel_SECURITY_LEVEL_ENTERPRISE:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file56" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: selfchain/keyless/tx.proto

package types

import (
        context "context"
        fmt "fmt"
        _ "github.com/cosmos/cosmos-sdk/types/msgservice"
        _ "github.com/cosmos/gogoproto/gogoproto"
        grpc1 "github.com/cosmos/gogoproto/grpc"
        proto "github.com/cosmos/gogoproto/proto"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgCreateWallet defines the CreateWallet request type
type MsgCreateWallet struct {
        Creator       string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
        PubKey        string `protobuf:"bytes,2,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
        WalletAddress string `protobuf:"bytes,3,opt,name=wallet_address,json=walletAddress,proto3" json:"wallet_address,omitempty"`
        ChainId       string `protobuf:"bytes,4,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *MsgCreateWallet) Reset()         <span class="cov0" title="0">{ *m = MsgCreateWallet{} }</span>
func (m *MsgCreateWallet) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgCreateWallet) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgCreateWallet) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e253e00af3c3c87e, []int{0}
}</span>
func (m *MsgCreateWallet) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgCreateWallet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgCreateWallet.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgCreateWallet) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgCreateWallet.Merge(m, src)
}</span>
func (m *MsgCreateWallet) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgCreateWallet) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgCreateWallet.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgCreateWallet proto.InternalMessageInfo

func (m *MsgCreateWallet) GetCreator() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Creator
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgCreateWallet) GetPubKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PubKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgCreateWallet) GetWalletAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WalletAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgCreateWallet) GetChainId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ChainId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// MsgCreateWalletResponse defines the CreateWallet response type
type MsgCreateWalletResponse struct {
        WalletAddress string `protobuf:"bytes,1,opt,name=wallet_address,json=walletAddress,proto3" json:"wallet_address,omitempty"`
}

func (m *MsgCreateWalletResponse) Reset()         <span class="cov0" title="0">{ *m = MsgCreateWalletResponse{} }</span>
func (m *MsgCreateWalletResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgCreateWalletResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgCreateWalletResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e253e00af3c3c87e, []int{1}
}</span>
func (m *MsgCreateWalletResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgCreateWalletResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgCreateWalletResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgCreateWalletResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgCreateWalletResponse.Merge(m, src)
}</span>
func (m *MsgCreateWalletResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgCreateWalletResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgCreateWalletResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgCreateWalletResponse proto.InternalMessageInfo

func (m *MsgCreateWalletResponse) GetWalletAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WalletAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// MsgRecoverWallet defines the RecoverWallet request type
type MsgRecoverWallet struct {
        Creator       string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
        WalletAddress string `protobuf:"bytes,2,opt,name=wallet_address,json=walletAddress,proto3" json:"wallet_address,omitempty"`
        RecoveryProof string `protobuf:"bytes,3,opt,name=recovery_proof,json=recoveryProof,proto3" json:"recovery_proof,omitempty"`
        NewPubKey     string `protobuf:"bytes,4,opt,name=new_pub_key,json=newPubKey,proto3" json:"new_pub_key,omitempty"`
        Signature     string `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *MsgRecoverWallet) Reset()         <span class="cov0" title="0">{ *m = MsgRecoverWallet{} }</span>
func (m *MsgRecoverWallet) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgRecoverWallet) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgRecoverWallet) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e253e00af3c3c87e, []int{2}
}</span>
func (m *MsgRecoverWallet) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgRecoverWallet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgRecoverWallet.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgRecoverWallet) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgRecoverWallet.Merge(m, src)
}</span>
func (m *MsgRecoverWallet) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgRecoverWallet) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgRecoverWallet.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgRecoverWallet proto.InternalMessageInfo

func (m *MsgRecoverWallet) GetCreator() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Creator
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgRecoverWallet) GetWalletAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WalletAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgRecoverWallet) GetRecoveryProof() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.RecoveryProof
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgRecoverWallet) GetNewPubKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.NewPubKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgRecoverWallet) GetSignature() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Signature
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// MsgRecoverWalletResponse defines the RecoverWallet response type
type MsgRecoverWalletResponse struct {
        WalletAddress string `protobuf:"bytes,1,opt,name=wallet_address,json=walletAddress,proto3" json:"wallet_address,omitempty"`
}

func (m *MsgRecoverWalletResponse) Reset()         <span class="cov0" title="0">{ *m = MsgRecoverWalletResponse{} }</span>
func (m *MsgRecoverWalletResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgRecoverWalletResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgRecoverWalletResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e253e00af3c3c87e, []int{3}
}</span>
func (m *MsgRecoverWalletResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgRecoverWalletResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgRecoverWalletResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgRecoverWalletResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgRecoverWalletResponse.Merge(m, src)
}</span>
func (m *MsgRecoverWalletResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgRecoverWalletResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgRecoverWalletResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgRecoverWalletResponse proto.InternalMessageInfo

func (m *MsgRecoverWalletResponse) GetWalletAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WalletAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// MsgSignTransaction defines the SignTransaction request type
type MsgSignTransaction struct {
        Creator       string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
        WalletAddress string `protobuf:"bytes,2,opt,name=wallet_address,json=walletAddress,proto3" json:"wallet_address,omitempty"`
        UnsignedTx    string `protobuf:"bytes,3,opt,name=unsigned_tx,json=unsignedTx,proto3" json:"unsigned_tx,omitempty"`
        ChainId       string `protobuf:"bytes,4,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *MsgSignTransaction) Reset()         <span class="cov0" title="0">{ *m = MsgSignTransaction{} }</span>
func (m *MsgSignTransaction) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgSignTransaction) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgSignTransaction) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e253e00af3c3c87e, []int{4}
}</span>
func (m *MsgSignTransaction) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgSignTransaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgSignTransaction.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgSignTransaction) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgSignTransaction.Merge(m, src)
}</span>
func (m *MsgSignTransaction) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgSignTransaction) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgSignTransaction.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgSignTransaction proto.InternalMessageInfo

func (m *MsgSignTransaction) GetCreator() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Creator
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgSignTransaction) GetWalletAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WalletAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgSignTransaction) GetUnsignedTx() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UnsignedTx
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgSignTransaction) GetChainId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ChainId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// MsgSignTransactionResponse defines the SignTransaction response type
type MsgSignTransactionResponse struct {
        SignedTx string `protobuf:"bytes,1,opt,name=signed_tx,json=signedTx,proto3" json:"signed_tx,omitempty"`
}

func (m *MsgSignTransactionResponse) Reset()         <span class="cov0" title="0">{ *m = MsgSignTransactionResponse{} }</span>
func (m *MsgSignTransactionResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgSignTransactionResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgSignTransactionResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e253e00af3c3c87e, []int{5}
}</span>
func (m *MsgSignTransactionResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgSignTransactionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgSignTransactionResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgSignTransactionResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgSignTransactionResponse.Merge(m, src)
}</span>
func (m *MsgSignTransactionResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgSignTransactionResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgSignTransactionResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgSignTransactionResponse proto.InternalMessageInfo

func (m *MsgSignTransactionResponse) GetSignedTx() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SignedTx
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// MsgBatchSign defines the BatchSign request type
type MsgBatchSign struct {
        Creator       string   `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
        WalletAddress string   `protobuf:"bytes,2,opt,name=wallet_address,json=walletAddress,proto3" json:"wallet_address,omitempty"`
        UnsignedTxs   []string `protobuf:"bytes,3,rep,name=unsigned_txs,json=unsignedTxs,proto3" json:"unsigned_txs,omitempty"`
        ChainId       string   `protobuf:"bytes,4,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *MsgBatchSign) Reset()         <span class="cov0" title="0">{ *m = MsgBatchSign{} }</span>
func (m *MsgBatchSign) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgBatchSign) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgBatchSign) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e253e00af3c3c87e, []int{6}
}</span>
func (m *MsgBatchSign) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgBatchSign) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgBatchSign.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgBatchSign) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgBatchSign.Merge(m, src)
}</span>
func (m *MsgBatchSign) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgBatchSign) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgBatchSign.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgBatchSign proto.InternalMessageInfo

func (m *MsgBatchSign) GetCreator() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Creator
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgBatchSign) GetWalletAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WalletAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgBatchSign) GetUnsignedTxs() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UnsignedTxs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *MsgBatchSign) GetChainId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ChainId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// MsgBatchSignResponse defines the BatchSign response type
type MsgBatchSignResponse struct {
        SignedTxs []string `protobuf:"bytes,1,rep,name=signed_txs,json=signedTxs,proto3" json:"signed_txs,omitempty"`
}

func (m *MsgBatchSignResponse) Reset()         <span class="cov0" title="0">{ *m = MsgBatchSignResponse{} }</span>
func (m *MsgBatchSignResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgBatchSignResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgBatchSignResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e253e00af3c3c87e, []int{7}
}</span>
func (m *MsgBatchSignResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgBatchSignResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgBatchSignResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgBatchSignResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgBatchSignResponse.Merge(m, src)
}</span>
func (m *MsgBatchSignResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgBatchSignResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgBatchSignResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgBatchSignResponse proto.InternalMessageInfo

func (m *MsgBatchSignResponse) GetSignedTxs() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SignedTxs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// MsgInitiateKeyRotation defines the InitiateKeyRotation request type
type MsgInitiateKeyRotation struct {
        Creator       string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
        WalletAddress string `protobuf:"bytes,2,opt,name=wallet_address,json=walletAddress,proto3" json:"wallet_address,omitempty"`
        NewPubKey     string `protobuf:"bytes,3,opt,name=new_pub_key,json=newPubKey,proto3" json:"new_pub_key,omitempty"`
        Signature     string `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *MsgInitiateKeyRotation) Reset()         <span class="cov0" title="0">{ *m = MsgInitiateKeyRotation{} }</span>
func (m *MsgInitiateKeyRotation) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgInitiateKeyRotation) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgInitiateKeyRotation) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e253e00af3c3c87e, []int{8}
}</span>
func (m *MsgInitiateKeyRotation) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgInitiateKeyRotation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgInitiateKeyRotation.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgInitiateKeyRotation) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgInitiateKeyRotation.Merge(m, src)
}</span>
func (m *MsgInitiateKeyRotation) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgInitiateKeyRotation) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgInitiateKeyRotation.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgInitiateKeyRotation proto.InternalMessageInfo

func (m *MsgInitiateKeyRotation) GetCreator() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Creator
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgInitiateKeyRotation) GetWalletAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WalletAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgInitiateKeyRotation) GetNewPubKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.NewPubKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgInitiateKeyRotation) GetSignature() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Signature
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// MsgInitiateKeyRotationResponse defines the InitiateKeyRotation response type
type MsgInitiateKeyRotationResponse struct {
        WalletAddress string `protobuf:"bytes,1,opt,name=wallet_address,json=walletAddress,proto3" json:"wallet_address,omitempty"`
        NewVersion    uint32 `protobuf:"varint,2,opt,name=new_version,json=newVersion,proto3" json:"new_version,omitempty"`
}

func (m *MsgInitiateKeyRotationResponse) Reset()         <span class="cov0" title="0">{ *m = MsgInitiateKeyRotationResponse{} }</span>
func (m *MsgInitiateKeyRotationResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgInitiateKeyRotationResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgInitiateKeyRotationResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e253e00af3c3c87e, []int{9}
}</span>
func (m *MsgInitiateKeyRotationResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgInitiateKeyRotationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgInitiateKeyRotationResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgInitiateKeyRotationResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgInitiateKeyRotationResponse.Merge(m, src)
}</span>
func (m *MsgInitiateKeyRotationResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgInitiateKeyRotationResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgInitiateKeyRotationResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgInitiateKeyRotationResponse proto.InternalMessageInfo

func (m *MsgInitiateKeyRotationResponse) GetWalletAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WalletAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgInitiateKeyRotationResponse) GetNewVersion() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.NewVersion
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// MsgCompleteKeyRotation defines the CompleteKeyRotation request type
type MsgCompleteKeyRotation struct {
        Creator       string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
        WalletAddress string `protobuf:"bytes,2,opt,name=wallet_address,json=walletAddress,proto3" json:"wallet_address,omitempty"`
        Version       uint32 `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
        Signature     string `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *MsgCompleteKeyRotation) Reset()         <span class="cov0" title="0">{ *m = MsgCompleteKeyRotation{} }</span>
func (m *MsgCompleteKeyRotation) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgCompleteKeyRotation) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgCompleteKeyRotation) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e253e00af3c3c87e, []int{10}
}</span>
func (m *MsgCompleteKeyRotation) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgCompleteKeyRotation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgCompleteKeyRotation.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgCompleteKeyRotation) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgCompleteKeyRotation.Merge(m, src)
}</span>
func (m *MsgCompleteKeyRotation) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgCompleteKeyRotation) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgCompleteKeyRotation.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgCompleteKeyRotation proto.InternalMessageInfo

func (m *MsgCompleteKeyRotation) GetCreator() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Creator
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgCompleteKeyRotation) GetWalletAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WalletAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgCompleteKeyRotation) GetVersion() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Version
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *MsgCompleteKeyRotation) GetSignature() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Signature
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// MsgCompleteKeyRotationResponse defines the CompleteKeyRotation response type
type MsgCompleteKeyRotationResponse struct {
        WalletAddress string `protobuf:"bytes,1,opt,name=wallet_address,json=walletAddress,proto3" json:"wallet_address,omitempty"`
        Version       uint32 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *MsgCompleteKeyRotationResponse) Reset()         <span class="cov0" title="0">{ *m = MsgCompleteKeyRotationResponse{} }</span>
func (m *MsgCompleteKeyRotationResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgCompleteKeyRotationResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgCompleteKeyRotationResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e253e00af3c3c87e, []int{11}
}</span>
func (m *MsgCompleteKeyRotationResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgCompleteKeyRotationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgCompleteKeyRotationResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgCompleteKeyRotationResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgCompleteKeyRotationResponse.Merge(m, src)
}</span>
func (m *MsgCompleteKeyRotationResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgCompleteKeyRotationResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgCompleteKeyRotationResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgCompleteKeyRotationResponse proto.InternalMessageInfo

func (m *MsgCompleteKeyRotationResponse) GetWalletAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WalletAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgCompleteKeyRotationResponse) GetVersion() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Version
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// MsgCancelKeyRotation defines the CancelKeyRotation request type
type MsgCancelKeyRotation struct {
        Creator       string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
        WalletAddress string `protobuf:"bytes,2,opt,name=wallet_address,json=walletAddress,proto3" json:"wallet_address,omitempty"`
        Version       uint32 `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *MsgCancelKeyRotation) Reset()         <span class="cov0" title="0">{ *m = MsgCancelKeyRotation{} }</span>
func (m *MsgCancelKeyRotation) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgCancelKeyRotation) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgCancelKeyRotation) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e253e00af3c3c87e, []int{12}
}</span>
func (m *MsgCancelKeyRotation) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgCancelKeyRotation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgCancelKeyRotation.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgCancelKeyRotation) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgCancelKeyRotation.Merge(m, src)
}</span>
func (m *MsgCancelKeyRotation) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgCancelKeyRotation) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgCancelKeyRotation.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgCancelKeyRotation proto.InternalMessageInfo

func (m *MsgCancelKeyRotation) GetCreator() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Creator
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgCancelKeyRotation) GetWalletAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WalletAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgCancelKeyRotation) GetVersion() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Version
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// MsgCancelKeyRotationResponse defines the CancelKeyRotation response type
type MsgCancelKeyRotationResponse struct {
        WalletAddress string `protobuf:"bytes,1,opt,name=wallet_address,json=walletAddress,proto3" json:"wallet_address,omitempty"`
}

func (m *MsgCancelKeyRotationResponse) Reset()         <span class="cov0" title="0">{ *m = MsgCancelKeyRotationResponse{} }</span>
func (m *MsgCancelKeyRotationResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgCancelKeyRotationResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgCancelKeyRotationResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e253e00af3c3c87e, []int{13}
}</span>
func (m *MsgCancelKeyRotationResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgCancelKeyRotationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgCancelKeyRotationResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgCancelKeyRotationResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgCancelKeyRotationResponse.Merge(m, src)
}</span>
func (m *MsgCancelKeyRotationResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgCancelKeyRotationResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgCancelKeyRotationResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgCancelKeyRotationResponse proto.InternalMessageInfo

func (m *MsgCancelKeyRotationResponse) GetWalletAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WalletAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*MsgCreateWallet)(nil), "selfchain.keyless.MsgCreateWallet")
        proto.RegisterType((*MsgCreateWalletResponse)(nil), "selfchain.keyless.MsgCreateWalletResponse")
        proto.RegisterType((*MsgRecoverWallet)(nil), "selfchain.keyless.MsgRecoverWallet")
        proto.RegisterType((*MsgRecoverWalletResponse)(nil), "selfchain.keyless.MsgRecoverWalletResponse")
        proto.RegisterType((*MsgSignTransaction)(nil), "selfchain.keyless.MsgSignTransaction")
        proto.RegisterType((*MsgSignTransactionResponse)(nil), "selfchain.keyless.MsgSignTransactionResponse")
        proto.RegisterType((*MsgBatchSign)(nil), "selfchain.keyless.MsgBatchSign")
        proto.RegisterType((*MsgBatchSignResponse)(nil), "selfchain.keyless.MsgBatchSignResponse")
        proto.RegisterType((*MsgInitiateKeyRotation)(nil), "selfchain.keyless.MsgInitiateKeyRotation")
        proto.RegisterType((*MsgInitiateKeyRotationResponse)(nil), "selfchain.keyless.MsgInitiateKeyRotationResponse")
        proto.RegisterType((*MsgCompleteKeyRotation)(nil), "selfchain.keyless.MsgCompleteKeyRotation")
        proto.RegisterType((*MsgCompleteKeyRotationResponse)(nil), "selfchain.keyless.MsgCompleteKeyRotationResponse")
        proto.RegisterType((*MsgCancelKeyRotation)(nil), "selfchain.keyless.MsgCancelKeyRotation")
        proto.RegisterType((*MsgCancelKeyRotationResponse)(nil), "selfchain.keyless.MsgCancelKeyRotationResponse")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("selfchain/keyless/tx.proto", fileDescriptor_e253e00af3c3c87e) }</span>

var fileDescriptor_e253e00af3c3c87e = []byte{
        // 719 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0x4f, 0x4f, 0xdb, 0x4e,
        0x10, 0x65, 0x09, 0xff, 0x32, 0x04, 0xf8, 0xe1, 0x1f, 0x2a, 0xc6, 0xa5, 0xa6, 0x75, 0x85, 0x4a,
        0xa9, 0x9a, 0x88, 0xa2, 0x1e, 0xda, 0x53, 0x01, 0xf5, 0x80, 0x50, 0x24, 0x94, 0xd2, 0x56, 0xea,
        0xa1, 0xd1, 0xe2, 0x0c, 0xc6, 0x22, 0xd9, 0xb5, 0xbc, 0x0e, 0x49, 0x4e, 0xad, 0xfa, 0x09, 0x7a,
        0xe8, 0xad, 0x87, 0x9e, 0x7a, 0xe7, 0x53, 0x54, 0x3d, 0x72, 0xec, 0xb1, 0x82, 0x03, 0xfd, 0x18,
        0x95, 0x6d, 0xec, 0x24, 0xce, 0x02, 0xb1, 0x40, 0x3d, 0x25, 0x3b, 0xf3, 0x76, 0xde, 0x9b, 0xe7,
        0xb1, 0x77, 0x41, 0x13, 0x58, 0xdd, 0x33, 0xf7, 0xa9, 0xcd, 0x0a, 0x07, 0xd8, 0xaa, 0xa2, 0x10,
        0x05, 0xaf, 0x99, 0x77, 0x5c, 0xee, 0x71, 0x65, 0x3a, 0xce, 0xe5, 0xcf, 0x73, 0xda, 0x8c, 0xc5,
        0x2d, 0x1e, 0x64, 0x0b, 0xfe, 0xbf, 0x10, 0xa8, 0xcd, 0x9a, 0x5c, 0xd4, 0xb8, 0x28, 0xd4, 0x84,
        0x55, 0x38, 0x5c, 0xf1, 0x7f, 0xc2, 0x84, 0xf1, 0x85, 0xc0, 0x54, 0x51, 0x58, 0x1b, 0x2e, 0x52,
        0x0f, 0xdf, 0xd2, 0x6a, 0x15, 0x3d, 0x45, 0x85, 0x51, 0xd3, 0x5f, 0x73, 0x57, 0x25, 0x77, 0xc9,
        0x52, 0xb6, 0x14, 0x2d, 0x95, 0x59, 0x18, 0x75, 0xea, 0xbb, 0xe5, 0x03, 0x6c, 0xa9, 0x83, 0x41,
        0x66, 0xc4, 0xa9, 0xef, 0x6e, 0x61, 0x4b, 0x59, 0x84, 0xc9, 0x46, 0xb0, 0xb9, 0x4c, 0x2b, 0x15,
        0x17, 0x85, 0x50, 0x33, 0x41, 0x7e, 0x22, 0x8c, 0xae, 0x85, 0x41, 0x65, 0x0e, 0xc6, 0x02, 0xb5,
        0x65, 0xbb, 0xa2, 0x0e, 0x9d, 0x97, 0xf6, 0xd7, 0x9b, 0x95, 0xe7, 0xb9, 0x4f, 0x67, 0x47, 0xcb,
        0x11, 0x91, 0xf1, 0x02, 0x66, 0x13, 0xaa, 0x4a, 0x28, 0x1c, 0xce, 0x04, 0x4a, 0xa8, 0x88, 0x84,
        0xca, 0xf8, 0x41, 0xe0, 0xbf, 0xa2, 0xb0, 0x4a, 0x68, 0xf2, 0x43, 0x74, 0xaf, 0xec, 0xac, 0xb7,
        0xea, 0xa0, 0xac, 0x81, 0x45, 0x98, 0x74, 0xc3, 0x8a, 0xad, 0xb2, 0xe3, 0x72, 0xbe, 0x17, 0xf5,
        0x19, 0x45, 0xb7, 0xfd, 0xa0, 0xa2, 0xc3, 0x38, 0xc3, 0x46, 0x39, 0xf2, 0x2a, 0x6c, 0x35, 0xcb,
        0xb0, 0xb1, 0x1d, 0xda, 0x35, 0x0f, 0x59, 0x61, 0x5b, 0x8c, 0x7a, 0x75, 0x17, 0xd5, 0xe1, 0x30,
        0x1b, 0x07, 0x12, 0x56, 0xac, 0x81, 0x9a, 0xec, 0x23, 0xad, 0x17, 0xdf, 0x08, 0x28, 0x45, 0x61,
        0xbd, 0xb2, 0x2d, 0xb6, 0xe3, 0x52, 0x26, 0xa8, 0xe9, 0xd9, 0x9c, 0x5d, 0xdf, 0x8d, 0x05, 0x18,
        0xaf, 0x33, 0x5f, 0x37, 0x56, 0xca, 0x5e, 0xf3, 0xdc, 0x0a, 0x88, 0x42, 0x3b, 0xcd, 0xfe, 0x9f,
        0xf7, 0x33, 0xd0, 0x7a, 0x05, 0xc6, 0x6d, 0xde, 0x0e, 0xed, 0x0a, 0x59, 0x42, 0xa9, 0x63, 0x11,
        0x87, 0xf1, 0x95, 0x40, 0xae, 0x28, 0xac, 0x75, 0xea, 0x99, 0xfb, 0x7e, 0x81, 0xeb, 0xb7, 0x75,
        0x0f, 0x72, 0x1d, 0x6d, 0xf9, 0xa3, 0x9c, 0x59, 0xca, 0x96, 0xc6, 0xdb, 0x7d, 0xa5, 0x18, 0xe4,
        0xa7, 0x30, 0xd3, 0x29, 0x2e, 0x6e, 0xe9, 0x0e, 0x40, 0x07, 0x03, 0x09, 0x18, 0xb2, 0x71, 0x7d,
        0xe3, 0x3b, 0x81, 0x5b, 0x45, 0x61, 0x6d, 0x32, 0xdb, 0xb3, 0xa9, 0x87, 0x5b, 0xd8, 0x2a, 0x71,
        0x8f, 0xde, 0xcc, 0x53, 0x4b, 0x0c, 0x67, 0xe6, 0xd2, 0xe1, 0x1c, 0xba, 0x7c, 0x38, 0xf7, 0x41,
        0x97, 0xcb, 0x4c, 0x39, 0xa2, 0xfe, 0x28, 0xf9, 0xa2, 0x0e, 0xd1, 0x15, 0x36, 0x67, 0x81, 0xf0,
        0x89, 0x12, 0x30, 0x6c, 0xbc, 0x09, 0x23, 0xfe, 0x0c, 0xfb, 0x8e, 0x6c, 0xf0, 0x9a, 0x53, 0xc5,
        0x1b, 0x76, 0x44, 0x85, 0xd1, 0x88, 0x38, 0x13, 0x10, 0x47, 0xcb, 0x54, 0x5e, 0xd0, 0xc0, 0x0b,
        0x89, 0xc0, 0xb4, 0x5e, 0x74, 0xc8, 0x19, 0xec, 0x92, 0x63, 0x7c, 0x08, 0xa6, 0x69, 0x83, 0x32,
        0x13, 0xab, 0xff, 0xc6, 0x81, 0x44, 0x8f, 0x2f, 0x61, 0x5e, 0x26, 0x20, 0x65, 0x87, 0x4f, 0xfe,
        0x0c, 0x43, 0xa6, 0x28, 0x2c, 0xe5, 0x3d, 0xe4, 0xba, 0x4e, 0x1e, 0x23, 0xdf, 0x73, 0xa0, 0xe5,
        0x13, 0xe7, 0x80, 0xb6, 0x7c, 0x35, 0x26, 0x96, 0x43, 0x61, 0xa2, 0xfb, 0x00, 0xb8, 0x2f, 0xdf,
        0xdc, 0x05, 0xd2, 0x1e, 0xf5, 0x01, 0x8a, 0x29, 0x2c, 0x98, 0x4a, 0x7e, 0x57, 0x17, 0xe5, 0xfb,
        0x13, 0x30, 0xed, 0x71, 0x5f, 0xb0, 0x98, 0xe8, 0x35, 0x64, 0xdb, 0xdf, 0xb8, 0x05, 0xf9, 0xde,
        0x18, 0xa0, 0x3d, 0xb8, 0x02, 0x10, 0x97, 0x15, 0xf0, 0xbf, 0xec, 0x2b, 0xf3, 0x50, 0xbe, 0x5f,
        0x02, 0xd5, 0x56, 0xfa, 0x86, 0x76, 0x92, 0xca, 0x5e, 0xe4, 0x0b, 0x48, 0x25, 0xd0, 0x8b, 0x48,
        0x2f, 0x7b, 0xfb, 0x6a, 0x30, 0xdd, 0xfb, 0xe6, 0x5c, 0xe0, 0x53, 0x0f, 0x50, 0x2b, 0xf4, 0x09,
        0x8c, 0xe8, 0xb4, 0xe1, 0x8f, 0x67, 0x47, 0xcb, 0x64, 0x7d, 0xf5, 0xe7, 0x89, 0x4e, 0x8e, 0x4f,
        0x74, 0xf2, 0xfb, 0x44, 0x27, 0x9f, 0x4f, 0xf5, 0x81, 0xe3, 0x53, 0x7d, 0xe0, 0xd7, 0xa9, 0x3e,
        0xf0, 0x6e, 0xae, 0x7d, 0xb1, 0x6b, 0xb6, 0xaf, 0x76, 0x2d, 0x07, 0xc5, 0xee, 0x48, 0x70, 0x39,
        0x5b, 0xfd, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x6a, 0xc9, 0xbe, 0x8a, 0xfc, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
        // CreateWallet creates a new keyless wallet
        CreateWallet(ctx context.Context, in *MsgCreateWallet, opts ...grpc.CallOption) (*MsgCreateWalletResponse, error)
        // RecoverWallet recovers a wallet using recovery proof
        RecoverWallet(ctx context.Context, in *MsgRecoverWallet, opts ...grpc.CallOption) (*MsgRecoverWalletResponse, error)
        // SignTransaction signs a transaction using the keyless wallet
        SignTransaction(ctx context.Context, in *MsgSignTransaction, opts ...grpc.CallOption) (*MsgSignTransactionResponse, error)
        // BatchSign performs batch signing operation
        BatchSign(ctx context.Context, in *MsgBatchSign, opts ...grpc.CallOption) (*MsgBatchSignResponse, error)
        // InitiateKeyRotation initiates key rotation for a wallet
        InitiateKeyRotation(ctx context.Context, in *MsgInitiateKeyRotation, opts ...grpc.CallOption) (*MsgInitiateKeyRotationResponse, error)
        // CompleteKeyRotation completes key rotation for a wallet
        CompleteKeyRotation(ctx context.Context, in *MsgCompleteKeyRotation, opts ...grpc.CallOption) (*MsgCompleteKeyRotationResponse, error)
        // CancelKeyRotation cancels key rotation for a wallet
        CancelKeyRotation(ctx context.Context, in *MsgCancelKeyRotation, opts ...grpc.CallOption) (*MsgCancelKeyRotationResponse, error)
}

type msgClient struct {
        cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient <span class="cov0" title="0">{
        return &amp;msgClient{cc}
}</span>

func (c *msgClient) CreateWallet(ctx context.Context, in *MsgCreateWallet, opts ...grpc.CallOption) (*MsgCreateWalletResponse, error) <span class="cov0" title="0">{
        out := new(MsgCreateWalletResponse)
        err := c.cc.Invoke(ctx, "/selfchain.keyless.Msg/CreateWallet", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgClient) RecoverWallet(ctx context.Context, in *MsgRecoverWallet, opts ...grpc.CallOption) (*MsgRecoverWalletResponse, error) <span class="cov0" title="0">{
        out := new(MsgRecoverWalletResponse)
        err := c.cc.Invoke(ctx, "/selfchain.keyless.Msg/RecoverWallet", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgClient) SignTransaction(ctx context.Context, in *MsgSignTransaction, opts ...grpc.CallOption) (*MsgSignTransactionResponse, error) <span class="cov0" title="0">{
        out := new(MsgSignTransactionResponse)
        err := c.cc.Invoke(ctx, "/selfchain.keyless.Msg/SignTransaction", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgClient) BatchSign(ctx context.Context, in *MsgBatchSign, opts ...grpc.CallOption) (*MsgBatchSignResponse, error) <span class="cov0" title="0">{
        out := new(MsgBatchSignResponse)
        err := c.cc.Invoke(ctx, "/selfchain.keyless.Msg/BatchSign", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgClient) InitiateKeyRotation(ctx context.Context, in *MsgInitiateKeyRotation, opts ...grpc.CallOption) (*MsgInitiateKeyRotationResponse, error) <span class="cov0" title="0">{
        out := new(MsgInitiateKeyRotationResponse)
        err := c.cc.Invoke(ctx, "/selfchain.keyless.Msg/InitiateKeyRotation", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgClient) CompleteKeyRotation(ctx context.Context, in *MsgCompleteKeyRotation, opts ...grpc.CallOption) (*MsgCompleteKeyRotationResponse, error) <span class="cov0" title="0">{
        out := new(MsgCompleteKeyRotationResponse)
        err := c.cc.Invoke(ctx, "/selfchain.keyless.Msg/CompleteKeyRotation", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgClient) CancelKeyRotation(ctx context.Context, in *MsgCancelKeyRotation, opts ...grpc.CallOption) (*MsgCancelKeyRotationResponse, error) <span class="cov0" title="0">{
        out := new(MsgCancelKeyRotationResponse)
        err := c.cc.Invoke(ctx, "/selfchain.keyless.Msg/CancelKeyRotation", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
        // CreateWallet creates a new keyless wallet
        CreateWallet(context.Context, *MsgCreateWallet) (*MsgCreateWalletResponse, error)
        // RecoverWallet recovers a wallet using recovery proof
        RecoverWallet(context.Context, *MsgRecoverWallet) (*MsgRecoverWalletResponse, error)
        // SignTransaction signs a transaction using the keyless wallet
        SignTransaction(context.Context, *MsgSignTransaction) (*MsgSignTransactionResponse, error)
        // BatchSign performs batch signing operation
        BatchSign(context.Context, *MsgBatchSign) (*MsgBatchSignResponse, error)
        // InitiateKeyRotation initiates key rotation for a wallet
        InitiateKeyRotation(context.Context, *MsgInitiateKeyRotation) (*MsgInitiateKeyRotationResponse, error)
        // CompleteKeyRotation completes key rotation for a wallet
        CompleteKeyRotation(context.Context, *MsgCompleteKeyRotation) (*MsgCompleteKeyRotationResponse, error)
        // CancelKeyRotation cancels key rotation for a wallet
        CancelKeyRotation(context.Context, *MsgCancelKeyRotation) (*MsgCancelKeyRotationResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) CreateWallet(ctx context.Context, req *MsgCreateWallet) (*MsgCreateWalletResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateWallet not implemented")
}</span>
func (*UnimplementedMsgServer) RecoverWallet(ctx context.Context, req *MsgRecoverWallet) (*MsgRecoverWalletResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RecoverWallet not implemented")
}</span>
func (*UnimplementedMsgServer) SignTransaction(ctx context.Context, req *MsgSignTransaction) (*MsgSignTransactionResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method SignTransaction not implemented")
}</span>
func (*UnimplementedMsgServer) BatchSign(ctx context.Context, req *MsgBatchSign) (*MsgBatchSignResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method BatchSign not implemented")
}</span>
func (*UnimplementedMsgServer) InitiateKeyRotation(ctx context.Context, req *MsgInitiateKeyRotation) (*MsgInitiateKeyRotationResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method InitiateKeyRotation not implemented")
}</span>
func (*UnimplementedMsgServer) CompleteKeyRotation(ctx context.Context, req *MsgCompleteKeyRotation) (*MsgCompleteKeyRotationResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CompleteKeyRotation not implemented")
}</span>
func (*UnimplementedMsgServer) CancelKeyRotation(ctx context.Context, req *MsgCancelKeyRotation) (*MsgCancelKeyRotationResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CancelKeyRotation not implemented")
}</span>

func RegisterMsgServer(s grpc1.Server, srv MsgServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;_Msg_serviceDesc, srv)
}</span>

func _Msg_CreateWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgCreateWallet)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).CreateWallet(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/selfchain.keyless.Msg/CreateWallet",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).CreateWallet(ctx, req.(*MsgCreateWallet))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Msg_RecoverWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgRecoverWallet)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).RecoverWallet(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/selfchain.keyless.Msg/RecoverWallet",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).RecoverWallet(ctx, req.(*MsgRecoverWallet))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Msg_SignTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgSignTransaction)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).SignTransaction(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/selfchain.keyless.Msg/SignTransaction",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).SignTransaction(ctx, req.(*MsgSignTransaction))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Msg_BatchSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgBatchSign)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).BatchSign(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/selfchain.keyless.Msg/BatchSign",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).BatchSign(ctx, req.(*MsgBatchSign))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Msg_InitiateKeyRotation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgInitiateKeyRotation)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).InitiateKeyRotation(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/selfchain.keyless.Msg/InitiateKeyRotation",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).InitiateKeyRotation(ctx, req.(*MsgInitiateKeyRotation))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Msg_CompleteKeyRotation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgCompleteKeyRotation)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).CompleteKeyRotation(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/selfchain.keyless.Msg/CompleteKeyRotation",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).CompleteKeyRotation(ctx, req.(*MsgCompleteKeyRotation))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Msg_CancelKeyRotation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgCancelKeyRotation)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).CancelKeyRotation(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/selfchain.keyless.Msg/CancelKeyRotation",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).CancelKeyRotation(ctx, req.(*MsgCancelKeyRotation))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

var _Msg_serviceDesc = grpc.ServiceDesc{
        ServiceName: "selfchain.keyless.Msg",
        HandlerType: (*MsgServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateWallet",
                        Handler:    _Msg_CreateWallet_Handler,
                },
                {
                        MethodName: "RecoverWallet",
                        Handler:    _Msg_RecoverWallet_Handler,
                },
                {
                        MethodName: "SignTransaction",
                        Handler:    _Msg_SignTransaction_Handler,
                },
                {
                        MethodName: "BatchSign",
                        Handler:    _Msg_BatchSign_Handler,
                },
                {
                        MethodName: "InitiateKeyRotation",
                        Handler:    _Msg_InitiateKeyRotation_Handler,
                },
                {
                        MethodName: "CompleteKeyRotation",
                        Handler:    _Msg_CompleteKeyRotation_Handler,
                },
                {
                        MethodName: "CancelKeyRotation",
                        Handler:    _Msg_CancelKeyRotation_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "selfchain/keyless/tx.proto",
}

func (m *MsgCreateWallet) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgCreateWallet) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgCreateWallet) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.ChainId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ChainId)
                copy(dAtA[i:], m.ChainId)
                i = encodeVarintTx(dAtA, i, uint64(len(m.ChainId)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov0" title="0">if len(m.WalletAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.WalletAddress)
                copy(dAtA[i:], m.WalletAddress)
                i = encodeVarintTx(dAtA, i, uint64(len(m.WalletAddress)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.PubKey) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.PubKey)
                copy(dAtA[i:], m.PubKey)
                i = encodeVarintTx(dAtA, i, uint64(len(m.PubKey)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Creator) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Creator)
                copy(dAtA[i:], m.Creator)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgCreateWalletResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgCreateWalletResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgCreateWalletResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.WalletAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.WalletAddress)
                copy(dAtA[i:], m.WalletAddress)
                i = encodeVarintTx(dAtA, i, uint64(len(m.WalletAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgRecoverWallet) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgRecoverWallet) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgRecoverWallet) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Signature) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Signature)
                copy(dAtA[i:], m.Signature)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Signature)))
                i--
                dAtA[i] = 0x2a
        }</span>
        <span class="cov0" title="0">if len(m.NewPubKey) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.NewPubKey)
                copy(dAtA[i:], m.NewPubKey)
                i = encodeVarintTx(dAtA, i, uint64(len(m.NewPubKey)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov0" title="0">if len(m.RecoveryProof) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.RecoveryProof)
                copy(dAtA[i:], m.RecoveryProof)
                i = encodeVarintTx(dAtA, i, uint64(len(m.RecoveryProof)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.WalletAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.WalletAddress)
                copy(dAtA[i:], m.WalletAddress)
                i = encodeVarintTx(dAtA, i, uint64(len(m.WalletAddress)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Creator) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Creator)
                copy(dAtA[i:], m.Creator)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgRecoverWalletResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgRecoverWalletResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgRecoverWalletResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.WalletAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.WalletAddress)
                copy(dAtA[i:], m.WalletAddress)
                i = encodeVarintTx(dAtA, i, uint64(len(m.WalletAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgSignTransaction) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgSignTransaction) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgSignTransaction) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.ChainId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ChainId)
                copy(dAtA[i:], m.ChainId)
                i = encodeVarintTx(dAtA, i, uint64(len(m.ChainId)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov0" title="0">if len(m.UnsignedTx) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.UnsignedTx)
                copy(dAtA[i:], m.UnsignedTx)
                i = encodeVarintTx(dAtA, i, uint64(len(m.UnsignedTx)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.WalletAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.WalletAddress)
                copy(dAtA[i:], m.WalletAddress)
                i = encodeVarintTx(dAtA, i, uint64(len(m.WalletAddress)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Creator) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Creator)
                copy(dAtA[i:], m.Creator)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgSignTransactionResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgSignTransactionResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgSignTransactionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.SignedTx) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.SignedTx)
                copy(dAtA[i:], m.SignedTx)
                i = encodeVarintTx(dAtA, i, uint64(len(m.SignedTx)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgBatchSign) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgBatchSign) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgBatchSign) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.ChainId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ChainId)
                copy(dAtA[i:], m.ChainId)
                i = encodeVarintTx(dAtA, i, uint64(len(m.ChainId)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov0" title="0">if len(m.UnsignedTxs) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.UnsignedTxs) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        i -= len(m.UnsignedTxs[iNdEx])
                        copy(dAtA[i:], m.UnsignedTxs[iNdEx])
                        i = encodeVarintTx(dAtA, i, uint64(len(m.UnsignedTxs[iNdEx])))
                        i--
                        dAtA[i] = 0x1a
                }</span>
        }
        <span class="cov0" title="0">if len(m.WalletAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.WalletAddress)
                copy(dAtA[i:], m.WalletAddress)
                i = encodeVarintTx(dAtA, i, uint64(len(m.WalletAddress)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Creator) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Creator)
                copy(dAtA[i:], m.Creator)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgBatchSignResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgBatchSignResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgBatchSignResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.SignedTxs) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.SignedTxs) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        i -= len(m.SignedTxs[iNdEx])
                        copy(dAtA[i:], m.SignedTxs[iNdEx])
                        i = encodeVarintTx(dAtA, i, uint64(len(m.SignedTxs[iNdEx])))
                        i--
                        dAtA[i] = 0xa
                }</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgInitiateKeyRotation) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgInitiateKeyRotation) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgInitiateKeyRotation) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Signature) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Signature)
                copy(dAtA[i:], m.Signature)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Signature)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov0" title="0">if len(m.NewPubKey) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.NewPubKey)
                copy(dAtA[i:], m.NewPubKey)
                i = encodeVarintTx(dAtA, i, uint64(len(m.NewPubKey)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.WalletAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.WalletAddress)
                copy(dAtA[i:], m.WalletAddress)
                i = encodeVarintTx(dAtA, i, uint64(len(m.WalletAddress)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Creator) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Creator)
                copy(dAtA[i:], m.Creator)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgInitiateKeyRotationResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgInitiateKeyRotationResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgInitiateKeyRotationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.NewVersion != 0 </span><span class="cov0" title="0">{
                i = encodeVarintTx(dAtA, i, uint64(m.NewVersion))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.WalletAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.WalletAddress)
                copy(dAtA[i:], m.WalletAddress)
                i = encodeVarintTx(dAtA, i, uint64(len(m.WalletAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgCompleteKeyRotation) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgCompleteKeyRotation) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgCompleteKeyRotation) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Signature) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Signature)
                copy(dAtA[i:], m.Signature)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Signature)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov0" title="0">if m.Version != 0 </span><span class="cov0" title="0">{
                i = encodeVarintTx(dAtA, i, uint64(m.Version))
                i--
                dAtA[i] = 0x18
        }</span>
        <span class="cov0" title="0">if len(m.WalletAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.WalletAddress)
                copy(dAtA[i:], m.WalletAddress)
                i = encodeVarintTx(dAtA, i, uint64(len(m.WalletAddress)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Creator) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Creator)
                copy(dAtA[i:], m.Creator)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgCompleteKeyRotationResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgCompleteKeyRotationResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgCompleteKeyRotationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Version != 0 </span><span class="cov0" title="0">{
                i = encodeVarintTx(dAtA, i, uint64(m.Version))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.WalletAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.WalletAddress)
                copy(dAtA[i:], m.WalletAddress)
                i = encodeVarintTx(dAtA, i, uint64(len(m.WalletAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgCancelKeyRotation) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgCancelKeyRotation) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgCancelKeyRotation) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Version != 0 </span><span class="cov0" title="0">{
                i = encodeVarintTx(dAtA, i, uint64(m.Version))
                i--
                dAtA[i] = 0x18
        }</span>
        <span class="cov0" title="0">if len(m.WalletAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.WalletAddress)
                copy(dAtA[i:], m.WalletAddress)
                i = encodeVarintTx(dAtA, i, uint64(len(m.WalletAddress)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Creator) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Creator)
                copy(dAtA[i:], m.Creator)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgCancelKeyRotationResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgCancelKeyRotationResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgCancelKeyRotationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.WalletAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.WalletAddress)
                copy(dAtA[i:], m.WalletAddress)
                i = encodeVarintTx(dAtA, i, uint64(len(m.WalletAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovTx(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *MsgCreateWallet) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Creator)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.PubKey)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.WalletAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.ChainId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgCreateWalletResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.WalletAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgRecoverWallet) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Creator)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.WalletAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.RecoveryProof)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.NewPubKey)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Signature)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgRecoverWalletResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.WalletAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgSignTransaction) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Creator)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.WalletAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.UnsignedTx)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.ChainId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgSignTransactionResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.SignedTx)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgBatchSign) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Creator)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.WalletAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">if len(m.UnsignedTxs) &gt; 0 </span><span class="cov0" title="0">{
                for _, s := range m.UnsignedTxs </span><span class="cov0" title="0">{
                        l = len(s)
                        n += 1 + l + sovTx(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">l = len(m.ChainId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgBatchSignResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.SignedTxs) &gt; 0 </span><span class="cov0" title="0">{
                for _, s := range m.SignedTxs </span><span class="cov0" title="0">{
                        l = len(s)
                        n += 1 + l + sovTx(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *MsgInitiateKeyRotation) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Creator)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.WalletAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.NewPubKey)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Signature)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgInitiateKeyRotationResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.WalletAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.NewVersion != 0 </span><span class="cov0" title="0">{
                n += 1 + sovTx(uint64(m.NewVersion))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgCompleteKeyRotation) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Creator)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.WalletAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Version != 0 </span><span class="cov0" title="0">{
                n += 1 + sovTx(uint64(m.Version))
        }</span>
        <span class="cov0" title="0">l = len(m.Signature)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgCompleteKeyRotationResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.WalletAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Version != 0 </span><span class="cov0" title="0">{
                n += 1 + sovTx(uint64(m.Version))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgCancelKeyRotation) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Creator)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.WalletAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Version != 0 </span><span class="cov0" title="0">{
                n += 1 + sovTx(uint64(m.Version))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgCancelKeyRotationResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.WalletAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovTx(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozTx(x uint64) (n int) <span class="cov0" title="0">{
        return sovTx(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *MsgCreateWallet) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgCreateWallet: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgCreateWallet: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Creator = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.PubKey = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WalletAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.WalletAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ChainId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgCreateWalletResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgCreateWalletResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgCreateWalletResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WalletAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.WalletAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgRecoverWallet) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgRecoverWallet: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgRecoverWallet: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Creator = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WalletAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.WalletAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field RecoveryProof", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.RecoveryProof = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field NewPubKey", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.NewPubKey = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 5:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Signature = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgRecoverWalletResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgRecoverWalletResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgRecoverWalletResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WalletAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.WalletAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgSignTransaction) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgSignTransaction: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgSignTransaction: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Creator = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WalletAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.WalletAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field UnsignedTx", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.UnsignedTx = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ChainId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgSignTransactionResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgSignTransactionResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgSignTransactionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SignedTx", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.SignedTx = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgBatchSign) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgBatchSign: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgBatchSign: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Creator = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WalletAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.WalletAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field UnsignedTxs", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.UnsignedTxs = append(m.UnsignedTxs, string(dAtA[iNdEx:postIndex]))
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ChainId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgBatchSignResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgBatchSignResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgBatchSignResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SignedTxs", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.SignedTxs = append(m.SignedTxs, string(dAtA[iNdEx:postIndex]))
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgInitiateKeyRotation) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgInitiateKeyRotation: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgInitiateKeyRotation: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Creator = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WalletAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.WalletAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field NewPubKey", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.NewPubKey = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Signature = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgInitiateKeyRotationResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgInitiateKeyRotationResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgInitiateKeyRotationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WalletAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.WalletAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field NewVersion", wireType)
                        }</span>
                        <span class="cov0" title="0">m.NewVersion = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.NewVersion |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgCompleteKeyRotation) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgCompleteKeyRotation: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgCompleteKeyRotation: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Creator = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WalletAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.WalletAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Version = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Version |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Signature = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgCompleteKeyRotationResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgCompleteKeyRotationResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgCompleteKeyRotationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WalletAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.WalletAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Version = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Version |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgCancelKeyRotation) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgCancelKeyRotation: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgCancelKeyRotation: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Creator = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WalletAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.WalletAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Version = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Version |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgCancelKeyRotationResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgCancelKeyRotationResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgCancelKeyRotationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WalletAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.WalletAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipTx(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupTx
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthTx
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file57" style="display: none">package types

import "time"

// NewWallet creates a new Wallet instance
func NewWallet(id, publicKey string, securityLevel, threshold, parties uint32) *Wallet <span class="cov0" title="0">{
        now := time.Now()
        return &amp;Wallet{
                Id:            id,
                PublicKey:     publicKey,
                KeyVersion:    1,
                Permissions:   make([]string, 0),
                CreatedAt:     &amp;now,
                UpdatedAt:     &amp;now,
                Metadata:      make(map[string]string),
                SecurityLevel: securityLevel,
                Threshold:     threshold,
                Parties:       parties,
        }
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: selfchain/keyless/wallet.proto

package types

import (
        fmt "fmt"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
        _ "google.golang.org/protobuf/types/known/timestamppb"
        io "io"
        math "math"
        math_bits "math/bits"
        time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Wallet represents a keyless wallet
type Wallet struct {
        Id            string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Address       string            `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
        PublicKey     string            `protobuf:"bytes,3,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
        KeyVersion    uint32            `protobuf:"varint,4,opt,name=key_version,json=keyVersion,proto3" json:"key_version,omitempty"`
        Permissions   []string          `protobuf:"bytes,5,rep,name=permissions,proto3" json:"permissions,omitempty"`
        CreatedAt     *time.Time        `protobuf:"bytes,6,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at,omitempty"`
        UpdatedAt     *time.Time        `protobuf:"bytes,7,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at,omitempty"`
        Metadata      map[string]string `protobuf:"bytes,8,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        SecurityLevel uint32            `protobuf:"varint,9,opt,name=security_level,json=securityLevel,proto3" json:"security_level,omitempty"`
        Threshold     uint32            `protobuf:"varint,10,opt,name=threshold,proto3" json:"threshold,omitempty"`
        Parties       uint32            `protobuf:"varint,11,opt,name=parties,proto3" json:"parties,omitempty"`
        Status        string            `protobuf:"bytes,12,opt,name=status,proto3" json:"status,omitempty"`
        ChainId       string            `protobuf:"bytes,13,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *Wallet) Reset()         <span class="cov0" title="0">{ *m = Wallet{} }</span>
func (m *Wallet) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Wallet) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Wallet) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_26dddf90ae5a75d4, []int{0}
}</span>
func (m *Wallet) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Wallet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Wallet.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Wallet) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Wallet.Merge(m, src)
}</span>
func (m *Wallet) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Wallet) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Wallet.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Wallet proto.InternalMessageInfo

func (m *Wallet) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Wallet) GetAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Address
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Wallet) GetPublicKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PublicKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Wallet) GetKeyVersion() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyVersion
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Wallet) GetPermissions() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Permissions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Wallet) GetCreatedAt() *time.Time <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Wallet) GetUpdatedAt() *time.Time <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UpdatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Wallet) GetMetadata() map[string]string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Wallet) GetSecurityLevel() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SecurityLevel
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Wallet) GetThreshold() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Threshold
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Wallet) GetParties() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Parties
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Wallet) GetStatus() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Wallet) GetChainId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ChainId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*Wallet)(nil), "selfchain.keyless.Wallet")
        proto.RegisterMapType((map[string]string)(nil), "selfchain.keyless.Wallet.MetadataEntry")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("selfchain/keyless/wallet.proto", fileDescriptor_26dddf90ae5a75d4) }</span>

var fileDescriptor_26dddf90ae5a75d4 = []byte{
        // 457 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x52, 0xc1, 0x6e, 0xd3, 0x40,
        0x10, 0x8d, 0x93, 0x34, 0x8d, 0xc7, 0xa4, 0x82, 0x55, 0x85, 0xb6, 0x11, 0x38, 0x16, 0x12, 0xc2,
        0x27, 0x5b, 0x6a, 0x2f, 0x08, 0x0e, 0xa8, 0x45, 0x1c, 0x10, 0x70, 0xb1, 0x10, 0x48, 0x5c, 0xac,
        0x4d, 0x76, 0x9a, 0xac, 0xb2, 0x89, 0x2d, 0xef, 0x3a, 0xe0, 0xbf, 0xe8, 0x77, 0xf0, 0x25, 0x1c,
        0x7b, 0xe4, 0x06, 0x4a, 0x7e, 0x04, 0x79, 0xd7, 0x4e, 0x40, 0x5c, 0x7a, 0xdb, 0xf7, 0xde, 0xcc,
        0x68, 0xe7, 0xbd, 0x01, 0x5f, 0xa1, 0xbc, 0x9e, 0x2d, 0x98, 0x58, 0xc7, 0x4b, 0xac, 0x24, 0x2a,
        0x15, 0x7f, 0x65, 0x52, 0xa2, 0x8e, 0xf2, 0x22, 0xd3, 0x19, 0x79, 0xb0, 0xd7, 0xa3, 0x46, 0x1f,
        0x9f, 0xce, 0xb3, 0x79, 0x66, 0xd4, 0xb8, 0x7e, 0xd9, 0xc2, 0xf1, 0x64, 0x9e, 0x65, 0x73, 0x89,
        0xb1, 0x41, 0xd3, 0xf2, 0x3a, 0xd6, 0x62, 0x85, 0x4a, 0xb3, 0x55, 0x6e, 0x0b, 0x9e, 0x7c, 0xef,
        0xc3, 0xe0, 0xb3, 0x19, 0x4d, 0x4e, 0xa0, 0x2b, 0x38, 0x75, 0x02, 0x27, 0x74, 0x93, 0xae, 0xe0,
        0x84, 0xc2, 0x31, 0xe3, 0xbc, 0x40, 0xa5, 0x68, 0xd7, 0x90, 0x2d, 0x24, 0x8f, 0x01, 0xf2, 0x72,
        0x2a, 0xc5, 0x2c, 0x5d, 0x62, 0x45, 0x7b, 0x46, 0x74, 0x2d, 0xf3, 0x0e, 0x2b, 0x32, 0x01, 0x6f,
        0x89, 0x55, 0xba, 0xc1, 0x42, 0x89, 0x6c, 0x4d, 0xfb, 0x81, 0x13, 0x8e, 0x12, 0x58, 0x62, 0xf5,
        0xc9, 0x32, 0x24, 0x00, 0x2f, 0xc7, 0x62, 0x25, 0x54, 0x8d, 0x14, 0x3d, 0x0a, 0x7a, 0xa1, 0x9b,
        0xfc, 0x4d, 0x91, 0x57, 0x00, 0xb3, 0x02, 0x99, 0x46, 0x9e, 0x32, 0x4d, 0x07, 0x81, 0x13, 0x7a,
        0xe7, 0xe3, 0xc8, 0x2e, 0x13, 0xb5, 0xcb, 0x44, 0x1f, 0xdb, 0x65, 0xae, 0xfa, 0x37, 0xbf, 0x26,
        0x4e, 0xe2, 0x36, 0x3d, 0x97, 0xba, 0x1e, 0x50, 0xe6, 0xbc, 0x1d, 0x70, 0x7c, 0xd7, 0x01, 0x4d,
        0xcf, 0xa5, 0x26, 0xaf, 0x61, 0xb8, 0x42, 0xcd, 0x38, 0xd3, 0x8c, 0x0e, 0x83, 0x5e, 0xe8, 0x9d,
        0x3f, 0x8b, 0xfe, 0x73, 0x3d, 0xb2, 0xd6, 0x45, 0x1f, 0x9a, 0xca, 0x37, 0x6b, 0x5d, 0x54, 0xc9,
        0xbe, 0x91, 0x3c, 0x85, 0x13, 0x85, 0xb3, 0xb2, 0x10, 0xba, 0x4a, 0x25, 0x6e, 0x50, 0x52, 0xd7,
        0x98, 0x31, 0x6a, 0xd9, 0xf7, 0x35, 0x49, 0x1e, 0x81, 0xab, 0x17, 0x05, 0xaa, 0x45, 0x26, 0x39,
        0x05, 0x53, 0x71, 0x20, 0xea, 0x1c, 0x72, 0x56, 0x68, 0x81, 0x8a, 0x7a, 0x46, 0x6b, 0x21, 0x79,
        0x08, 0x03, 0xa5, 0x99, 0x2e, 0x15, 0xbd, 0x67, 0x32, 0x68, 0x10, 0x39, 0x83, 0xa1, 0xf9, 0x66,
        0x2a, 0x38, 0x1d, 0xd9, 0xe8, 0x0c, 0x7e, 0xcb, 0xc7, 0x2f, 0x61, 0xf4, 0xcf, 0x67, 0xc9, 0x7d,
        0xe8, 0xd5, 0x21, 0xda, 0xd8, 0xeb, 0x27, 0x39, 0x85, 0xa3, 0x0d, 0x93, 0x25, 0x36, 0xa9, 0x5b,
        0xf0, 0xa2, 0xfb, 0xdc, 0xb9, 0xba, 0xf8, 0xb1, 0xf5, 0x9d, 0xdb, 0xad, 0xef, 0xfc, 0xde, 0xfa,
        0xce, 0xcd, 0xce, 0xef, 0xdc, 0xee, 0xfc, 0xce, 0xcf, 0x9d, 0xdf, 0xf9, 0x72, 0x76, 0x38, 0xd8,
        0x6f, 0xfb, 0x93, 0xd5, 0x55, 0x8e, 0x6a, 0x3a, 0x30, 0x6e, 0x5f, 0xfc, 0x09, 0x00, 0x00, 0xff,
        0xff, 0xe3, 0x2d, 0x66, 0x19, 0xd4, 0x02, 0x00, 0x00,
}

func (m *Wallet) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Wallet) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Wallet) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.ChainId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ChainId)
                copy(dAtA[i:], m.ChainId)
                i = encodeVarintWallet(dAtA, i, uint64(len(m.ChainId)))
                i--
                dAtA[i] = 0x6a
        }</span>
        <span class="cov0" title="0">if len(m.Status) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Status)
                copy(dAtA[i:], m.Status)
                i = encodeVarintWallet(dAtA, i, uint64(len(m.Status)))
                i--
                dAtA[i] = 0x62
        }</span>
        <span class="cov0" title="0">if m.Parties != 0 </span><span class="cov0" title="0">{
                i = encodeVarintWallet(dAtA, i, uint64(m.Parties))
                i--
                dAtA[i] = 0x58
        }</span>
        <span class="cov0" title="0">if m.Threshold != 0 </span><span class="cov0" title="0">{
                i = encodeVarintWallet(dAtA, i, uint64(m.Threshold))
                i--
                dAtA[i] = 0x50
        }</span>
        <span class="cov0" title="0">if m.SecurityLevel != 0 </span><span class="cov0" title="0">{
                i = encodeVarintWallet(dAtA, i, uint64(m.SecurityLevel))
                i--
                dAtA[i] = 0x48
        }</span>
        <span class="cov0" title="0">if len(m.Metadata) &gt; 0 </span><span class="cov0" title="0">{
                for k := range m.Metadata </span><span class="cov0" title="0">{
                        v := m.Metadata[k]
                        baseI := i
                        i -= len(v)
                        copy(dAtA[i:], v)
                        i = encodeVarintWallet(dAtA, i, uint64(len(v)))
                        i--
                        dAtA[i] = 0x12
                        i -= len(k)
                        copy(dAtA[i:], k)
                        i = encodeVarintWallet(dAtA, i, uint64(len(k)))
                        i--
                        dAtA[i] = 0xa
                        i = encodeVarintWallet(dAtA, i, uint64(baseI-i))
                        i--
                        dAtA[i] = 0x42
                }</span>
        }
        <span class="cov0" title="0">if m.UpdatedAt != nil </span><span class="cov0" title="0">{
                n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.UpdatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.UpdatedAt):])
                if err1 != nil </span><span class="cov0" title="0">{
                        return 0, err1
                }</span>
                <span class="cov0" title="0">i -= n1
                i = encodeVarintWallet(dAtA, i, uint64(n1))
                i--
                dAtA[i] = 0x3a</span>
        }
        <span class="cov0" title="0">if m.CreatedAt != nil </span><span class="cov0" title="0">{
                n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.CreatedAt):])
                if err2 != nil </span><span class="cov0" title="0">{
                        return 0, err2
                }</span>
                <span class="cov0" title="0">i -= n2
                i = encodeVarintWallet(dAtA, i, uint64(n2))
                i--
                dAtA[i] = 0x32</span>
        }
        <span class="cov0" title="0">if len(m.Permissions) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Permissions) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        i -= len(m.Permissions[iNdEx])
                        copy(dAtA[i:], m.Permissions[iNdEx])
                        i = encodeVarintWallet(dAtA, i, uint64(len(m.Permissions[iNdEx])))
                        i--
                        dAtA[i] = 0x2a
                }</span>
        }
        <span class="cov0" title="0">if m.KeyVersion != 0 </span><span class="cov0" title="0">{
                i = encodeVarintWallet(dAtA, i, uint64(m.KeyVersion))
                i--
                dAtA[i] = 0x20
        }</span>
        <span class="cov0" title="0">if len(m.PublicKey) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.PublicKey)
                copy(dAtA[i:], m.PublicKey)
                i = encodeVarintWallet(dAtA, i, uint64(len(m.PublicKey)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.Address) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Address)
                copy(dAtA[i:], m.Address)
                i = encodeVarintWallet(dAtA, i, uint64(len(m.Address)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Id) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Id)
                copy(dAtA[i:], m.Id)
                i = encodeVarintWallet(dAtA, i, uint64(len(m.Id)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintWallet(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovWallet(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *Wallet) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Id)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovWallet(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Address)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovWallet(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.PublicKey)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovWallet(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.KeyVersion != 0 </span><span class="cov0" title="0">{
                n += 1 + sovWallet(uint64(m.KeyVersion))
        }</span>
        <span class="cov0" title="0">if len(m.Permissions) &gt; 0 </span><span class="cov0" title="0">{
                for _, s := range m.Permissions </span><span class="cov0" title="0">{
                        l = len(s)
                        n += 1 + l + sovWallet(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">if m.CreatedAt != nil </span><span class="cov0" title="0">{
                l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.CreatedAt)
                n += 1 + l + sovWallet(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.UpdatedAt != nil </span><span class="cov0" title="0">{
                l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.UpdatedAt)
                n += 1 + l + sovWallet(uint64(l))
        }</span>
        <span class="cov0" title="0">if len(m.Metadata) &gt; 0 </span><span class="cov0" title="0">{
                for k, v := range m.Metadata </span><span class="cov0" title="0">{
                        _ = k
                        _ = v
                        mapEntrySize := 1 + len(k) + sovWallet(uint64(len(k))) + 1 + len(v) + sovWallet(uint64(len(v)))
                        n += mapEntrySize + 1 + sovWallet(uint64(mapEntrySize))
                }</span>
        }
        <span class="cov0" title="0">if m.SecurityLevel != 0 </span><span class="cov0" title="0">{
                n += 1 + sovWallet(uint64(m.SecurityLevel))
        }</span>
        <span class="cov0" title="0">if m.Threshold != 0 </span><span class="cov0" title="0">{
                n += 1 + sovWallet(uint64(m.Threshold))
        }</span>
        <span class="cov0" title="0">if m.Parties != 0 </span><span class="cov0" title="0">{
                n += 1 + sovWallet(uint64(m.Parties))
        }</span>
        <span class="cov0" title="0">l = len(m.Status)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovWallet(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.ChainId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovWallet(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovWallet(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozWallet(x uint64) (n int) <span class="cov0" title="0">{
        return sovWallet(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *Wallet) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowWallet
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Wallet: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Wallet: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowWallet
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthWallet
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthWallet
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Id = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowWallet
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthWallet
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthWallet
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Address = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowWallet
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthWallet
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthWallet
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.PublicKey = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field KeyVersion", wireType)
                        }</span>
                        <span class="cov0" title="0">m.KeyVersion = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowWallet
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.KeyVersion |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 5:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowWallet
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthWallet
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthWallet
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Permissions = append(m.Permissions, string(dAtA[iNdEx:postIndex]))
                        iNdEx = postIndex</span>
                case 6:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowWallet
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthWallet
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthWallet
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.CreatedAt == nil </span><span class="cov0" title="0">{
                                m.CreatedAt = new(time.Time)
                        }</span>
                        <span class="cov0" title="0">if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 7:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowWallet
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthWallet
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthWallet
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.UpdatedAt == nil </span><span class="cov0" title="0">{
                                m.UpdatedAt = new(time.Time)
                        }</span>
                        <span class="cov0" title="0">if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 8:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowWallet
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthWallet
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthWallet
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Metadata == nil </span><span class="cov0" title="0">{
                                m.Metadata = make(map[string]string)
                        }</span>
                        <span class="cov0" title="0">var mapkey string
                        var mapvalue string
                        for iNdEx &lt; postIndex </span><span class="cov0" title="0">{
                                entryPreIndex := iNdEx
                                var wire uint64
                                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                                return ErrIntOverflowWallet
                                        }</span>
                                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                                return io.ErrUnexpectedEOF
                                        }</span>
                                        <span class="cov0" title="0">b := dAtA[iNdEx]
                                        iNdEx++
                                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                                if fieldNum == 1 </span><span class="cov0" title="0">{
                                        var stringLenmapkey uint64
                                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                                        return ErrIntOverflowWallet
                                                }</span>
                                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                                        return io.ErrUnexpectedEOF
                                                }</span>
                                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                                iNdEx++
                                                stringLenmapkey |= uint64(b&amp;0x7F) &lt;&lt; shift
                                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                                        break</span>
                                                }
                                        }
                                        <span class="cov0" title="0">intStringLenmapkey := int(stringLenmapkey)
                                        if intStringLenmapkey &lt; 0 </span><span class="cov0" title="0">{
                                                return ErrInvalidLengthWallet
                                        }</span>
                                        <span class="cov0" title="0">postStringIndexmapkey := iNdEx + intStringLenmapkey
                                        if postStringIndexmapkey &lt; 0 </span><span class="cov0" title="0">{
                                                return ErrInvalidLengthWallet
                                        }</span>
                                        <span class="cov0" title="0">if postStringIndexmapkey &gt; l </span><span class="cov0" title="0">{
                                                return io.ErrUnexpectedEOF
                                        }</span>
                                        <span class="cov0" title="0">mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
                                        iNdEx = postStringIndexmapkey</span>
                                } else<span class="cov0" title="0"> if fieldNum == 2 </span><span class="cov0" title="0">{
                                        var stringLenmapvalue uint64
                                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                                        return ErrIntOverflowWallet
                                                }</span>
                                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                                        return io.ErrUnexpectedEOF
                                                }</span>
                                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                                iNdEx++
                                                stringLenmapvalue |= uint64(b&amp;0x7F) &lt;&lt; shift
                                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                                        break</span>
                                                }
                                        }
                                        <span class="cov0" title="0">intStringLenmapvalue := int(stringLenmapvalue)
                                        if intStringLenmapvalue &lt; 0 </span><span class="cov0" title="0">{
                                                return ErrInvalidLengthWallet
                                        }</span>
                                        <span class="cov0" title="0">postStringIndexmapvalue := iNdEx + intStringLenmapvalue
                                        if postStringIndexmapvalue &lt; 0 </span><span class="cov0" title="0">{
                                                return ErrInvalidLengthWallet
                                        }</span>
                                        <span class="cov0" title="0">if postStringIndexmapvalue &gt; l </span><span class="cov0" title="0">{
                                                return io.ErrUnexpectedEOF
                                        }</span>
                                        <span class="cov0" title="0">mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
                                        iNdEx = postStringIndexmapvalue</span>
                                } else<span class="cov0" title="0"> {
                                        iNdEx = entryPreIndex
                                        skippy, err := skipWallet(dAtA[iNdEx:])
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                                return ErrInvalidLengthWallet
                                        }</span>
                                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; postIndex </span><span class="cov0" title="0">{
                                                return io.ErrUnexpectedEOF
                                        }</span>
                                        <span class="cov0" title="0">iNdEx += skippy</span>
                                }
                        }
                        <span class="cov0" title="0">m.Metadata[mapkey] = mapvalue
                        iNdEx = postIndex</span>
                case 9:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SecurityLevel", wireType)
                        }</span>
                        <span class="cov0" title="0">m.SecurityLevel = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowWallet
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.SecurityLevel |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 10:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Threshold = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowWallet
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Threshold |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 11:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Parties", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Parties = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowWallet
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Parties |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 12:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowWallet
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthWallet
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthWallet
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Status = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 13:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowWallet
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthWallet
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthWallet
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ChainId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipWallet(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthWallet
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipWallet(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowWallet
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowWallet
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowWallet
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthWallet
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupWallet
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthWallet
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthWallet        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowWallet          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupWallet = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
